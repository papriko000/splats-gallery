/*! For license information please see launcher.js.LICENSE.txt */
(()=>{"use strict";var t={184:(t,A,e)=>{e.d(A,{$EB:()=>d,$Ed:()=>kr,$Kf:()=>Oa,$NF:()=>xc,$O9:()=>ft,$Yl:()=>H,$_I:()=>Dt,$ei:()=>D,$p8:()=>zc,A$4:()=>fs,AKb:()=>tc,ALV:()=>Gn,AQS:()=>rn,Am1:()=>rl,B69:()=>Ui,B6O:()=>_o,BER:()=>ot,BH$:()=>jr,BKk:()=>Xs,BND:()=>DI,BRH:()=>Dc,BXX:()=>AA,B_h:()=>cA,CR7:()=>Ie,CSG:()=>zg,CV9:()=>Ho,CVz:()=>aA,CWW:()=>MA,Cfg:()=>mt,CmU:()=>Zc,CwR:()=>Sl,D$Q:()=>Ug,DAe:()=>HA,DXC:()=>Vr,Df:()=>Pg,Dmk:()=>Ht,E0M:()=>RI,EAD:()=>ja,EQC:()=>kA,EZo:()=>Q,EdD:()=>f,F1T:()=>sa,F1l:()=>cI,FCc:()=>Wr,FFZ:()=>we,FNr:()=>Kg,FV:()=>it,FXf:()=>w,FZo:()=>Vc,Fn:()=>yA,Fpm:()=>iI,FvD:()=>ao,Fvi:()=>gt,Fvt:()=>Vg,G3T:()=>bA,G4u:()=>Le,GBG:()=>gc,GJx:()=>dt,GOR:()=>go,GWd:()=>Jt,GYF:()=>Ka,GZZ:()=>Go,G_z:()=>qg,Gu$:()=>Mg,Gwm:()=>V,GxU:()=>Is,H23:()=>wA,H2z:()=>kI,HIg:()=>Pt,HLH:()=>ie,HO_:()=>vA,HPb:()=>ge,HXV:()=>iA,HgN:()=>wn,HiM:()=>Yc,Hit:()=>oc,Ho_:()=>ho,Hrb:()=>ps,Hrq:()=>_e,I46:()=>za,I9Y:()=>$e,IE4:()=>Xt,IUQ:()=>_n,IWo:()=>SI,Iit:()=>Ws,Ipv:()=>yo,Iw4:()=>Ul,IzY:()=>FI,Jnc:()=>o,K52:()=>W,KDk:()=>oA,KLL:()=>te,KPJ:()=>dc,KRh:()=>X,Ke9:()=>LA,Kef:()=>SA,Ktl:()=>De,Kwu:()=>p,Kzg:()=>il,LAk:()=>at,Ld9:()=>NI,LiQ:()=>_,LlO:()=>Zs,LoY:()=>Fs,LuO:()=>Jl,MBL:()=>cc,MOq:()=>Re,MSw:()=>vg,MW4:()=>ys,Mjd:()=>et,Mmk:()=>dn,N1A:()=>qr,N2s:()=>Dl,N5j:()=>zA,NRn:()=>Un,NTi:()=>E,NZq:()=>vt,Nex:()=>TI,Nt7:()=>k,Nv2:()=>no,Nwf:()=>Nl,Nz6:()=>$t,O0B:()=>Rn,O3Y:()=>_g,O49:()=>PA,O9p:()=>fi,ONl:()=>Ao,OUM:()=>Mt,Oax:()=>ws,Om:()=>Bt,OuU:()=>F,P5j:()=>kl,PFK:()=>pI,PJ3:()=>NA,PPD:()=>hr,PTz:()=>tn,Pdi:()=>ec,Pem:()=>so,Pf$:()=>Ql,Pq0:()=>An,Q1f:()=>ns,QCA:()=>fg,QP0:()=>l,Qev:()=>Ye,Qrf:()=>hA,R1W:()=>uI,R3r:()=>ca,RJ4:()=>YA,ROr:()=>se,RQf:()=>kt,RcT:()=>he,RiT:()=>Ic,Riy:()=>rA,Rkk:()=>qA,RlV:()=>ci,RoJ:()=>Ca,RrE:()=>L,Ru$:()=>ae,RyA:()=>h,S$4:()=>mA,S20:()=>wo,SUR:()=>Xc,SYV:()=>io,ScU:()=>Sc,T6I:()=>rc,TDQ:()=>mo,THS:()=>ds,TM5:()=>He,TMh:()=>Be,Tap:()=>vc,TdN:()=>Te,TiK:()=>pe,TkQ:()=>Wt,U3G:()=>K,UJ6:()=>sc,UPV:()=>Rg,UTZ:()=>ct,Ufg:()=>xg,UpK:()=>ka,UtB:()=>$l,UtX:()=>al,V3x:()=>Lt,V9B:()=>rs,VCu:()=>co,VGF:()=>jt,VT0:()=>Ot,VVr:()=>ee,Vb5:()=>r,VnP:()=>Uo,Vnu:()=>Se,Vwu:()=>GI,VxR:()=>$A,W9U:()=>xA,WBB:()=>yg,WNZ:()=>a,WTh:()=>yI,Wdf:()=>ke,Wew:()=>Gt,Wk7:()=>I,Wyr:()=>Ne,XG_:()=>DA,XIg:()=>C,XJ7:()=>Ng,XMJ:()=>Ll,XTe:()=>$c,XrR:()=>$,Y9S:()=>fc,YHV:()=>Wl,YJl:()=>oa,YOZ:()=>ac,YRT:()=>yc,Yhb:()=>ic,Yuy:()=>Ft,Z0B:()=>ko,Z58:()=>ha,ZLX:()=>sr,ZM4:()=>vI,ZQM:()=>Kt,Zcv:()=>gr,Zpd:()=>bg,Zr2:()=>XA,ZyN:()=>qc,_4j:()=>Lg,_QJ:()=>dA,_Ut:()=>js,_xc:()=>oI,a$r:()=>yt,a55:()=>ze,a5J:()=>BA,aEY:()=>G,aHM:()=>Ec,aJ8:()=>rt,aMy:()=>_A,aVO:()=>Og,agE:()=>xe,amv:()=>Ce,b4q:()=>aa,bC7:()=>QA,bCz:()=>m,bI3:()=>VA,bTm:()=>c,baL:()=>Es,bdM:()=>Sg,bkx:()=>Nt,brA:()=>z,bw0:()=>j,c5h:()=>oo,c90:()=>Zt,cHt:()=>Rt,cRK:()=>la,cZY:()=>eI,caT:()=>Z,cj9:()=>Xe,czI:()=>lA,dAo:()=>Lo,dYF:()=>Tn,dcC:()=>zt,dhZ:()=>UA,dth:()=>bc,dwI:()=>sn,dzP:()=>Pl,e0p:()=>Y,eB$:()=>ua,eHc:()=>J,eHs:()=>da,eaF:()=>zs,eoi:()=>fe,er$:()=>ZA,ezk:()=>nc,f4X:()=>b,fBL:()=>_t,fJr:()=>re,fP5:()=>pl,fTw:()=>BI,fc6:()=>Qs,g7M:()=>st,gJ2:()=>Ut,gO9:()=>y,gPd:()=>bn,gWB:()=>ye,ghU:()=>Ct,h2z:()=>GA,hB5:()=>u,hIf:()=>Me,hZF:()=>lc,h_9:()=>Cc,hdd:()=>N,hgQ:()=>U,hjs:()=>jl,hsX:()=>B,hxR:()=>Qt,hy7:()=>lt,hzE:()=>dI,i7d:()=>$s,i7u:()=>Ge,iNn:()=>Ks,iOZ:()=>ro,iUH:()=>St,ibB:()=>xo,ie2:()=>R,imn:()=>as,ix0:()=>Tt,iyt:()=>ei,j6:()=>Fg,jGm:()=>Jo,jR7:()=>tA,jUj:()=>Ia,jej:()=>un,jf0:()=>jA,jsO:()=>le,jut:()=>Wc,jzd:()=>me,k6Q:()=>eA,k6q:()=>wt,k8v:()=>KA,kBv:()=>i,kEx:()=>mc,kG0:()=>ne,kLi:()=>Sn,kO0:()=>Qe,kRr:()=>xt,kTW:()=>Et,kTp:()=>nA,kYr:()=>ce,k_V:()=>Zl,keZ:()=>ll,klZ:()=>ue,kn4:()=>li,kqe:()=>Ae,kxk:()=>_a,kyO:()=>At,l2R:()=>Bc,lGu:()=>q,lGw:()=>Ac,lMl:()=>Xi,lPF:()=>ln,lc7:()=>RA,ljd:()=>FA,lxW:()=>Vs,lyL:()=>EA,mcG:()=>hn,mrM:()=>Tr,nCl:()=>Tc,nEu:()=>Co,nNL:()=>nt,nST:()=>x,nWS:()=>Fn,nZQ:()=>Il,nc$:()=>Hl,nzx:()=>wg,o6l:()=>ra,oVO:()=>oe,oh6:()=>ql,ojh:()=>v,ojs:()=>fA,ov9:()=>P,pBf:()=>sA,pFK:()=>Bo,pHI:()=>pt,pPE:()=>Tl,paN:()=>Vt,ppV:()=>pn,psI:()=>uA,q2:()=>Gg,qBx:()=>Jg,qFE:()=>uo,qU7:()=>lo,qUd:()=>Pc,qa3:()=>gA,qad:()=>M,qq$:()=>cn,qtW:()=>xs,r6x:()=>jc,rFo:()=>Nn,rKP:()=>Dg,rOG:()=>Fe,rQf:()=>TA,rSH:()=>IA,rYR:()=>JA,s0K:()=>To,sKt:()=>de,sPf:()=>n,tBo:()=>Ol,tJf:()=>bt,tXL:()=>Yg,tcD:()=>Io,tz3:()=>hc,uB5:()=>CA,uSd:()=>Hg,uV5:()=>ut,uWO:()=>Za,uXQ:()=>ve,ubm:()=>na,uf3:()=>dr,uov:()=>be,ure:()=>Oc,v9J:()=>Ue,veJ:()=>Mc,vim:()=>Ee,vmz:()=>ms,vyJ:()=>WA,wAk:()=>qo,wTz:()=>OA,wfO:()=>ht,wn6:()=>T,wrO:()=>Yt,wtR:()=>s,wvS:()=>Cs,xFO:()=>It,xJ6:()=>Eg,xOk:()=>Kc,xSv:()=>O,xZx:()=>xl,xfg:()=>Yo,xiE:()=>Bn,y3Z:()=>pA,y9J:()=>kn,y_p:()=>tt,ypk:()=>zo,ywQ:()=>g,zD7:()=>hl,zdS:()=>qt,zgK:()=>mi,znC:()=>S});const n="178",i={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},s={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},a=0,r=1,o=2,g=3,c=0,l=1,I=2,h=3,u=0,B=1,d=2,C=0,E=1,Q=2,p=3,f=4,m=5,y=100,w=101,x=102,S=103,D=104,v=200,M=201,b=202,_=203,R=204,F=205,N=206,k=207,T=208,G=209,U=210,L=211,H=212,Y=213,P=214,J=0,q=1,z=2,O=3,K=4,V=5,W=6,j=7,Z=0,X=1,$=2,tt=0,At=1,et=2,nt=3,it=4,st=5,at=6,rt=7,ot="attached",gt="detached",ct=300,lt=301,It=302,ht=303,ut=304,Bt=306,dt=1e3,Ct=1001,Et=1002,Qt=1003,pt=1004,ft=1004,mt=1005,yt=1005,wt=1006,xt=1007,St=1007,Dt=1008,vt=1008,Mt=1009,bt=1010,_t=1011,Rt=1012,Ft=1013,Nt=1014,kt=1015,Tt=1016,Gt=1017,Ut=1018,Lt=1020,Ht=35902,Yt=1021,Pt=1022,Jt=1023,qt=1026,zt=1027,Ot=1028,Kt=1029,Vt=1030,Wt=1031,jt=1032,Zt=1033,Xt=33776,$t=33777,tA=33778,AA=33779,eA=35840,nA=35841,iA=35842,sA=35843,aA=36196,rA=37492,oA=37496,gA=37808,cA=37809,lA=37810,IA=37811,hA=37812,uA=37813,BA=37814,dA=37815,CA=37816,EA=37817,QA=37818,pA=37819,fA=37820,mA=37821,yA=36492,wA=36494,xA=36495,SA=36283,DA=36284,vA=36285,MA=36286,bA=2200,_A=2201,RA=2202,FA=2300,NA=2301,kA=2302,TA=2400,GA=2401,UA=2402,LA=2500,HA=2501,YA=0,PA=1,JA=2,qA=3200,zA=3201,OA=3202,KA=3203,VA=0,WA=1,jA="",ZA="srgb",XA="srgb-linear",$A="linear",te="srgb",Ae=0,ee=7680,ne=7681,ie=7682,se=7683,ae=34055,re=34056,oe=5386,ge=512,ce=513,le=514,Ie=515,he=516,ue=517,Be=518,de=519,Ce=512,Ee=513,Qe=514,pe=515,fe=516,me=517,ye=518,we=519,xe=35044,Se=35048,De=35040,ve=35045,Me=35049,be=35041,_e=35046,Re=35050,Fe=35042,Ne="100",ke="300 es",Te=2e3,Ge=2001,Ue={COMPUTE:"compute",RENDER:"render"},Le={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},He={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"};class Ye{addEventListener(t,A){void 0===this._listeners&&(this._listeners={});const e=this._listeners;void 0===e[t]&&(e[t]=[]),-1===e[t].indexOf(A)&&e[t].push(A)}hasEventListener(t,A){const e=this._listeners;return void 0!==e&&void 0!==e[t]&&-1!==e[t].indexOf(A)}removeEventListener(t,A){const e=this._listeners;if(void 0===e)return;const n=e[t];if(void 0!==n){const t=n.indexOf(A);-1!==t&&n.splice(t,1)}}dispatchEvent(t){const A=this._listeners;if(void 0===A)return;const e=A[t.type];if(void 0!==e){t.target=this;const A=e.slice(0);for(let e=0,n=A.length;e<n;e++)A[e].call(this,t);t.target=null}}}const Pe=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Je=1234567;const qe=Math.PI/180,ze=180/Math.PI;function Oe(){const t=4294967295*Math.random()|0,A=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(Pe[255&t]+Pe[t>>8&255]+Pe[t>>16&255]+Pe[t>>24&255]+"-"+Pe[255&A]+Pe[A>>8&255]+"-"+Pe[A>>16&15|64]+Pe[A>>24&255]+"-"+Pe[63&e|128]+Pe[e>>8&255]+"-"+Pe[e>>16&255]+Pe[e>>24&255]+Pe[255&n]+Pe[n>>8&255]+Pe[n>>16&255]+Pe[n>>24&255]).toLowerCase()}function Ke(t,A,e){return Math.max(A,Math.min(e,t))}function Ve(t,A){return(t%A+A)%A}function We(t,A,e){return(1-e)*t+e*A}function je(t,A){switch(A.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function Ze(t,A){switch(A.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const Xe={DEG2RAD:qe,RAD2DEG:ze,generateUUID:Oe,clamp:Ke,euclideanModulo:Ve,mapLinear:function(t,A,e,n,i){return n+(t-A)*(i-n)/(e-A)},inverseLerp:function(t,A,e){return t!==A?(e-t)/(A-t):0},lerp:We,damp:function(t,A,e,n){return We(t,A,1-Math.exp(-e*n))},pingpong:function(t,A=1){return A-Math.abs(Ve(t,2*A)-A)},smoothstep:function(t,A,e){return t<=A?0:t>=e?1:(t=(t-A)/(e-A))*t*(3-2*t)},smootherstep:function(t,A,e){return t<=A?0:t>=e?1:(t=(t-A)/(e-A))*t*t*(t*(6*t-15)+10)},randInt:function(t,A){return t+Math.floor(Math.random()*(A-t+1))},randFloat:function(t,A){return t+Math.random()*(A-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(Je=t);let A=Je+=1831565813;return A=Math.imul(A^A>>>15,1|A),A^=A+Math.imul(A^A>>>7,61|A),((A^A>>>14)>>>0)/4294967296},degToRad:function(t){return t*qe},radToDeg:function(t){return t*ze},isPowerOfTwo:function(t){return!(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,A,e,n,i){const s=Math.cos,a=Math.sin,r=s(e/2),o=a(e/2),g=s((A+n)/2),c=a((A+n)/2),l=s((A-n)/2),I=a((A-n)/2),h=s((n-A)/2),u=a((n-A)/2);switch(i){case"XYX":t.set(r*c,o*l,o*I,r*g);break;case"YZY":t.set(o*I,r*c,o*l,r*g);break;case"ZXZ":t.set(o*l,o*I,r*c,r*g);break;case"XZX":t.set(r*c,o*u,o*h,r*g);break;case"YXY":t.set(o*h,r*c,o*u,r*g);break;case"ZYZ":t.set(o*u,o*h,r*c,r*g);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}},normalize:Ze,denormalize:je};class $e{constructor(t=0,A=0){$e.prototype.isVector2=!0,this.x=t,this.y=A}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,A){return this.x=t,this.y=A,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,A){switch(t){case 0:this.x=A;break;case 1:this.y=A;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,A){return this.x=t.x+A.x,this.y=t.y+A.y,this}addScaledVector(t,A){return this.x+=t.x*A,this.y+=t.y*A,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,A){return this.x=t.x-A.x,this.y=t.y-A.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const A=this.x,e=this.y,n=t.elements;return this.x=n[0]*A+n[3]*e+n[6],this.y=n[1]*A+n[4]*e+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,A){return this.x=Ke(this.x,t.x,A.x),this.y=Ke(this.y,t.y,A.y),this}clampScalar(t,A){return this.x=Ke(this.x,t,A),this.y=Ke(this.y,t,A),this}clampLength(t,A){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Ke(e,t,A))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const A=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===A)return Math.PI/2;const e=this.dot(t)/A;return Math.acos(Ke(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const A=this.x-t.x,e=this.y-t.y;return A*A+e*e}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,A){return this.x+=(t.x-this.x)*A,this.y+=(t.y-this.y)*A,this}lerpVectors(t,A,e){return this.x=t.x+(A.x-t.x)*e,this.y=t.y+(A.y-t.y)*e,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,A=0){return this.x=t[A],this.y=t[A+1],this}toArray(t=[],A=0){return t[A]=this.x,t[A+1]=this.y,t}fromBufferAttribute(t,A){return this.x=t.getX(A),this.y=t.getY(A),this}rotateAround(t,A){const e=Math.cos(A),n=Math.sin(A),i=this.x-t.x,s=this.y-t.y;return this.x=i*e-s*n+t.x,this.y=i*n+s*e+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class tn{constructor(t=0,A=0,e=0,n=1){this.isQuaternion=!0,this._x=t,this._y=A,this._z=e,this._w=n}static slerpFlat(t,A,e,n,i,s,a){let r=e[n+0],o=e[n+1],g=e[n+2],c=e[n+3];const l=i[s+0],I=i[s+1],h=i[s+2],u=i[s+3];if(0===a)return t[A+0]=r,t[A+1]=o,t[A+2]=g,void(t[A+3]=c);if(1===a)return t[A+0]=l,t[A+1]=I,t[A+2]=h,void(t[A+3]=u);if(c!==u||r!==l||o!==I||g!==h){let t=1-a;const A=r*l+o*I+g*h+c*u,e=A>=0?1:-1,n=1-A*A;if(n>Number.EPSILON){const i=Math.sqrt(n),s=Math.atan2(i,A*e);t=Math.sin(t*s)/i,a=Math.sin(a*s)/i}const i=a*e;if(r=r*t+l*i,o=o*t+I*i,g=g*t+h*i,c=c*t+u*i,t===1-a){const t=1/Math.sqrt(r*r+o*o+g*g+c*c);r*=t,o*=t,g*=t,c*=t}}t[A]=r,t[A+1]=o,t[A+2]=g,t[A+3]=c}static multiplyQuaternionsFlat(t,A,e,n,i,s){const a=e[n],r=e[n+1],o=e[n+2],g=e[n+3],c=i[s],l=i[s+1],I=i[s+2],h=i[s+3];return t[A]=a*h+g*c+r*I-o*l,t[A+1]=r*h+g*l+o*c-a*I,t[A+2]=o*h+g*I+a*l-r*c,t[A+3]=g*h-a*c-r*l-o*I,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,A,e,n){return this._x=t,this._y=A,this._z=e,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,A=!0){const e=t._x,n=t._y,i=t._z,s=t._order,a=Math.cos,r=Math.sin,o=a(e/2),g=a(n/2),c=a(i/2),l=r(e/2),I=r(n/2),h=r(i/2);switch(s){case"XYZ":this._x=l*g*c+o*I*h,this._y=o*I*c-l*g*h,this._z=o*g*h+l*I*c,this._w=o*g*c-l*I*h;break;case"YXZ":this._x=l*g*c+o*I*h,this._y=o*I*c-l*g*h,this._z=o*g*h-l*I*c,this._w=o*g*c+l*I*h;break;case"ZXY":this._x=l*g*c-o*I*h,this._y=o*I*c+l*g*h,this._z=o*g*h+l*I*c,this._w=o*g*c-l*I*h;break;case"ZYX":this._x=l*g*c-o*I*h,this._y=o*I*c+l*g*h,this._z=o*g*h-l*I*c,this._w=o*g*c+l*I*h;break;case"YZX":this._x=l*g*c+o*I*h,this._y=o*I*c+l*g*h,this._z=o*g*h-l*I*c,this._w=o*g*c-l*I*h;break;case"XZY":this._x=l*g*c-o*I*h,this._y=o*I*c-l*g*h,this._z=o*g*h+l*I*c,this._w=o*g*c+l*I*h;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!0===A&&this._onChangeCallback(),this}setFromAxisAngle(t,A){const e=A/2,n=Math.sin(e);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(t){const A=t.elements,e=A[0],n=A[4],i=A[8],s=A[1],a=A[5],r=A[9],o=A[2],g=A[6],c=A[10],l=e+a+c;if(l>0){const t=.5/Math.sqrt(l+1);this._w=.25/t,this._x=(g-r)*t,this._y=(i-o)*t,this._z=(s-n)*t}else if(e>a&&e>c){const t=2*Math.sqrt(1+e-a-c);this._w=(g-r)/t,this._x=.25*t,this._y=(n+s)/t,this._z=(i+o)/t}else if(a>c){const t=2*Math.sqrt(1+a-e-c);this._w=(i-o)/t,this._x=(n+s)/t,this._y=.25*t,this._z=(r+g)/t}else{const t=2*Math.sqrt(1+c-e-a);this._w=(s-n)/t,this._x=(i+o)/t,this._y=(r+g)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,A){let e=t.dot(A)+1;return e<1e-8?(e=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=e):(this._x=0,this._y=-t.z,this._z=t.y,this._w=e)):(this._x=t.y*A.z-t.z*A.y,this._y=t.z*A.x-t.x*A.z,this._z=t.x*A.y-t.y*A.x,this._w=e),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ke(this.dot(t),-1,1)))}rotateTowards(t,A){const e=this.angleTo(t);if(0===e)return this;const n=Math.min(1,A/e);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,A){const e=t._x,n=t._y,i=t._z,s=t._w,a=A._x,r=A._y,o=A._z,g=A._w;return this._x=e*g+s*a+n*o-i*r,this._y=n*g+s*r+i*a-e*o,this._z=i*g+s*o+e*r-n*a,this._w=s*g-e*a-n*r-i*o,this._onChangeCallback(),this}slerp(t,A){if(0===A)return this;if(1===A)return this.copy(t);const e=this._x,n=this._y,i=this._z,s=this._w;let a=s*t._w+e*t._x+n*t._y+i*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=e,this._y=n,this._z=i,this;const r=1-a*a;if(r<=Number.EPSILON){const t=1-A;return this._w=t*s+A*this._w,this._x=t*e+A*this._x,this._y=t*n+A*this._y,this._z=t*i+A*this._z,this.normalize(),this}const o=Math.sqrt(r),g=Math.atan2(o,a),c=Math.sin((1-A)*g)/o,l=Math.sin(A*g)/o;return this._w=s*c+this._w*l,this._x=e*c+this._x*l,this._y=n*c+this._y*l,this._z=i*c+this._z*l,this._onChangeCallback(),this}slerpQuaternions(t,A,e){return this.copy(t).slerp(A,e)}random(){const t=2*Math.PI*Math.random(),A=2*Math.PI*Math.random(),e=Math.random(),n=Math.sqrt(1-e),i=Math.sqrt(e);return this.set(n*Math.sin(t),n*Math.cos(t),i*Math.sin(A),i*Math.cos(A))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,A=0){return this._x=t[A],this._y=t[A+1],this._z=t[A+2],this._w=t[A+3],this._onChangeCallback(),this}toArray(t=[],A=0){return t[A]=this._x,t[A+1]=this._y,t[A+2]=this._z,t[A+3]=this._w,t}fromBufferAttribute(t,A){return this._x=t.getX(A),this._y=t.getY(A),this._z=t.getZ(A),this._w=t.getW(A),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class An{constructor(t=0,A=0,e=0){An.prototype.isVector3=!0,this.x=t,this.y=A,this.z=e}set(t,A,e){return void 0===e&&(e=this.z),this.x=t,this.y=A,this.z=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,A){switch(t){case 0:this.x=A;break;case 1:this.y=A;break;case 2:this.z=A;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,A){return this.x=t.x+A.x,this.y=t.y+A.y,this.z=t.z+A.z,this}addScaledVector(t,A){return this.x+=t.x*A,this.y+=t.y*A,this.z+=t.z*A,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,A){return this.x=t.x-A.x,this.y=t.y-A.y,this.z=t.z-A.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,A){return this.x=t.x*A.x,this.y=t.y*A.y,this.z=t.z*A.z,this}applyEuler(t){return this.applyQuaternion(nn.setFromEuler(t))}applyAxisAngle(t,A){return this.applyQuaternion(nn.setFromAxisAngle(t,A))}applyMatrix3(t){const A=this.x,e=this.y,n=this.z,i=t.elements;return this.x=i[0]*A+i[3]*e+i[6]*n,this.y=i[1]*A+i[4]*e+i[7]*n,this.z=i[2]*A+i[5]*e+i[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const A=this.x,e=this.y,n=this.z,i=t.elements,s=1/(i[3]*A+i[7]*e+i[11]*n+i[15]);return this.x=(i[0]*A+i[4]*e+i[8]*n+i[12])*s,this.y=(i[1]*A+i[5]*e+i[9]*n+i[13])*s,this.z=(i[2]*A+i[6]*e+i[10]*n+i[14])*s,this}applyQuaternion(t){const A=this.x,e=this.y,n=this.z,i=t.x,s=t.y,a=t.z,r=t.w,o=2*(s*n-a*e),g=2*(a*A-i*n),c=2*(i*e-s*A);return this.x=A+r*o+s*c-a*g,this.y=e+r*g+a*o-i*c,this.z=n+r*c+i*g-s*o,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const A=this.x,e=this.y,n=this.z,i=t.elements;return this.x=i[0]*A+i[4]*e+i[8]*n,this.y=i[1]*A+i[5]*e+i[9]*n,this.z=i[2]*A+i[6]*e+i[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,A){return this.x=Ke(this.x,t.x,A.x),this.y=Ke(this.y,t.y,A.y),this.z=Ke(this.z,t.z,A.z),this}clampScalar(t,A){return this.x=Ke(this.x,t,A),this.y=Ke(this.y,t,A),this.z=Ke(this.z,t,A),this}clampLength(t,A){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Ke(e,t,A))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,A){return this.x+=(t.x-this.x)*A,this.y+=(t.y-this.y)*A,this.z+=(t.z-this.z)*A,this}lerpVectors(t,A,e){return this.x=t.x+(A.x-t.x)*e,this.y=t.y+(A.y-t.y)*e,this.z=t.z+(A.z-t.z)*e,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,A){const e=t.x,n=t.y,i=t.z,s=A.x,a=A.y,r=A.z;return this.x=n*r-i*a,this.y=i*s-e*r,this.z=e*a-n*s,this}projectOnVector(t){const A=t.lengthSq();if(0===A)return this.set(0,0,0);const e=t.dot(this)/A;return this.copy(t).multiplyScalar(e)}projectOnPlane(t){return en.copy(this).projectOnVector(t),this.sub(en)}reflect(t){return this.sub(en.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const A=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===A)return Math.PI/2;const e=this.dot(t)/A;return Math.acos(Ke(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const A=this.x-t.x,e=this.y-t.y,n=this.z-t.z;return A*A+e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,A,e){const n=Math.sin(A)*t;return this.x=n*Math.sin(e),this.y=Math.cos(A)*t,this.z=n*Math.cos(e),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,A,e){return this.x=t*Math.sin(A),this.y=e,this.z=t*Math.cos(A),this}setFromMatrixPosition(t){const A=t.elements;return this.x=A[12],this.y=A[13],this.z=A[14],this}setFromMatrixScale(t){const A=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=A,this.y=e,this.z=n,this}setFromMatrixColumn(t,A){return this.fromArray(t.elements,4*A)}setFromMatrix3Column(t,A){return this.fromArray(t.elements,3*A)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,A=0){return this.x=t[A],this.y=t[A+1],this.z=t[A+2],this}toArray(t=[],A=0){return t[A]=this.x,t[A+1]=this.y,t[A+2]=this.z,t}fromBufferAttribute(t,A){return this.x=t.getX(A),this.y=t.getY(A),this.z=t.getZ(A),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,A=2*Math.random()-1,e=Math.sqrt(1-A*A);return this.x=e*Math.cos(t),this.y=A,this.z=e*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const en=new An,nn=new tn;class sn{constructor(t,A,e,n,i,s,a,r,o){sn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,A,e,n,i,s,a,r,o)}set(t,A,e,n,i,s,a,r,o){const g=this.elements;return g[0]=t,g[1]=n,g[2]=a,g[3]=A,g[4]=i,g[5]=r,g[6]=e,g[7]=s,g[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const A=this.elements,e=t.elements;return A[0]=e[0],A[1]=e[1],A[2]=e[2],A[3]=e[3],A[4]=e[4],A[5]=e[5],A[6]=e[6],A[7]=e[7],A[8]=e[8],this}extractBasis(t,A,e){return t.setFromMatrix3Column(this,0),A.setFromMatrix3Column(this,1),e.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const A=t.elements;return this.set(A[0],A[4],A[8],A[1],A[5],A[9],A[2],A[6],A[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,A){const e=t.elements,n=A.elements,i=this.elements,s=e[0],a=e[3],r=e[6],o=e[1],g=e[4],c=e[7],l=e[2],I=e[5],h=e[8],u=n[0],B=n[3],d=n[6],C=n[1],E=n[4],Q=n[7],p=n[2],f=n[5],m=n[8];return i[0]=s*u+a*C+r*p,i[3]=s*B+a*E+r*f,i[6]=s*d+a*Q+r*m,i[1]=o*u+g*C+c*p,i[4]=o*B+g*E+c*f,i[7]=o*d+g*Q+c*m,i[2]=l*u+I*C+h*p,i[5]=l*B+I*E+h*f,i[8]=l*d+I*Q+h*m,this}multiplyScalar(t){const A=this.elements;return A[0]*=t,A[3]*=t,A[6]*=t,A[1]*=t,A[4]*=t,A[7]*=t,A[2]*=t,A[5]*=t,A[8]*=t,this}determinant(){const t=this.elements,A=t[0],e=t[1],n=t[2],i=t[3],s=t[4],a=t[5],r=t[6],o=t[7],g=t[8];return A*s*g-A*a*o-e*i*g+e*a*r+n*i*o-n*s*r}invert(){const t=this.elements,A=t[0],e=t[1],n=t[2],i=t[3],s=t[4],a=t[5],r=t[6],o=t[7],g=t[8],c=g*s-a*o,l=a*r-g*i,I=o*i-s*r,h=A*c+e*l+n*I;if(0===h)return this.set(0,0,0,0,0,0,0,0,0);const u=1/h;return t[0]=c*u,t[1]=(n*o-g*e)*u,t[2]=(a*e-n*s)*u,t[3]=l*u,t[4]=(g*A-n*r)*u,t[5]=(n*i-a*A)*u,t[6]=I*u,t[7]=(e*r-o*A)*u,t[8]=(s*A-e*i)*u,this}transpose(){let t;const A=this.elements;return t=A[1],A[1]=A[3],A[3]=t,t=A[2],A[2]=A[6],A[6]=t,t=A[5],A[5]=A[7],A[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const A=this.elements;return t[0]=A[0],t[1]=A[3],t[2]=A[6],t[3]=A[1],t[4]=A[4],t[5]=A[7],t[6]=A[2],t[7]=A[5],t[8]=A[8],this}setUvTransform(t,A,e,n,i,s,a){const r=Math.cos(i),o=Math.sin(i);return this.set(e*r,e*o,-e*(r*s+o*a)+s+t,-n*o,n*r,-n*(-o*s+r*a)+a+A,0,0,1),this}scale(t,A){return this.premultiply(an.makeScale(t,A)),this}rotate(t){return this.premultiply(an.makeRotation(-t)),this}translate(t,A){return this.premultiply(an.makeTranslation(t,A)),this}makeTranslation(t,A){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,A,0,0,1),this}makeRotation(t){const A=Math.cos(t),e=Math.sin(t);return this.set(A,-e,0,e,A,0,0,0,1),this}makeScale(t,A){return this.set(t,0,0,0,A,0,0,0,1),this}equals(t){const A=this.elements,e=t.elements;for(let t=0;t<9;t++)if(A[t]!==e[t])return!1;return!0}fromArray(t,A=0){for(let e=0;e<9;e++)this.elements[e]=t[e+A];return this}toArray(t=[],A=0){const e=this.elements;return t[A]=e[0],t[A+1]=e[1],t[A+2]=e[2],t[A+3]=e[3],t[A+4]=e[4],t[A+5]=e[5],t[A+6]=e[6],t[A+7]=e[7],t[A+8]=e[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const an=new sn;function rn(t){for(let A=t.length-1;A>=0;--A)if(t[A]>=65535)return!0;return!1}const on={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function gn(t,A){return new on[t](A)}function cn(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function ln(){const t=cn("canvas");return t.style.display="block",t}const In={};function hn(t){t in In||(In[t]=!0,console.warn(t))}function un(t,A,e){return new Promise(function(n,i){setTimeout(function s(){switch(t.clientWaitSync(A,t.SYNC_FLUSH_COMMANDS_BIT,0)){case t.WAIT_FAILED:i();break;case t.TIMEOUT_EXPIRED:setTimeout(s,e);break;default:n()}},e)})}function Bn(t){const A=t.elements;A[2]=.5*A[2]+.5*A[3],A[6]=.5*A[6]+.5*A[7],A[10]=.5*A[10]+.5*A[11],A[14]=.5*A[14]+.5*A[15]}function dn(t){const A=t.elements;-1===A[11]?(A[10]=-A[10]-1,A[14]=-A[14]):(A[10]=-A[10],A[14]=1-A[14])}const Cn=(new sn).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),En=(new sn).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function Qn(){const t={enabled:!0,workingColorSpace:XA,spaces:{},convert:function(t,A,e){return!1!==this.enabled&&A!==e&&A&&e?(this.spaces[A].transfer===te&&(t.r=fn(t.r),t.g=fn(t.g),t.b=fn(t.b)),this.spaces[A].primaries!==this.spaces[e].primaries&&(t.applyMatrix3(this.spaces[A].toXYZ),t.applyMatrix3(this.spaces[e].fromXYZ)),this.spaces[e].transfer===te&&(t.r=mn(t.r),t.g=mn(t.g),t.b=mn(t.b)),t):t},workingToColorSpace:function(t,A){return this.convert(t,this.workingColorSpace,A)},colorSpaceToWorking:function(t,A){return this.convert(t,A,this.workingColorSpace)},getPrimaries:function(t){return this.spaces[t].primaries},getTransfer:function(t){return t===jA?$A:this.spaces[t].transfer},getLuminanceCoefficients:function(t,A=this.workingColorSpace){return t.fromArray(this.spaces[A].luminanceCoefficients)},define:function(t){Object.assign(this.spaces,t)},_getMatrix:function(t,A,e){return t.copy(this.spaces[A].toXYZ).multiply(this.spaces[e].fromXYZ)},_getDrawingBufferColorSpace:function(t){return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(t=this.workingColorSpace){return this.spaces[t].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(A,e){return hn("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),t.workingToColorSpace(A,e)},toWorkingColorSpace:function(A,e){return hn("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),t.colorSpaceToWorking(A,e)}},A=[.64,.33,.3,.6,.15,.06],e=[.2126,.7152,.0722],n=[.3127,.329];return t.define({[XA]:{primaries:A,whitePoint:n,transfer:$A,toXYZ:Cn,fromXYZ:En,luminanceCoefficients:e,workingColorSpaceConfig:{unpackColorSpace:ZA},outputColorSpaceConfig:{drawingBufferColorSpace:ZA}},[ZA]:{primaries:A,whitePoint:n,transfer:te,toXYZ:Cn,fromXYZ:En,luminanceCoefficients:e,outputColorSpaceConfig:{drawingBufferColorSpace:ZA}}}),t}const pn=Qn();function fn(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function mn(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}let yn;class wn{static getDataURL(t,A="image/png"){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===yn&&(yn=cn("canvas")),yn.width=t.width,yn.height=t.height;const A=yn.getContext("2d");t instanceof ImageData?A.putImageData(t,0,0):A.drawImage(t,0,0,t.width,t.height),e=yn}return e.toDataURL(A)}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const A=cn("canvas");A.width=t.width,A.height=t.height;const e=A.getContext("2d");e.drawImage(t,0,0,t.width,t.height);const n=e.getImageData(0,0,t.width,t.height),i=n.data;for(let t=0;t<i.length;t++)i[t]=255*fn(i[t]/255);return e.putImageData(n,0,0),A}if(t.data){const A=t.data.slice(0);for(let t=0;t<A.length;t++)A instanceof Uint8Array||A instanceof Uint8ClampedArray?A[t]=Math.floor(255*fn(A[t]/255)):A[t]=fn(A[t]);return{data:A,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let xn=0;class Sn{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:xn++}),this.uuid=Oe(),this.data=t,this.dataReady=!0,this.version=0}getSize(t){const A=this.data;return A instanceof HTMLVideoElement?t.set(A.videoWidth,A.videoHeight):null!==A?t.set(A.width,A.height,A.depth||0):t.set(0,0,0),t}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const A=void 0===t||"string"==typeof t;if(!A&&void 0!==t.images[this.uuid])return t.images[this.uuid];const e={uuid:this.uuid,url:""},n=this.data;if(null!==n){let t;if(Array.isArray(n)){t=[];for(let A=0,e=n.length;A<e;A++)n[A].isDataTexture?t.push(Dn(n[A].image)):t.push(Dn(n[A]))}else t=Dn(n);e.url=t}return A||(t.images[this.uuid]=e),e}}function Dn(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?wn.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let vn=0;const Mn=new An;class bn extends Ye{constructor(t=bn.DEFAULT_IMAGE,A=bn.DEFAULT_MAPPING,e=Ct,n=Ct,i=wt,s=Dt,a=Jt,r=Mt,o=bn.DEFAULT_ANISOTROPY,g=jA){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:vn++}),this.uuid=Oe(),this.name="",this.source=new Sn(t),this.mipmaps=[],this.mapping=A,this.channel=0,this.wrapS=e,this.wrapT=n,this.magFilter=i,this.minFilter=s,this.anisotropy=o,this.format=a,this.internalFormat=null,this.type=r,this.offset=new $e(0,0),this.repeat=new $e(1,1),this.center=new $e(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new sn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=g,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(t&&t.depth&&t.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(Mn).x}get height(){return this.source.getSize(Mn).y}get depth(){return this.source.getSize(Mn).z}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(t,A){this.updateRanges.push({start:t,count:A})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.isArrayTexture=t.isArrayTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}setValues(t){for(const A in t){const e=t[A];if(void 0===e){console.warn(`THREE.Texture.setValues(): parameter '${A}' has value of undefined.`);continue}const n=this[A];void 0!==n?n&&e&&n.isVector2&&e.isVector2||n&&e&&n.isVector3&&e.isVector3||n&&e&&n.isMatrix3&&e.isMatrix3?n.copy(e):this[A]=e:console.warn(`THREE.Texture.setValues(): property '${A}' does not exist.`)}}toJSON(t){const A=void 0===t||"string"==typeof t;if(!A&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const e={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(e.userData=this.userData),A||(t.textures[this.uuid]=e),e}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==ct)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case dt:t.x=t.x-Math.floor(t.x);break;case Ct:t.x=t.x<0?0:1;break;case Et:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case dt:t.y=t.y-Math.floor(t.y);break;case Ct:t.y=t.y<0?0:1;break;case Et:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}}bn.DEFAULT_IMAGE=null,bn.DEFAULT_MAPPING=ct,bn.DEFAULT_ANISOTROPY=1;class _n{constructor(t=0,A=0,e=0,n=1){_n.prototype.isVector4=!0,this.x=t,this.y=A,this.z=e,this.w=n}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,A,e,n){return this.x=t,this.y=A,this.z=e,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,A){switch(t){case 0:this.x=A;break;case 1:this.y=A;break;case 2:this.z=A;break;case 3:this.w=A;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,A){return this.x=t.x+A.x,this.y=t.y+A.y,this.z=t.z+A.z,this.w=t.w+A.w,this}addScaledVector(t,A){return this.x+=t.x*A,this.y+=t.y*A,this.z+=t.z*A,this.w+=t.w*A,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,A){return this.x=t.x-A.x,this.y=t.y-A.y,this.z=t.z-A.z,this.w=t.w-A.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const A=this.x,e=this.y,n=this.z,i=this.w,s=t.elements;return this.x=s[0]*A+s[4]*e+s[8]*n+s[12]*i,this.y=s[1]*A+s[5]*e+s[9]*n+s[13]*i,this.z=s[2]*A+s[6]*e+s[10]*n+s[14]*i,this.w=s[3]*A+s[7]*e+s[11]*n+s[15]*i,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const A=Math.sqrt(1-t.w*t.w);return A<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/A,this.y=t.y/A,this.z=t.z/A),this}setAxisAngleFromRotationMatrix(t){let A,e,n,i;const s=.01,a=.1,r=t.elements,o=r[0],g=r[4],c=r[8],l=r[1],I=r[5],h=r[9],u=r[2],B=r[6],d=r[10];if(Math.abs(g-l)<s&&Math.abs(c-u)<s&&Math.abs(h-B)<s){if(Math.abs(g+l)<a&&Math.abs(c+u)<a&&Math.abs(h+B)<a&&Math.abs(o+I+d-3)<a)return this.set(1,0,0,0),this;A=Math.PI;const t=(o+1)/2,r=(I+1)/2,C=(d+1)/2,E=(g+l)/4,Q=(c+u)/4,p=(h+B)/4;return t>r&&t>C?t<s?(e=0,n=.707106781,i=.707106781):(e=Math.sqrt(t),n=E/e,i=Q/e):r>C?r<s?(e=.707106781,n=0,i=.707106781):(n=Math.sqrt(r),e=E/n,i=p/n):C<s?(e=.707106781,n=.707106781,i=0):(i=Math.sqrt(C),e=Q/i,n=p/i),this.set(e,n,i,A),this}let C=Math.sqrt((B-h)*(B-h)+(c-u)*(c-u)+(l-g)*(l-g));return Math.abs(C)<.001&&(C=1),this.x=(B-h)/C,this.y=(c-u)/C,this.z=(l-g)/C,this.w=Math.acos((o+I+d-1)/2),this}setFromMatrixPosition(t){const A=t.elements;return this.x=A[12],this.y=A[13],this.z=A[14],this.w=A[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,A){return this.x=Ke(this.x,t.x,A.x),this.y=Ke(this.y,t.y,A.y),this.z=Ke(this.z,t.z,A.z),this.w=Ke(this.w,t.w,A.w),this}clampScalar(t,A){return this.x=Ke(this.x,t,A),this.y=Ke(this.y,t,A),this.z=Ke(this.z,t,A),this.w=Ke(this.w,t,A),this}clampLength(t,A){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Ke(e,t,A))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,A){return this.x+=(t.x-this.x)*A,this.y+=(t.y-this.y)*A,this.z+=(t.z-this.z)*A,this.w+=(t.w-this.w)*A,this}lerpVectors(t,A,e){return this.x=t.x+(A.x-t.x)*e,this.y=t.y+(A.y-t.y)*e,this.z=t.z+(A.z-t.z)*e,this.w=t.w+(A.w-t.w)*e,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,A=0){return this.x=t[A],this.y=t[A+1],this.z=t[A+2],this.w=t[A+3],this}toArray(t=[],A=0){return t[A]=this.x,t[A+1]=this.y,t[A+2]=this.z,t[A+3]=this.w,t}fromBufferAttribute(t,A){return this.x=t.getX(A),this.y=t.getY(A),this.z=t.getZ(A),this.w=t.getW(A),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Rn extends Ye{constructor(t=1,A=1,e={}){super(),e=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:wt,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},e),this.isRenderTarget=!0,this.width=t,this.height=A,this.depth=e.depth,this.scissor=new _n(0,0,t,A),this.scissorTest=!1,this.viewport=new _n(0,0,t,A);const n={width:t,height:A,depth:e.depth},i=new bn(n);this.textures=[];const s=e.count;for(let t=0;t<s;t++)this.textures[t]=i.clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;this._setTextureOptions(e),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=e.depthTexture,this.samples=e.samples,this.multiview=e.multiview}_setTextureOptions(t={}){const A={minFilter:wt,generateMipmaps:!1,flipY:!1,internalFormat:null};void 0!==t.mapping&&(A.mapping=t.mapping),void 0!==t.wrapS&&(A.wrapS=t.wrapS),void 0!==t.wrapT&&(A.wrapT=t.wrapT),void 0!==t.wrapR&&(A.wrapR=t.wrapR),void 0!==t.magFilter&&(A.magFilter=t.magFilter),void 0!==t.minFilter&&(A.minFilter=t.minFilter),void 0!==t.format&&(A.format=t.format),void 0!==t.type&&(A.type=t.type),void 0!==t.anisotropy&&(A.anisotropy=t.anisotropy),void 0!==t.colorSpace&&(A.colorSpace=t.colorSpace),void 0!==t.flipY&&(A.flipY=t.flipY),void 0!==t.generateMipmaps&&(A.generateMipmaps=t.generateMipmaps),void 0!==t.internalFormat&&(A.internalFormat=t.internalFormat);for(let t=0;t<this.textures.length;t++)this.textures[t].setValues(A)}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}set depthTexture(t){null!==this._depthTexture&&(this._depthTexture.renderTarget=null),null!==t&&(t.renderTarget=this),this._depthTexture=t}get depthTexture(){return this._depthTexture}setSize(t,A,e=1){if(this.width!==t||this.height!==A||this.depth!==e){this.width=t,this.height=A,this.depth=e;for(let n=0,i=this.textures.length;n<i;n++)this.textures[n].image.width=t,this.textures[n].image.height=A,this.textures[n].image.depth=e,this.textures[n].isArrayTexture=this.textures[n].image.depth>1;this.dispose()}this.viewport.set(0,0,t,A),this.scissor.set(0,0,t,A)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let A=0,e=t.textures.length;A<e;A++){this.textures[A]=t.textures[A].clone(),this.textures[A].isRenderTargetTexture=!0,this.textures[A].renderTarget=this;const e=Object.assign({},t.textures[A].image);this.textures[A].source=new Sn(e)}return this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Fn extends Rn{constructor(t=1,A=1,e={}){super(t,A,e),this.isWebGLRenderTarget=!0}}class Nn extends bn{constructor(t=null,A=1,e=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:A,height:e,depth:n},this.magFilter=Qt,this.minFilter=Qt,this.wrapR=Ct,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class kn extends Fn{constructor(t=1,A=1,e=1,n={}){super(t,A,n),this.isWebGLArrayRenderTarget=!0,this.depth=e,this.texture=new Nn(null,t,A,e),this._setTextureOptions(n),this.texture.isRenderTargetTexture=!0}}class Tn extends bn{constructor(t=null,A=1,e=1,n=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:A,height:e,depth:n},this.magFilter=Qt,this.minFilter=Qt,this.wrapR=Ct,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Gn extends Fn{constructor(t=1,A=1,e=1,n={}){super(t,A,n),this.isWebGL3DRenderTarget=!0,this.depth=e,this.texture=new Tn(null,t,A,e),this._setTextureOptions(n),this.texture.isRenderTargetTexture=!0}}class Un{constructor(t=new An(1/0,1/0,1/0),A=new An(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=A}set(t,A){return this.min.copy(t),this.max.copy(A),this}setFromArray(t){this.makeEmpty();for(let A=0,e=t.length;A<e;A+=3)this.expandByPoint(Hn.fromArray(t,A));return this}setFromBufferAttribute(t){this.makeEmpty();for(let A=0,e=t.count;A<e;A++)this.expandByPoint(Hn.fromBufferAttribute(t,A));return this}setFromPoints(t){this.makeEmpty();for(let A=0,e=t.length;A<e;A++)this.expandByPoint(t[A]);return this}setFromCenterAndSize(t,A){const e=Hn.copy(A).multiplyScalar(.5);return this.min.copy(t).sub(e),this.max.copy(t).add(e),this}setFromObject(t,A=!1){return this.makeEmpty(),this.expandByObject(t,A)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,A=!1){t.updateWorldMatrix(!1,!1);const e=t.geometry;if(void 0!==e){const n=e.getAttribute("position");if(!0===A&&void 0!==n&&!0!==t.isInstancedMesh)for(let A=0,e=n.count;A<e;A++)!0===t.isMesh?t.getVertexPosition(A,Hn):Hn.fromBufferAttribute(n,A),Hn.applyMatrix4(t.matrixWorld),this.expandByPoint(Hn);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),Yn.copy(t.boundingBox)):(null===e.boundingBox&&e.computeBoundingBox(),Yn.copy(e.boundingBox)),Yn.applyMatrix4(t.matrixWorld),this.union(Yn)}const n=t.children;for(let t=0,e=n.length;t<e;t++)this.expandByObject(n[t],A);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,A){return A.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,Hn),Hn.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let A,e;return t.normal.x>0?(A=t.normal.x*this.min.x,e=t.normal.x*this.max.x):(A=t.normal.x*this.max.x,e=t.normal.x*this.min.x),t.normal.y>0?(A+=t.normal.y*this.min.y,e+=t.normal.y*this.max.y):(A+=t.normal.y*this.max.y,e+=t.normal.y*this.min.y),t.normal.z>0?(A+=t.normal.z*this.min.z,e+=t.normal.z*this.max.z):(A+=t.normal.z*this.max.z,e+=t.normal.z*this.min.z),A<=-t.constant&&e>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Vn),Wn.subVectors(this.max,Vn),Pn.subVectors(t.a,Vn),Jn.subVectors(t.b,Vn),qn.subVectors(t.c,Vn),zn.subVectors(Jn,Pn),On.subVectors(qn,Jn),Kn.subVectors(Pn,qn);let A=[0,-zn.z,zn.y,0,-On.z,On.y,0,-Kn.z,Kn.y,zn.z,0,-zn.x,On.z,0,-On.x,Kn.z,0,-Kn.x,-zn.y,zn.x,0,-On.y,On.x,0,-Kn.y,Kn.x,0];return!!Xn(A,Pn,Jn,qn,Wn)&&(A=[1,0,0,0,1,0,0,0,1],!!Xn(A,Pn,Jn,qn,Wn)&&(jn.crossVectors(zn,On),A=[jn.x,jn.y,jn.z],Xn(A,Pn,Jn,qn,Wn)))}clampPoint(t,A){return A.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Hn).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(Hn).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(Ln[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Ln[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Ln[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Ln[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Ln[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Ln[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Ln[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Ln[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Ln)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const Ln=[new An,new An,new An,new An,new An,new An,new An,new An],Hn=new An,Yn=new Un,Pn=new An,Jn=new An,qn=new An,zn=new An,On=new An,Kn=new An,Vn=new An,Wn=new An,jn=new An,Zn=new An;function Xn(t,A,e,n,i){for(let s=0,a=t.length-3;s<=a;s+=3){Zn.fromArray(t,s);const a=i.x*Math.abs(Zn.x)+i.y*Math.abs(Zn.y)+i.z*Math.abs(Zn.z),r=A.dot(Zn),o=e.dot(Zn),g=n.dot(Zn);if(Math.max(-Math.max(r,o,g),Math.min(r,o,g))>a)return!1}return!0}const $n=new Un,ti=new An,Ai=new An;class ei{constructor(t=new An,A=-1){this.isSphere=!0,this.center=t,this.radius=A}set(t,A){return this.center.copy(t),this.radius=A,this}setFromPoints(t,A){const e=this.center;void 0!==A?e.copy(A):$n.setFromPoints(t).getCenter(e);let n=0;for(let A=0,i=t.length;A<i;A++)n=Math.max(n,e.distanceToSquared(t[A]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const A=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=A*A}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,A){const e=this.center.distanceToSquared(t);return A.copy(t),e>this.radius*this.radius&&(A.sub(this.center).normalize(),A.multiplyScalar(this.radius).add(this.center)),A}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;ti.subVectors(t,this.center);const A=ti.lengthSq();if(A>this.radius*this.radius){const t=Math.sqrt(A),e=.5*(t-this.radius);this.center.addScaledVector(ti,e/t),this.radius+=e}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(Ai.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(ti.copy(t.center).add(Ai)),this.expandByPoint(ti.copy(t.center).sub(Ai))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}const ni=new An,ii=new An,si=new An,ai=new An,ri=new An,oi=new An,gi=new An;class ci{constructor(t=new An,A=new An(0,0,-1)){this.origin=t,this.direction=A}set(t,A){return this.origin.copy(t),this.direction.copy(A),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,A){return A.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,ni)),this}closestPointToPoint(t,A){A.subVectors(t,this.origin);const e=A.dot(this.direction);return e<0?A.copy(this.origin):A.copy(this.origin).addScaledVector(this.direction,e)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const A=ni.subVectors(t,this.origin).dot(this.direction);return A<0?this.origin.distanceToSquared(t):(ni.copy(this.origin).addScaledVector(this.direction,A),ni.distanceToSquared(t))}distanceSqToSegment(t,A,e,n){ii.copy(t).add(A).multiplyScalar(.5),si.copy(A).sub(t).normalize(),ai.copy(this.origin).sub(ii);const i=.5*t.distanceTo(A),s=-this.direction.dot(si),a=ai.dot(this.direction),r=-ai.dot(si),o=ai.lengthSq(),g=Math.abs(1-s*s);let c,l,I,h;if(g>0)if(c=s*r-a,l=s*a-r,h=i*g,c>=0)if(l>=-h)if(l<=h){const t=1/g;c*=t,l*=t,I=c*(c+s*l+2*a)+l*(s*c+l+2*r)+o}else l=i,c=Math.max(0,-(s*l+a)),I=-c*c+l*(l+2*r)+o;else l=-i,c=Math.max(0,-(s*l+a)),I=-c*c+l*(l+2*r)+o;else l<=-h?(c=Math.max(0,-(-s*i+a)),l=c>0?-i:Math.min(Math.max(-i,-r),i),I=-c*c+l*(l+2*r)+o):l<=h?(c=0,l=Math.min(Math.max(-i,-r),i),I=l*(l+2*r)+o):(c=Math.max(0,-(s*i+a)),l=c>0?i:Math.min(Math.max(-i,-r),i),I=-c*c+l*(l+2*r)+o);else l=s>0?-i:i,c=Math.max(0,-(s*l+a)),I=-c*c+l*(l+2*r)+o;return e&&e.copy(this.origin).addScaledVector(this.direction,c),n&&n.copy(ii).addScaledVector(si,l),I}intersectSphere(t,A){ni.subVectors(t.center,this.origin);const e=ni.dot(this.direction),n=ni.dot(ni)-e*e,i=t.radius*t.radius;if(n>i)return null;const s=Math.sqrt(i-n),a=e-s,r=e+s;return r<0?null:a<0?this.at(r,A):this.at(a,A)}intersectsSphere(t){return!(t.radius<0)&&this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const A=t.normal.dot(this.direction);if(0===A)return 0===t.distanceToPoint(this.origin)?0:null;const e=-(this.origin.dot(t.normal)+t.constant)/A;return e>=0?e:null}intersectPlane(t,A){const e=this.distanceToPlane(t);return null===e?null:this.at(e,A)}intersectsPlane(t){const A=t.distanceToPoint(this.origin);return 0===A||t.normal.dot(this.direction)*A<0}intersectBox(t,A){let e,n,i,s,a,r;const o=1/this.direction.x,g=1/this.direction.y,c=1/this.direction.z,l=this.origin;return o>=0?(e=(t.min.x-l.x)*o,n=(t.max.x-l.x)*o):(e=(t.max.x-l.x)*o,n=(t.min.x-l.x)*o),g>=0?(i=(t.min.y-l.y)*g,s=(t.max.y-l.y)*g):(i=(t.max.y-l.y)*g,s=(t.min.y-l.y)*g),e>s||i>n?null:((i>e||isNaN(e))&&(e=i),(s<n||isNaN(n))&&(n=s),c>=0?(a=(t.min.z-l.z)*c,r=(t.max.z-l.z)*c):(a=(t.max.z-l.z)*c,r=(t.min.z-l.z)*c),e>r||a>n?null:((a>e||e!=e)&&(e=a),(r<n||n!=n)&&(n=r),n<0?null:this.at(e>=0?e:n,A)))}intersectsBox(t){return null!==this.intersectBox(t,ni)}intersectTriangle(t,A,e,n,i){ri.subVectors(A,t),oi.subVectors(e,t),gi.crossVectors(ri,oi);let s,a=this.direction.dot(gi);if(a>0){if(n)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}ai.subVectors(this.origin,t);const r=s*this.direction.dot(oi.crossVectors(ai,oi));if(r<0)return null;const o=s*this.direction.dot(ri.cross(ai));if(o<0)return null;if(r+o>a)return null;const g=-s*ai.dot(gi);return g<0?null:this.at(g/a,i)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class li{constructor(t,A,e,n,i,s,a,r,o,g,c,l,I,h,u,B){li.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,A,e,n,i,s,a,r,o,g,c,l,I,h,u,B)}set(t,A,e,n,i,s,a,r,o,g,c,l,I,h,u,B){const d=this.elements;return d[0]=t,d[4]=A,d[8]=e,d[12]=n,d[1]=i,d[5]=s,d[9]=a,d[13]=r,d[2]=o,d[6]=g,d[10]=c,d[14]=l,d[3]=I,d[7]=h,d[11]=u,d[15]=B,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new li).fromArray(this.elements)}copy(t){const A=this.elements,e=t.elements;return A[0]=e[0],A[1]=e[1],A[2]=e[2],A[3]=e[3],A[4]=e[4],A[5]=e[5],A[6]=e[6],A[7]=e[7],A[8]=e[8],A[9]=e[9],A[10]=e[10],A[11]=e[11],A[12]=e[12],A[13]=e[13],A[14]=e[14],A[15]=e[15],this}copyPosition(t){const A=this.elements,e=t.elements;return A[12]=e[12],A[13]=e[13],A[14]=e[14],this}setFromMatrix3(t){const A=t.elements;return this.set(A[0],A[3],A[6],0,A[1],A[4],A[7],0,A[2],A[5],A[8],0,0,0,0,1),this}extractBasis(t,A,e){return t.setFromMatrixColumn(this,0),A.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(t,A,e){return this.set(t.x,A.x,e.x,0,t.y,A.y,e.y,0,t.z,A.z,e.z,0,0,0,0,1),this}extractRotation(t){const A=this.elements,e=t.elements,n=1/Ii.setFromMatrixColumn(t,0).length(),i=1/Ii.setFromMatrixColumn(t,1).length(),s=1/Ii.setFromMatrixColumn(t,2).length();return A[0]=e[0]*n,A[1]=e[1]*n,A[2]=e[2]*n,A[3]=0,A[4]=e[4]*i,A[5]=e[5]*i,A[6]=e[6]*i,A[7]=0,A[8]=e[8]*s,A[9]=e[9]*s,A[10]=e[10]*s,A[11]=0,A[12]=0,A[13]=0,A[14]=0,A[15]=1,this}makeRotationFromEuler(t){const A=this.elements,e=t.x,n=t.y,i=t.z,s=Math.cos(e),a=Math.sin(e),r=Math.cos(n),o=Math.sin(n),g=Math.cos(i),c=Math.sin(i);if("XYZ"===t.order){const t=s*g,e=s*c,n=a*g,i=a*c;A[0]=r*g,A[4]=-r*c,A[8]=o,A[1]=e+n*o,A[5]=t-i*o,A[9]=-a*r,A[2]=i-t*o,A[6]=n+e*o,A[10]=s*r}else if("YXZ"===t.order){const t=r*g,e=r*c,n=o*g,i=o*c;A[0]=t+i*a,A[4]=n*a-e,A[8]=s*o,A[1]=s*c,A[5]=s*g,A[9]=-a,A[2]=e*a-n,A[6]=i+t*a,A[10]=s*r}else if("ZXY"===t.order){const t=r*g,e=r*c,n=o*g,i=o*c;A[0]=t-i*a,A[4]=-s*c,A[8]=n+e*a,A[1]=e+n*a,A[5]=s*g,A[9]=i-t*a,A[2]=-s*o,A[6]=a,A[10]=s*r}else if("ZYX"===t.order){const t=s*g,e=s*c,n=a*g,i=a*c;A[0]=r*g,A[4]=n*o-e,A[8]=t*o+i,A[1]=r*c,A[5]=i*o+t,A[9]=e*o-n,A[2]=-o,A[6]=a*r,A[10]=s*r}else if("YZX"===t.order){const t=s*r,e=s*o,n=a*r,i=a*o;A[0]=r*g,A[4]=i-t*c,A[8]=n*c+e,A[1]=c,A[5]=s*g,A[9]=-a*g,A[2]=-o*g,A[6]=e*c+n,A[10]=t-i*c}else if("XZY"===t.order){const t=s*r,e=s*o,n=a*r,i=a*o;A[0]=r*g,A[4]=-c,A[8]=o*g,A[1]=t*c+i,A[5]=s*g,A[9]=e*c-n,A[2]=n*c-e,A[6]=a*g,A[10]=i*c+t}return A[3]=0,A[7]=0,A[11]=0,A[12]=0,A[13]=0,A[14]=0,A[15]=1,this}makeRotationFromQuaternion(t){return this.compose(ui,t,Bi)}lookAt(t,A,e){const n=this.elements;return Ei.subVectors(t,A),0===Ei.lengthSq()&&(Ei.z=1),Ei.normalize(),di.crossVectors(e,Ei),0===di.lengthSq()&&(1===Math.abs(e.z)?Ei.x+=1e-4:Ei.z+=1e-4,Ei.normalize(),di.crossVectors(e,Ei)),di.normalize(),Ci.crossVectors(Ei,di),n[0]=di.x,n[4]=Ci.x,n[8]=Ei.x,n[1]=di.y,n[5]=Ci.y,n[9]=Ei.y,n[2]=di.z,n[6]=Ci.z,n[10]=Ei.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,A){const e=t.elements,n=A.elements,i=this.elements,s=e[0],a=e[4],r=e[8],o=e[12],g=e[1],c=e[5],l=e[9],I=e[13],h=e[2],u=e[6],B=e[10],d=e[14],C=e[3],E=e[7],Q=e[11],p=e[15],f=n[0],m=n[4],y=n[8],w=n[12],x=n[1],S=n[5],D=n[9],v=n[13],M=n[2],b=n[6],_=n[10],R=n[14],F=n[3],N=n[7],k=n[11],T=n[15];return i[0]=s*f+a*x+r*M+o*F,i[4]=s*m+a*S+r*b+o*N,i[8]=s*y+a*D+r*_+o*k,i[12]=s*w+a*v+r*R+o*T,i[1]=g*f+c*x+l*M+I*F,i[5]=g*m+c*S+l*b+I*N,i[9]=g*y+c*D+l*_+I*k,i[13]=g*w+c*v+l*R+I*T,i[2]=h*f+u*x+B*M+d*F,i[6]=h*m+u*S+B*b+d*N,i[10]=h*y+u*D+B*_+d*k,i[14]=h*w+u*v+B*R+d*T,i[3]=C*f+E*x+Q*M+p*F,i[7]=C*m+E*S+Q*b+p*N,i[11]=C*y+E*D+Q*_+p*k,i[15]=C*w+E*v+Q*R+p*T,this}multiplyScalar(t){const A=this.elements;return A[0]*=t,A[4]*=t,A[8]*=t,A[12]*=t,A[1]*=t,A[5]*=t,A[9]*=t,A[13]*=t,A[2]*=t,A[6]*=t,A[10]*=t,A[14]*=t,A[3]*=t,A[7]*=t,A[11]*=t,A[15]*=t,this}determinant(){const t=this.elements,A=t[0],e=t[4],n=t[8],i=t[12],s=t[1],a=t[5],r=t[9],o=t[13],g=t[2],c=t[6],l=t[10],I=t[14];return t[3]*(+i*r*c-n*o*c-i*a*l+e*o*l+n*a*I-e*r*I)+t[7]*(+A*r*I-A*o*l+i*s*l-n*s*I+n*o*g-i*r*g)+t[11]*(+A*o*c-A*a*I-i*s*c+e*s*I+i*a*g-e*o*g)+t[15]*(-n*a*g-A*r*c+A*a*l+n*s*c-e*s*l+e*r*g)}transpose(){const t=this.elements;let A;return A=t[1],t[1]=t[4],t[4]=A,A=t[2],t[2]=t[8],t[8]=A,A=t[6],t[6]=t[9],t[9]=A,A=t[3],t[3]=t[12],t[12]=A,A=t[7],t[7]=t[13],t[13]=A,A=t[11],t[11]=t[14],t[14]=A,this}setPosition(t,A,e){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=A,n[14]=e),this}invert(){const t=this.elements,A=t[0],e=t[1],n=t[2],i=t[3],s=t[4],a=t[5],r=t[6],o=t[7],g=t[8],c=t[9],l=t[10],I=t[11],h=t[12],u=t[13],B=t[14],d=t[15],C=c*B*o-u*l*o+u*r*I-a*B*I-c*r*d+a*l*d,E=h*l*o-g*B*o-h*r*I+s*B*I+g*r*d-s*l*d,Q=g*u*o-h*c*o+h*a*I-s*u*I-g*a*d+s*c*d,p=h*c*r-g*u*r-h*a*l+s*u*l+g*a*B-s*c*B,f=A*C+e*E+n*Q+i*p;if(0===f)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=C*m,t[1]=(u*l*i-c*B*i-u*n*I+e*B*I+c*n*d-e*l*d)*m,t[2]=(a*B*i-u*r*i+u*n*o-e*B*o-a*n*d+e*r*d)*m,t[3]=(c*r*i-a*l*i-c*n*o+e*l*o+a*n*I-e*r*I)*m,t[4]=E*m,t[5]=(g*B*i-h*l*i+h*n*I-A*B*I-g*n*d+A*l*d)*m,t[6]=(h*r*i-s*B*i-h*n*o+A*B*o+s*n*d-A*r*d)*m,t[7]=(s*l*i-g*r*i+g*n*o-A*l*o-s*n*I+A*r*I)*m,t[8]=Q*m,t[9]=(h*c*i-g*u*i-h*e*I+A*u*I+g*e*d-A*c*d)*m,t[10]=(s*u*i-h*a*i+h*e*o-A*u*o-s*e*d+A*a*d)*m,t[11]=(g*a*i-s*c*i-g*e*o+A*c*o+s*e*I-A*a*I)*m,t[12]=p*m,t[13]=(g*u*n-h*c*n+h*e*l-A*u*l-g*e*B+A*c*B)*m,t[14]=(h*a*n-s*u*n-h*e*r+A*u*r+s*e*B-A*a*B)*m,t[15]=(s*c*n-g*a*n+g*e*r-A*c*r-s*e*l+A*a*l)*m,this}scale(t){const A=this.elements,e=t.x,n=t.y,i=t.z;return A[0]*=e,A[4]*=n,A[8]*=i,A[1]*=e,A[5]*=n,A[9]*=i,A[2]*=e,A[6]*=n,A[10]*=i,A[3]*=e,A[7]*=n,A[11]*=i,this}getMaxScaleOnAxis(){const t=this.elements,A=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(A,e,n))}makeTranslation(t,A,e){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,A,0,0,1,e,0,0,0,1),this}makeRotationX(t){const A=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,A,-e,0,0,e,A,0,0,0,0,1),this}makeRotationY(t){const A=Math.cos(t),e=Math.sin(t);return this.set(A,0,e,0,0,1,0,0,-e,0,A,0,0,0,0,1),this}makeRotationZ(t){const A=Math.cos(t),e=Math.sin(t);return this.set(A,-e,0,0,e,A,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,A){const e=Math.cos(A),n=Math.sin(A),i=1-e,s=t.x,a=t.y,r=t.z,o=i*s,g=i*a;return this.set(o*s+e,o*a-n*r,o*r+n*a,0,o*a+n*r,g*a+e,g*r-n*s,0,o*r-n*a,g*r+n*s,i*r*r+e,0,0,0,0,1),this}makeScale(t,A,e){return this.set(t,0,0,0,0,A,0,0,0,0,e,0,0,0,0,1),this}makeShear(t,A,e,n,i,s){return this.set(1,e,i,0,t,1,s,0,A,n,1,0,0,0,0,1),this}compose(t,A,e){const n=this.elements,i=A._x,s=A._y,a=A._z,r=A._w,o=i+i,g=s+s,c=a+a,l=i*o,I=i*g,h=i*c,u=s*g,B=s*c,d=a*c,C=r*o,E=r*g,Q=r*c,p=e.x,f=e.y,m=e.z;return n[0]=(1-(u+d))*p,n[1]=(I+Q)*p,n[2]=(h-E)*p,n[3]=0,n[4]=(I-Q)*f,n[5]=(1-(l+d))*f,n[6]=(B+C)*f,n[7]=0,n[8]=(h+E)*m,n[9]=(B-C)*m,n[10]=(1-(l+u))*m,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,A,e){const n=this.elements;let i=Ii.set(n[0],n[1],n[2]).length();const s=Ii.set(n[4],n[5],n[6]).length(),a=Ii.set(n[8],n[9],n[10]).length();this.determinant()<0&&(i=-i),t.x=n[12],t.y=n[13],t.z=n[14],hi.copy(this);const r=1/i,o=1/s,g=1/a;return hi.elements[0]*=r,hi.elements[1]*=r,hi.elements[2]*=r,hi.elements[4]*=o,hi.elements[5]*=o,hi.elements[6]*=o,hi.elements[8]*=g,hi.elements[9]*=g,hi.elements[10]*=g,A.setFromRotationMatrix(hi),e.x=i,e.y=s,e.z=a,this}makePerspective(t,A,e,n,i,s,a=Te){const r=this.elements,o=2*i/(A-t),g=2*i/(e-n),c=(A+t)/(A-t),l=(e+n)/(e-n);let I,h;if(a===Te)I=-(s+i)/(s-i),h=-2*s*i/(s-i);else{if(a!==Ge)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);I=-s/(s-i),h=-s*i/(s-i)}return r[0]=o,r[4]=0,r[8]=c,r[12]=0,r[1]=0,r[5]=g,r[9]=l,r[13]=0,r[2]=0,r[6]=0,r[10]=I,r[14]=h,r[3]=0,r[7]=0,r[11]=-1,r[15]=0,this}makeOrthographic(t,A,e,n,i,s,a=Te){const r=this.elements,o=1/(A-t),g=1/(e-n),c=1/(s-i),l=(A+t)*o,I=(e+n)*g;let h,u;if(a===Te)h=(s+i)*c,u=-2*c;else{if(a!==Ge)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);h=i*c,u=-1*c}return r[0]=2*o,r[4]=0,r[8]=0,r[12]=-l,r[1]=0,r[5]=2*g,r[9]=0,r[13]=-I,r[2]=0,r[6]=0,r[10]=u,r[14]=-h,r[3]=0,r[7]=0,r[11]=0,r[15]=1,this}equals(t){const A=this.elements,e=t.elements;for(let t=0;t<16;t++)if(A[t]!==e[t])return!1;return!0}fromArray(t,A=0){for(let e=0;e<16;e++)this.elements[e]=t[e+A];return this}toArray(t=[],A=0){const e=this.elements;return t[A]=e[0],t[A+1]=e[1],t[A+2]=e[2],t[A+3]=e[3],t[A+4]=e[4],t[A+5]=e[5],t[A+6]=e[6],t[A+7]=e[7],t[A+8]=e[8],t[A+9]=e[9],t[A+10]=e[10],t[A+11]=e[11],t[A+12]=e[12],t[A+13]=e[13],t[A+14]=e[14],t[A+15]=e[15],t}}const Ii=new An,hi=new li,ui=new An(0,0,0),Bi=new An(1,1,1),di=new An,Ci=new An,Ei=new An,Qi=new li,pi=new tn;class fi{constructor(t=0,A=0,e=0,n=fi.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=A,this._z=e,this._order=n}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,A,e,n=this._order){return this._x=t,this._y=A,this._z=e,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,A=this._order,e=!0){const n=t.elements,i=n[0],s=n[4],a=n[8],r=n[1],o=n[5],g=n[9],c=n[2],l=n[6],I=n[10];switch(A){case"XYZ":this._y=Math.asin(Ke(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-g,I),this._z=Math.atan2(-s,i)):(this._x=Math.atan2(l,o),this._z=0);break;case"YXZ":this._x=Math.asin(-Ke(g,-1,1)),Math.abs(g)<.9999999?(this._y=Math.atan2(a,I),this._z=Math.atan2(r,o)):(this._y=Math.atan2(-c,i),this._z=0);break;case"ZXY":this._x=Math.asin(Ke(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(-c,I),this._z=Math.atan2(-s,o)):(this._y=0,this._z=Math.atan2(r,i));break;case"ZYX":this._y=Math.asin(-Ke(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(l,I),this._z=Math.atan2(r,i)):(this._x=0,this._z=Math.atan2(-s,o));break;case"YZX":this._z=Math.asin(Ke(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(-g,o),this._y=Math.atan2(-c,i)):(this._x=0,this._y=Math.atan2(a,I));break;case"XZY":this._z=Math.asin(-Ke(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(l,o),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-g,I),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+A)}return this._order=A,!0===e&&this._onChangeCallback(),this}setFromQuaternion(t,A,e){return Qi.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Qi,A,e)}setFromVector3(t,A=this._order){return this.set(t.x,t.y,t.z,A)}reorder(t){return pi.setFromEuler(this),this.setFromQuaternion(pi,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],A=0){return t[A]=this._x,t[A+1]=this._y,t[A+2]=this._z,t[A+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}fi.DEFAULT_ORDER="XYZ";class mi{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return 0!==(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let yi=0;const wi=new An,xi=new tn,Si=new li,Di=new An,vi=new An,Mi=new An,bi=new tn,_i=new An(1,0,0),Ri=new An(0,1,0),Fi=new An(0,0,1),Ni={type:"added"},ki={type:"removed"},Ti={type:"childadded",child:null},Gi={type:"childremoved",child:null};class Ui extends Ye{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:yi++}),this.uuid=Oe(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ui.DEFAULT_UP.clone();const t=new An,A=new fi,e=new tn,n=new An(1,1,1);A._onChange(function(){e.setFromEuler(A,!1)}),e._onChange(function(){A.setFromQuaternion(e,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:A},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new li},normalMatrix:{value:new sn}}),this.matrix=new li,this.matrixWorld=new li,this.matrixAutoUpdate=Ui.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Ui.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new mi,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,A){this.quaternion.setFromAxisAngle(t,A)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,A){return xi.setFromAxisAngle(t,A),this.quaternion.multiply(xi),this}rotateOnWorldAxis(t,A){return xi.setFromAxisAngle(t,A),this.quaternion.premultiply(xi),this}rotateX(t){return this.rotateOnAxis(_i,t)}rotateY(t){return this.rotateOnAxis(Ri,t)}rotateZ(t){return this.rotateOnAxis(Fi,t)}translateOnAxis(t,A){return wi.copy(t).applyQuaternion(this.quaternion),this.position.add(wi.multiplyScalar(A)),this}translateX(t){return this.translateOnAxis(_i,t)}translateY(t){return this.translateOnAxis(Ri,t)}translateZ(t){return this.translateOnAxis(Fi,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Si.copy(this.matrixWorld).invert())}lookAt(t,A,e){t.isVector3?Di.copy(t):Di.set(t,A,e);const n=this.parent;this.updateWorldMatrix(!0,!1),vi.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Si.lookAt(vi,Di,this.up):Si.lookAt(Di,vi,this.up),this.quaternion.setFromRotationMatrix(Si),n&&(Si.extractRotation(n.matrixWorld),xi.setFromRotationMatrix(Si),this.quaternion.premultiply(xi.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(Ni),Ti.child=t,this.dispatchEvent(Ti),Ti.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const A=this.children.indexOf(t);return-1!==A&&(t.parent=null,this.children.splice(A,1),t.dispatchEvent(ki),Gi.child=t,this.dispatchEvent(Gi),Gi.child=null),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Si.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),Si.multiply(t.parent.matrixWorld)),t.applyMatrix4(Si),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(Ni),Ti.child=t,this.dispatchEvent(Ti),Ti.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,A){if(this[t]===A)return this;for(let e=0,n=this.children.length;e<n;e++){const n=this.children[e].getObjectByProperty(t,A);if(void 0!==n)return n}}getObjectsByProperty(t,A,e=[]){this[t]===A&&e.push(this);const n=this.children;for(let i=0,s=n.length;i<s;i++)n[i].getObjectsByProperty(t,A,e);return e}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(vi,t,Mi),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(vi,bi,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const A=this.matrixWorld.elements;return t.set(A[8],A[9],A[10]).normalize()}raycast(){}traverse(t){t(this);const A=this.children;for(let e=0,n=A.length;e<n;e++)A[e].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const A=this.children;for(let e=0,n=A.length;e<n;e++)A[e].traverseVisible(t)}traverseAncestors(t){const A=this.parent;null!==A&&(t(A),A.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const A=this.children;for(let e=0,n=A.length;e<n;e++)A[e].updateMatrixWorld(t)}updateWorldMatrix(t,A){const e=this.parent;if(!0===t&&null!==e&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===A){const t=this.children;for(let A=0,e=t.length;A<e;A++)t[A].updateWorldMatrix(!1,!0)}}toJSON(t){const A=void 0===t||"string"==typeof t,e={};A&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},e.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const n={};function i(A,e){return void 0===A[e.uuid]&&(A[e.uuid]=e.toJSON(t)),e.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.geometryInfo=this._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox?t.boundingBox.toJSON():void 0,boundingSphere:t.boundingSphere?t.boundingSphere.toJSON():void 0})),n.instanceInfo=this._instanceInfo.map(t=>({...t})),n.availableInstanceIds=this._availableInstanceIds.slice(),n.availableGeometryIds=this._availableGeometryIds.slice(),n.nextIndexStart=this._nextIndexStart,n.nextVertexStart=this._nextVertexStart,n.geometryCount=this._geometryCount,n.maxInstanceCount=this._maxInstanceCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.matricesTexture=this._matricesTexture.toJSON(t),n.indirectTexture=this._indirectTexture.toJSON(t),null!==this._colorsTexture&&(n.colorsTexture=this._colorsTexture.toJSON(t)),null!==this.boundingSphere&&(n.boundingSphere=this.boundingSphere.toJSON()),null!==this.boundingBox&&(n.boundingBox=this.boundingBox.toJSON())),this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=i(t.geometries,this.geometry);const A=this.geometry.parameters;if(void 0!==A&&void 0!==A.shapes){const e=A.shapes;if(Array.isArray(e))for(let A=0,n=e.length;A<n;A++){const n=e[A];i(t.shapes,n)}else i(t.shapes,e)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const A=[];for(let e=0,n=this.material.length;e<n;e++)A.push(i(t.materials,this.material[e]));n.material=A}else n.material=i(t.materials,this.material);if(this.children.length>0){n.children=[];for(let A=0;A<this.children.length;A++)n.children.push(this.children[A].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let A=0;A<this.animations.length;A++){const e=this.animations[A];n.animations.push(i(t.animations,e))}}if(A){const A=s(t.geometries),n=s(t.materials),i=s(t.textures),a=s(t.images),r=s(t.shapes),o=s(t.skeletons),g=s(t.animations),c=s(t.nodes);A.length>0&&(e.geometries=A),n.length>0&&(e.materials=n),i.length>0&&(e.textures=i),a.length>0&&(e.images=a),r.length>0&&(e.shapes=r),o.length>0&&(e.skeletons=o),g.length>0&&(e.animations=g),c.length>0&&(e.nodes=c)}return e.object=n,e;function s(t){const A=[];for(const e in t){const n=t[e];delete n.metadata,A.push(n)}return A}}clone(t){return(new this.constructor).copy(this,t)}copy(t,A=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===A)for(let A=0;A<t.children.length;A++){const e=t.children[A];this.add(e.clone())}return this}}Ui.DEFAULT_UP=new An(0,1,0),Ui.DEFAULT_MATRIX_AUTO_UPDATE=!0,Ui.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Li=new An,Hi=new An,Yi=new An,Pi=new An,Ji=new An,qi=new An,zi=new An,Oi=new An,Ki=new An,Vi=new An,Wi=new _n,ji=new _n,Zi=new _n;class Xi{constructor(t=new An,A=new An,e=new An){this.a=t,this.b=A,this.c=e}static getNormal(t,A,e,n){n.subVectors(e,A),Li.subVectors(t,A),n.cross(Li);const i=n.lengthSq();return i>0?n.multiplyScalar(1/Math.sqrt(i)):n.set(0,0,0)}static getBarycoord(t,A,e,n,i){Li.subVectors(n,A),Hi.subVectors(e,A),Yi.subVectors(t,A);const s=Li.dot(Li),a=Li.dot(Hi),r=Li.dot(Yi),o=Hi.dot(Hi),g=Hi.dot(Yi),c=s*o-a*a;if(0===c)return i.set(0,0,0),null;const l=1/c,I=(o*r-a*g)*l,h=(s*g-a*r)*l;return i.set(1-I-h,h,I)}static containsPoint(t,A,e,n){return null!==this.getBarycoord(t,A,e,n,Pi)&&Pi.x>=0&&Pi.y>=0&&Pi.x+Pi.y<=1}static getInterpolation(t,A,e,n,i,s,a,r){return null===this.getBarycoord(t,A,e,n,Pi)?(r.x=0,r.y=0,"z"in r&&(r.z=0),"w"in r&&(r.w=0),null):(r.setScalar(0),r.addScaledVector(i,Pi.x),r.addScaledVector(s,Pi.y),r.addScaledVector(a,Pi.z),r)}static getInterpolatedAttribute(t,A,e,n,i,s){return Wi.setScalar(0),ji.setScalar(0),Zi.setScalar(0),Wi.fromBufferAttribute(t,A),ji.fromBufferAttribute(t,e),Zi.fromBufferAttribute(t,n),s.setScalar(0),s.addScaledVector(Wi,i.x),s.addScaledVector(ji,i.y),s.addScaledVector(Zi,i.z),s}static isFrontFacing(t,A,e,n){return Li.subVectors(e,A),Hi.subVectors(t,A),Li.cross(Hi).dot(n)<0}set(t,A,e){return this.a.copy(t),this.b.copy(A),this.c.copy(e),this}setFromPointsAndIndices(t,A,e,n){return this.a.copy(t[A]),this.b.copy(t[e]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,A,e,n){return this.a.fromBufferAttribute(t,A),this.b.fromBufferAttribute(t,e),this.c.fromBufferAttribute(t,n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Li.subVectors(this.c,this.b),Hi.subVectors(this.a,this.b),.5*Li.cross(Hi).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Xi.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,A){return Xi.getBarycoord(t,this.a,this.b,this.c,A)}getInterpolation(t,A,e,n,i){return Xi.getInterpolation(t,this.a,this.b,this.c,A,e,n,i)}containsPoint(t){return Xi.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Xi.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,A){const e=this.a,n=this.b,i=this.c;let s,a;Ji.subVectors(n,e),qi.subVectors(i,e),Oi.subVectors(t,e);const r=Ji.dot(Oi),o=qi.dot(Oi);if(r<=0&&o<=0)return A.copy(e);Ki.subVectors(t,n);const g=Ji.dot(Ki),c=qi.dot(Ki);if(g>=0&&c<=g)return A.copy(n);const l=r*c-g*o;if(l<=0&&r>=0&&g<=0)return s=r/(r-g),A.copy(e).addScaledVector(Ji,s);Vi.subVectors(t,i);const I=Ji.dot(Vi),h=qi.dot(Vi);if(h>=0&&I<=h)return A.copy(i);const u=I*o-r*h;if(u<=0&&o>=0&&h<=0)return a=o/(o-h),A.copy(e).addScaledVector(qi,a);const B=g*h-I*c;if(B<=0&&c-g>=0&&I-h>=0)return zi.subVectors(i,n),a=(c-g)/(c-g+(I-h)),A.copy(n).addScaledVector(zi,a);const d=1/(B+u+l);return s=u*d,a=l*d,A.copy(e).addScaledVector(Ji,s).addScaledVector(qi,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const $i={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ts={h:0,s:0,l:0},As={h:0,s:0,l:0};function es(t,A,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?t+6*(A-t)*e:e<.5?A:e<2/3?t+6*(A-t)*(2/3-e):t}class ns{constructor(t,A,e){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,A,e)}set(t,A,e){if(void 0===A&&void 0===e){const A=t;A&&A.isColor?this.copy(A):"number"==typeof A?this.setHex(A):"string"==typeof A&&this.setStyle(A)}else this.setRGB(t,A,e);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,A=ZA){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,pn.colorSpaceToWorking(this,A),this}setRGB(t,A,e,n=pn.workingColorSpace){return this.r=t,this.g=A,this.b=e,pn.colorSpaceToWorking(this,n),this}setHSL(t,A,e,n=pn.workingColorSpace){if(t=Ve(t,1),A=Ke(A,0,1),e=Ke(e,0,1),0===A)this.r=this.g=this.b=e;else{const n=e<=.5?e*(1+A):e+A-e*A,i=2*e-n;this.r=es(i,n,t+1/3),this.g=es(i,n,t),this.b=es(i,n,t-1/3)}return pn.colorSpaceToWorking(this,n),this}setStyle(t,A=ZA){function e(A){void 0!==A&&parseFloat(A)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(t)){let i;const s=n[1],a=n[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return e(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,A);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return e(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,A);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return e(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,A);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const e=n[1],i=e.length;if(3===i)return this.setRGB(parseInt(e.charAt(0),16)/15,parseInt(e.charAt(1),16)/15,parseInt(e.charAt(2),16)/15,A);if(6===i)return this.setHex(parseInt(e,16),A);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,A);return this}setColorName(t,A=ZA){const e=$i[t.toLowerCase()];return void 0!==e?this.setHex(e,A):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=fn(t.r),this.g=fn(t.g),this.b=fn(t.b),this}copyLinearToSRGB(t){return this.r=mn(t.r),this.g=mn(t.g),this.b=mn(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=ZA){return pn.workingToColorSpace(is.copy(this),t),65536*Math.round(Ke(255*is.r,0,255))+256*Math.round(Ke(255*is.g,0,255))+Math.round(Ke(255*is.b,0,255))}getHexString(t=ZA){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,A=pn.workingColorSpace){pn.workingToColorSpace(is.copy(this),A);const e=is.r,n=is.g,i=is.b,s=Math.max(e,n,i),a=Math.min(e,n,i);let r,o;const g=(a+s)/2;if(a===s)r=0,o=0;else{const t=s-a;switch(o=g<=.5?t/(s+a):t/(2-s-a),s){case e:r=(n-i)/t+(n<i?6:0);break;case n:r=(i-e)/t+2;break;case i:r=(e-n)/t+4}r/=6}return t.h=r,t.s=o,t.l=g,t}getRGB(t,A=pn.workingColorSpace){return pn.workingToColorSpace(is.copy(this),A),t.r=is.r,t.g=is.g,t.b=is.b,t}getStyle(t=ZA){pn.workingToColorSpace(is.copy(this),t);const A=is.r,e=is.g,n=is.b;return t!==ZA?`color(${t} ${A.toFixed(3)} ${e.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(255*A)},${Math.round(255*e)},${Math.round(255*n)})`}offsetHSL(t,A,e){return this.getHSL(ts),this.setHSL(ts.h+t,ts.s+A,ts.l+e)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,A){return this.r=t.r+A.r,this.g=t.g+A.g,this.b=t.b+A.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,A){return this.r+=(t.r-this.r)*A,this.g+=(t.g-this.g)*A,this.b+=(t.b-this.b)*A,this}lerpColors(t,A,e){return this.r=t.r+(A.r-t.r)*e,this.g=t.g+(A.g-t.g)*e,this.b=t.b+(A.b-t.b)*e,this}lerpHSL(t,A){this.getHSL(ts),t.getHSL(As);const e=We(ts.h,As.h,A),n=We(ts.s,As.s,A),i=We(ts.l,As.l,A);return this.setHSL(e,n,i),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const A=this.r,e=this.g,n=this.b,i=t.elements;return this.r=i[0]*A+i[3]*e+i[6]*n,this.g=i[1]*A+i[4]*e+i[7]*n,this.b=i[2]*A+i[5]*e+i[8]*n,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,A=0){return this.r=t[A],this.g=t[A+1],this.b=t[A+2],this}toArray(t=[],A=0){return t[A]=this.r,t[A+1]=this.g,t[A+2]=this.b,t}fromBufferAttribute(t,A){return this.r=t.getX(A),this.g=t.getY(A),this.b=t.getZ(A),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const is=new ns;ns.NAMES=$i;let ss=0;class as extends Ye{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:ss++}),this.uuid=Oe(),this.name="",this.type="Material",this.blending=E,this.side=u,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=R,this.blendDst=F,this.blendEquation=y,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ns(0,0,0),this.blendAlpha=0,this.depthFunc=O,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=de,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ee,this.stencilZFail=ee,this.stencilZPass=ee,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const A in t){const e=t[A];if(void 0===e){console.warn(`THREE.Material: parameter '${A}' has value of undefined.`);continue}const n=this[A];void 0!==n?n&&n.isColor?n.set(e):n&&n.isVector3&&e&&e.isVector3?n.copy(e):this[A]=e:console.warn(`THREE.Material: '${A}' is not a property of THREE.${this.type}.`)}}toJSON(t){const A=void 0===t||"string"==typeof t;A&&(t={textures:{},images:{}});const e={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};function n(t){const A=[];for(const e in t){const n=t[e];delete n.metadata,A.push(n)}return A}if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),void 0!==this.roughness&&(e.roughness=this.roughness),void 0!==this.metalness&&(e.metalness=this.metalness),void 0!==this.sheen&&(e.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(e.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(e.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(e.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(e.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(e.shininess=this.shininess),void 0!==this.clearcoat&&(e.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.dispersion&&(e.dispersion=this.dispersion),void 0!==this.iridescence&&(e.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(e.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(e.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(e.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(e.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(e.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(e.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(e.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(t).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(t).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(t).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(t).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(t).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(e.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(e.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(e.combine=this.combine)),void 0!==this.envMapRotation&&(e.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(e.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(e.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(e.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(e.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(e.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(e.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(e.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(e.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(e.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(e.size=this.size),null!==this.shadowSide&&(e.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==E&&(e.blending=this.blending),this.side!==u&&(e.side=this.side),!0===this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),!0===this.transparent&&(e.transparent=!0),this.blendSrc!==R&&(e.blendSrc=this.blendSrc),this.blendDst!==F&&(e.blendDst=this.blendDst),this.blendEquation!==y&&(e.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(e.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(e.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(e.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(e.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(e.blendAlpha=this.blendAlpha),this.depthFunc!==O&&(e.depthFunc=this.depthFunc),!1===this.depthTest&&(e.depthTest=this.depthTest),!1===this.depthWrite&&(e.depthWrite=this.depthWrite),!1===this.colorWrite&&(e.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(e.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==de&&(e.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(e.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(e.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==ee&&(e.stencilFail=this.stencilFail),this.stencilZFail!==ee&&(e.stencilZFail=this.stencilZFail),this.stencilZPass!==ee&&(e.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(e.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(e.rotation=this.rotation),!0===this.polygonOffset&&(e.polygonOffset=!0),0!==this.polygonOffsetFactor&&(e.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(e.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(e.linewidth=this.linewidth),void 0!==this.dashSize&&(e.dashSize=this.dashSize),void 0!==this.gapSize&&(e.gapSize=this.gapSize),void 0!==this.scale&&(e.scale=this.scale),!0===this.dithering&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),!0===this.alphaHash&&(e.alphaHash=!0),!0===this.alphaToCoverage&&(e.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(e.premultipliedAlpha=!0),!0===this.forceSinglePass&&(e.forceSinglePass=!0),!0===this.wireframe&&(e.wireframe=!0),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(e.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(e.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(e.flatShading=!0),!1===this.visible&&(e.visible=!1),!1===this.toneMapped&&(e.toneMapped=!1),!1===this.fog&&(e.fog=!1),Object.keys(this.userData).length>0&&(e.userData=this.userData),A){const A=n(t.textures),i=n(t.images);A.length>0&&(e.textures=A),i.length>0&&(e.images=i)}return e}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const A=t.clippingPlanes;let e=null;if(null!==A){const t=A.length;e=new Array(t);for(let n=0;n!==t;++n)e[n]=A[n].clone()}return this.clippingPlanes=e,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}class rs extends as{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ns(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new fi,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const os=gs();function gs(){const t=new ArrayBuffer(4),A=new Float32Array(t),e=new Uint32Array(t),n=new Uint32Array(512),i=new Uint32Array(512);for(let t=0;t<256;++t){const A=t-127;A<-27?(n[t]=0,n[256|t]=32768,i[t]=24,i[256|t]=24):A<-14?(n[t]=1024>>-A-14,n[256|t]=1024>>-A-14|32768,i[t]=-A-1,i[256|t]=-A-1):A<=15?(n[t]=A+15<<10,n[256|t]=A+15<<10|32768,i[t]=13,i[256|t]=13):A<128?(n[t]=31744,n[256|t]=64512,i[t]=24,i[256|t]=24):(n[t]=31744,n[256|t]=64512,i[t]=13,i[256|t]=13)}const s=new Uint32Array(2048),a=new Uint32Array(64),r=new Uint32Array(64);for(let t=1;t<1024;++t){let A=t<<13,e=0;for(;!(8388608&A);)A<<=1,e-=8388608;A&=-8388609,e+=947912704,s[t]=A|e}for(let t=1024;t<2048;++t)s[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)a[t]=t<<23;a[31]=1199570944,a[32]=2147483648;for(let t=33;t<63;++t)a[t]=2147483648+(t-32<<23);a[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(r[t]=1024);return{floatView:A,uint32View:e,baseTable:n,shiftTable:i,mantissaTable:s,exponentTable:a,offsetTable:r}}function cs(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=Ke(t,-65504,65504),os.floatView[0]=t;const A=os.uint32View[0],e=A>>23&511;return os.baseTable[e]+((8388607&A)>>os.shiftTable[e])}function ls(t){const A=t>>10;return os.uint32View[0]=os.mantissaTable[os.offsetTable[A]+(1023&t)]+os.exponentTable[A],os.floatView[0]}class Is{static toHalfFloat(t){return cs(t)}static fromHalfFloat(t){return ls(t)}}const hs=new An,us=new $e;let Bs=0;class ds{constructor(t,A,e=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:Bs++}),this.name="",this.array=t,this.itemSize=A,this.count=void 0!==t?t.length/A:0,this.normalized=e,this.usage=xe,this.updateRanges=[],this.gpuType=kt,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,A){this.updateRanges.push({start:t,count:A})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,A,e){t*=this.itemSize,e*=A.itemSize;for(let n=0,i=this.itemSize;n<i;n++)this.array[t+n]=A.array[e+n];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let A=0,e=this.count;A<e;A++)us.fromBufferAttribute(this,A),us.applyMatrix3(t),this.setXY(A,us.x,us.y);else if(3===this.itemSize)for(let A=0,e=this.count;A<e;A++)hs.fromBufferAttribute(this,A),hs.applyMatrix3(t),this.setXYZ(A,hs.x,hs.y,hs.z);return this}applyMatrix4(t){for(let A=0,e=this.count;A<e;A++)hs.fromBufferAttribute(this,A),hs.applyMatrix4(t),this.setXYZ(A,hs.x,hs.y,hs.z);return this}applyNormalMatrix(t){for(let A=0,e=this.count;A<e;A++)hs.fromBufferAttribute(this,A),hs.applyNormalMatrix(t),this.setXYZ(A,hs.x,hs.y,hs.z);return this}transformDirection(t){for(let A=0,e=this.count;A<e;A++)hs.fromBufferAttribute(this,A),hs.transformDirection(t),this.setXYZ(A,hs.x,hs.y,hs.z);return this}set(t,A=0){return this.array.set(t,A),this}getComponent(t,A){let e=this.array[t*this.itemSize+A];return this.normalized&&(e=je(e,this.array)),e}setComponent(t,A,e){return this.normalized&&(e=Ze(e,this.array)),this.array[t*this.itemSize+A]=e,this}getX(t){let A=this.array[t*this.itemSize];return this.normalized&&(A=je(A,this.array)),A}setX(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize]=A,this}getY(t){let A=this.array[t*this.itemSize+1];return this.normalized&&(A=je(A,this.array)),A}setY(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize+1]=A,this}getZ(t){let A=this.array[t*this.itemSize+2];return this.normalized&&(A=je(A,this.array)),A}setZ(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize+2]=A,this}getW(t){let A=this.array[t*this.itemSize+3];return this.normalized&&(A=je(A,this.array)),A}setW(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize+3]=A,this}setXY(t,A,e){return t*=this.itemSize,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array)),this.array[t+0]=A,this.array[t+1]=e,this}setXYZ(t,A,e,n){return t*=this.itemSize,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array),n=Ze(n,this.array)),this.array[t+0]=A,this.array[t+1]=e,this.array[t+2]=n,this}setXYZW(t,A,e,n,i){return t*=this.itemSize,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array),n=Ze(n,this.array),i=Ze(i,this.array)),this.array[t+0]=A,this.array[t+1]=e,this.array[t+2]=n,this.array[t+3]=i,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==xe&&(t.usage=this.usage),t}}class Cs extends ds{constructor(t,A,e){super(new Int8Array(t),A,e)}}class Es extends ds{constructor(t,A,e){super(new Uint8Array(t),A,e)}}class Qs extends ds{constructor(t,A,e){super(new Uint8ClampedArray(t),A,e)}}class ps extends ds{constructor(t,A,e){super(new Int16Array(t),A,e)}}class fs extends ds{constructor(t,A,e){super(new Uint16Array(t),A,e)}}class ms extends ds{constructor(t,A,e){super(new Int32Array(t),A,e)}}class ys extends ds{constructor(t,A,e){super(new Uint32Array(t),A,e)}}class ws extends ds{constructor(t,A,e){super(new Uint16Array(t),A,e),this.isFloat16BufferAttribute=!0}getX(t){let A=ls(this.array[t*this.itemSize]);return this.normalized&&(A=je(A,this.array)),A}setX(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize]=cs(A),this}getY(t){let A=ls(this.array[t*this.itemSize+1]);return this.normalized&&(A=je(A,this.array)),A}setY(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize+1]=cs(A),this}getZ(t){let A=ls(this.array[t*this.itemSize+2]);return this.normalized&&(A=je(A,this.array)),A}setZ(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize+2]=cs(A),this}getW(t){let A=ls(this.array[t*this.itemSize+3]);return this.normalized&&(A=je(A,this.array)),A}setW(t,A){return this.normalized&&(A=Ze(A,this.array)),this.array[t*this.itemSize+3]=cs(A),this}setXY(t,A,e){return t*=this.itemSize,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array)),this.array[t+0]=cs(A),this.array[t+1]=cs(e),this}setXYZ(t,A,e,n){return t*=this.itemSize,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array),n=Ze(n,this.array)),this.array[t+0]=cs(A),this.array[t+1]=cs(e),this.array[t+2]=cs(n),this}setXYZW(t,A,e,n,i){return t*=this.itemSize,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array),n=Ze(n,this.array),i=Ze(i,this.array)),this.array[t+0]=cs(A),this.array[t+1]=cs(e),this.array[t+2]=cs(n),this.array[t+3]=cs(i),this}}class xs extends ds{constructor(t,A,e){super(new Float32Array(t),A,e)}}let Ss=0;const Ds=new li,vs=new Ui,Ms=new An,bs=new Un,_s=new Un,Rs=new An;class Fs extends Ye{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ss++}),this.uuid=Oe(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(rn(t)?ys:fs)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,A){return this.attributes[t]=A,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,A,e=0){this.groups.push({start:t,count:A,materialIndex:e})}clearGroups(){this.groups=[]}setDrawRange(t,A){this.drawRange.start=t,this.drawRange.count=A}applyMatrix4(t){const A=this.attributes.position;void 0!==A&&(A.applyMatrix4(t),A.needsUpdate=!0);const e=this.attributes.normal;if(void 0!==e){const A=(new sn).getNormalMatrix(t);e.applyNormalMatrix(A),e.needsUpdate=!0}const n=this.attributes.tangent;return void 0!==n&&(n.transformDirection(t),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Ds.makeRotationFromQuaternion(t),this.applyMatrix4(Ds),this}rotateX(t){return Ds.makeRotationX(t),this.applyMatrix4(Ds),this}rotateY(t){return Ds.makeRotationY(t),this.applyMatrix4(Ds),this}rotateZ(t){return Ds.makeRotationZ(t),this.applyMatrix4(Ds),this}translate(t,A,e){return Ds.makeTranslation(t,A,e),this.applyMatrix4(Ds),this}scale(t,A,e){return Ds.makeScale(t,A,e),this.applyMatrix4(Ds),this}lookAt(t){return vs.lookAt(t),vs.updateMatrix(),this.applyMatrix4(vs.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ms).negate(),this.translate(Ms.x,Ms.y,Ms.z),this}setFromPoints(t){const A=this.getAttribute("position");if(void 0===A){const A=[];for(let e=0,n=t.length;e<n;e++){const n=t[e];A.push(n.x,n.y,n.z||0)}this.setAttribute("position",new xs(A,3))}else{const e=Math.min(t.length,A.count);for(let n=0;n<e;n++){const e=t[n];A.setXYZ(n,e.x,e.y,e.z||0)}t.length>A.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),A.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Un);const t=this.attributes.position,A=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new An(-1/0,-1/0,-1/0),new An(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),A)for(let t=0,e=A.length;t<e;t++){const e=A[t];bs.setFromBufferAttribute(e),this.morphTargetsRelative?(Rs.addVectors(this.boundingBox.min,bs.min),this.boundingBox.expandByPoint(Rs),Rs.addVectors(this.boundingBox.max,bs.max),this.boundingBox.expandByPoint(Rs)):(this.boundingBox.expandByPoint(bs.min),this.boundingBox.expandByPoint(bs.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new ei);const t=this.attributes.position,A=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new An,1/0);if(t){const e=this.boundingSphere.center;if(bs.setFromBufferAttribute(t),A)for(let t=0,e=A.length;t<e;t++){const e=A[t];_s.setFromBufferAttribute(e),this.morphTargetsRelative?(Rs.addVectors(bs.min,_s.min),bs.expandByPoint(Rs),Rs.addVectors(bs.max,_s.max),bs.expandByPoint(Rs)):(bs.expandByPoint(_s.min),bs.expandByPoint(_s.max))}bs.getCenter(e);let n=0;for(let A=0,i=t.count;A<i;A++)Rs.fromBufferAttribute(t,A),n=Math.max(n,e.distanceToSquared(Rs));if(A)for(let i=0,s=A.length;i<s;i++){const s=A[i],a=this.morphTargetsRelative;for(let A=0,i=s.count;A<i;A++)Rs.fromBufferAttribute(s,A),a&&(Ms.fromBufferAttribute(t,A),Rs.add(Ms)),n=Math.max(n,e.distanceToSquared(Rs))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,A=this.attributes;if(null===t||void 0===A.position||void 0===A.normal||void 0===A.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const e=A.position,n=A.normal,i=A.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new ds(new Float32Array(4*e.count),4));const s=this.getAttribute("tangent"),a=[],r=[];for(let t=0;t<e.count;t++)a[t]=new An,r[t]=new An;const o=new An,g=new An,c=new An,l=new $e,I=new $e,h=new $e,u=new An,B=new An;function d(t,A,n){o.fromBufferAttribute(e,t),g.fromBufferAttribute(e,A),c.fromBufferAttribute(e,n),l.fromBufferAttribute(i,t),I.fromBufferAttribute(i,A),h.fromBufferAttribute(i,n),g.sub(o),c.sub(o),I.sub(l),h.sub(l);const s=1/(I.x*h.y-h.x*I.y);isFinite(s)&&(u.copy(g).multiplyScalar(h.y).addScaledVector(c,-I.y).multiplyScalar(s),B.copy(c).multiplyScalar(I.x).addScaledVector(g,-h.x).multiplyScalar(s),a[t].add(u),a[A].add(u),a[n].add(u),r[t].add(B),r[A].add(B),r[n].add(B))}let C=this.groups;0===C.length&&(C=[{start:0,count:t.count}]);for(let A=0,e=C.length;A<e;++A){const e=C[A],n=e.start;for(let A=n,i=n+e.count;A<i;A+=3)d(t.getX(A+0),t.getX(A+1),t.getX(A+2))}const E=new An,Q=new An,p=new An,f=new An;function m(t){p.fromBufferAttribute(n,t),f.copy(p);const A=a[t];E.copy(A),E.sub(p.multiplyScalar(p.dot(A))).normalize(),Q.crossVectors(f,A);const e=Q.dot(r[t])<0?-1:1;s.setXYZW(t,E.x,E.y,E.z,e)}for(let A=0,e=C.length;A<e;++A){const e=C[A],n=e.start;for(let A=n,i=n+e.count;A<i;A+=3)m(t.getX(A+0)),m(t.getX(A+1)),m(t.getX(A+2))}}computeVertexNormals(){const t=this.index,A=this.getAttribute("position");if(void 0!==A){let e=this.getAttribute("normal");if(void 0===e)e=new ds(new Float32Array(3*A.count),3),this.setAttribute("normal",e);else for(let t=0,A=e.count;t<A;t++)e.setXYZ(t,0,0,0);const n=new An,i=new An,s=new An,a=new An,r=new An,o=new An,g=new An,c=new An;if(t)for(let l=0,I=t.count;l<I;l+=3){const I=t.getX(l+0),h=t.getX(l+1),u=t.getX(l+2);n.fromBufferAttribute(A,I),i.fromBufferAttribute(A,h),s.fromBufferAttribute(A,u),g.subVectors(s,i),c.subVectors(n,i),g.cross(c),a.fromBufferAttribute(e,I),r.fromBufferAttribute(e,h),o.fromBufferAttribute(e,u),a.add(g),r.add(g),o.add(g),e.setXYZ(I,a.x,a.y,a.z),e.setXYZ(h,r.x,r.y,r.z),e.setXYZ(u,o.x,o.y,o.z)}else for(let t=0,a=A.count;t<a;t+=3)n.fromBufferAttribute(A,t+0),i.fromBufferAttribute(A,t+1),s.fromBufferAttribute(A,t+2),g.subVectors(s,i),c.subVectors(n,i),g.cross(c),e.setXYZ(t+0,g.x,g.y,g.z),e.setXYZ(t+1,g.x,g.y,g.z),e.setXYZ(t+2,g.x,g.y,g.z);this.normalizeNormals(),e.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let A=0,e=t.count;A<e;A++)Rs.fromBufferAttribute(t,A),Rs.normalize(),t.setXYZ(A,Rs.x,Rs.y,Rs.z)}toNonIndexed(){function t(t,A){const e=t.array,n=t.itemSize,i=t.normalized,s=new e.constructor(A.length*n);let a=0,r=0;for(let i=0,o=A.length;i<o;i++){a=t.isInterleavedBufferAttribute?A[i]*t.data.stride+t.offset:A[i]*n;for(let t=0;t<n;t++)s[r++]=e[a++]}return new ds(s,n,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const A=new Fs,e=this.index.array,n=this.attributes;for(const i in n){const s=t(n[i],e);A.setAttribute(i,s)}const i=this.morphAttributes;for(const n in i){const s=[],a=i[n];for(let A=0,n=a.length;A<n;A++){const n=t(a[A],e);s.push(n)}A.morphAttributes[n]=s}A.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];A.addGroup(e.start,e.count,e.materialIndex)}return A}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const A=this.parameters;for(const e in A)void 0!==A[e]&&(t[e]=A[e]);return t}t.data={attributes:{}};const A=this.index;null!==A&&(t.data.index={type:A.array.constructor.name,array:Array.prototype.slice.call(A.array)});const e=this.attributes;for(const A in e){const n=e[A];t.data.attributes[A]=n.toJSON(t.data)}const n={};let i=!1;for(const A in this.morphAttributes){const e=this.morphAttributes[A],s=[];for(let A=0,n=e.length;A<n;A++){const n=e[A];s.push(n.toJSON(t.data))}s.length>0&&(n[A]=s,i=!0)}i&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere=a.toJSON()),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const A={};this.name=t.name;const e=t.index;null!==e&&this.setIndex(e.clone());const n=t.attributes;for(const t in n){const e=n[t];this.setAttribute(t,e.clone(A))}const i=t.morphAttributes;for(const t in i){const e=[],n=i[t];for(let t=0,i=n.length;t<i;t++)e.push(n[t].clone(A));this.morphAttributes[t]=e}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,A=s.length;t<A;t++){const A=s[t];this.addGroup(A.start,A.count,A.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const r=t.boundingSphere;return null!==r&&(this.boundingSphere=r.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ns=new li,ks=new ci,Ts=new ei,Gs=new An,Us=new An,Ls=new An,Hs=new An,Ys=new An,Ps=new An,Js=new An,qs=new An;class zs extends Ui{constructor(t=new Fs,A=new rs){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=A,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,A){return super.copy(t,A),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,A=Object.keys(t);if(A.length>0){const e=t[A[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,A=e.length;t<A;t++){const A=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[A]=t}}}}getVertexPosition(t,A){const e=this.geometry,n=e.attributes.position,i=e.morphAttributes.position,s=e.morphTargetsRelative;A.fromBufferAttribute(n,t);const a=this.morphTargetInfluences;if(i&&a){Ps.set(0,0,0);for(let e=0,n=i.length;e<n;e++){const n=a[e],r=i[e];0!==n&&(Ys.fromBufferAttribute(r,t),s?Ps.addScaledVector(Ys,n):Ps.addScaledVector(Ys.sub(A),n))}A.add(Ps)}return A}raycast(t,A){const e=this.geometry,n=this.material,i=this.matrixWorld;if(void 0!==n){if(null===e.boundingSphere&&e.computeBoundingSphere(),Ts.copy(e.boundingSphere),Ts.applyMatrix4(i),ks.copy(t.ray).recast(t.near),!1===Ts.containsPoint(ks.origin)){if(null===ks.intersectSphere(Ts,Gs))return;if(ks.origin.distanceToSquared(Gs)>(t.far-t.near)**2)return}Ns.copy(i).invert(),ks.copy(t.ray).applyMatrix4(Ns),null!==e.boundingBox&&!1===ks.intersectsBox(e.boundingBox)||this._computeIntersections(t,A,ks)}}_computeIntersections(t,A,e){let n;const i=this.geometry,s=this.material,a=i.index,r=i.attributes.position,o=i.attributes.uv,g=i.attributes.uv1,c=i.attributes.normal,l=i.groups,I=i.drawRange;if(null!==a)if(Array.isArray(s))for(let i=0,r=l.length;i<r;i++){const r=l[i],h=s[r.materialIndex];for(let i=Math.max(r.start,I.start),s=Math.min(a.count,Math.min(r.start+r.count,I.start+I.count));i<s;i+=3)n=Os(this,h,t,e,o,g,c,a.getX(i),a.getX(i+1),a.getX(i+2)),n&&(n.faceIndex=Math.floor(i/3),n.face.materialIndex=r.materialIndex,A.push(n))}else for(let i=Math.max(0,I.start),r=Math.min(a.count,I.start+I.count);i<r;i+=3)n=Os(this,s,t,e,o,g,c,a.getX(i),a.getX(i+1),a.getX(i+2)),n&&(n.faceIndex=Math.floor(i/3),A.push(n));else if(void 0!==r)if(Array.isArray(s))for(let i=0,a=l.length;i<a;i++){const a=l[i],h=s[a.materialIndex];for(let i=Math.max(a.start,I.start),s=Math.min(r.count,Math.min(a.start+a.count,I.start+I.count));i<s;i+=3)n=Os(this,h,t,e,o,g,c,i,i+1,i+2),n&&(n.faceIndex=Math.floor(i/3),n.face.materialIndex=a.materialIndex,A.push(n))}else for(let i=Math.max(0,I.start),a=Math.min(r.count,I.start+I.count);i<a;i+=3)n=Os(this,s,t,e,o,g,c,i,i+1,i+2),n&&(n.faceIndex=Math.floor(i/3),A.push(n))}}function Os(t,A,e,n,i,s,a,r,o,g){t.getVertexPosition(r,Us),t.getVertexPosition(o,Ls),t.getVertexPosition(g,Hs);const c=function(t,A,e,n,i,s,a,r){let o;if(o=A.side===B?n.intersectTriangle(a,s,i,!0,r):n.intersectTriangle(i,s,a,A.side===u,r),null===o)return null;qs.copy(r),qs.applyMatrix4(t.matrixWorld);const g=e.ray.origin.distanceTo(qs);return g<e.near||g>e.far?null:{distance:g,point:qs.clone(),object:t}}(t,A,e,n,Us,Ls,Hs,Js);if(c){const t=new An;Xi.getBarycoord(Js,Us,Ls,Hs,t),i&&(c.uv=Xi.getInterpolatedAttribute(i,r,o,g,t,new $e)),s&&(c.uv1=Xi.getInterpolatedAttribute(s,r,o,g,t,new $e)),a&&(c.normal=Xi.getInterpolatedAttribute(a,r,o,g,t,new An),c.normal.dot(n.direction)>0&&c.normal.multiplyScalar(-1));const A={a:r,b:o,c:g,normal:new An,materialIndex:0};Xi.getNormal(Us,Ls,Hs,A.normal),c.face=A,c.barycoord=t}return c}class Ks extends Fs{constructor(t=1,A=1,e=1,n=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:A,depth:e,widthSegments:n,heightSegments:i,depthSegments:s};const a=this;n=Math.floor(n),i=Math.floor(i),s=Math.floor(s);const r=[],o=[],g=[],c=[];let l=0,I=0;function h(t,A,e,n,i,s,h,u,B,d,C){const E=s/B,Q=h/d,p=s/2,f=h/2,m=u/2,y=B+1,w=d+1;let x=0,S=0;const D=new An;for(let s=0;s<w;s++){const a=s*Q-f;for(let r=0;r<y;r++){const l=r*E-p;D[t]=l*n,D[A]=a*i,D[e]=m,o.push(D.x,D.y,D.z),D[t]=0,D[A]=0,D[e]=u>0?1:-1,g.push(D.x,D.y,D.z),c.push(r/B),c.push(1-s/d),x+=1}}for(let t=0;t<d;t++)for(let A=0;A<B;A++){const e=l+A+y*t,n=l+A+y*(t+1),i=l+(A+1)+y*(t+1),s=l+(A+1)+y*t;r.push(e,n,s),r.push(n,i,s),S+=6}a.addGroup(I,S,C),I+=S,l+=x}h("z","y","x",-1,-1,e,A,t,s,i,0),h("z","y","x",1,-1,e,A,-t,s,i,1),h("x","z","y",1,1,t,e,A,n,s,2),h("x","z","y",1,-1,t,e,-A,n,s,3),h("x","y","z",1,-1,t,A,e,n,i,4),h("x","y","z",-1,-1,t,A,-e,n,i,5),this.setIndex(r),this.setAttribute("position",new xs(o,3)),this.setAttribute("normal",new xs(g,3)),this.setAttribute("uv",new xs(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ks(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Vs(t){const A={};for(const e in t){A[e]={};for(const n in t[e]){const i=t[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),A[e][n]=null):A[e][n]=i.clone():Array.isArray(i)?A[e][n]=i.slice():A[e][n]=i}}return A}function Ws(t){const A={};for(let e=0;e<t.length;e++){const n=Vs(t[e]);for(const t in n)A[t]=n[t]}return A}function js(t){const A=t.getRenderTarget();return null===A?t.outputColorSpace:!0===A.isXRRenderTarget?A.texture.colorSpace:pn.workingColorSpace}const Zs={clone:Vs,merge:Ws};class Xs extends as{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Vs(t.uniforms),this.uniformsGroups=function(t){const A=[];for(let e=0;e<t.length;e++)A.push(t[e].clone());return A}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const A=super.toJSON(t);A.glslVersion=this.glslVersion,A.uniforms={};for(const e in this.uniforms){const n=this.uniforms[e].value;n&&n.isTexture?A.uniforms[e]={type:"t",value:n.toJSON(t).uuid}:n&&n.isColor?A.uniforms[e]={type:"c",value:n.getHex()}:n&&n.isVector2?A.uniforms[e]={type:"v2",value:n.toArray()}:n&&n.isVector3?A.uniforms[e]={type:"v3",value:n.toArray()}:n&&n.isVector4?A.uniforms[e]={type:"v4",value:n.toArray()}:n&&n.isMatrix3?A.uniforms[e]={type:"m3",value:n.toArray()}:n&&n.isMatrix4?A.uniforms[e]={type:"m4",value:n.toArray()}:A.uniforms[e]={value:n}}Object.keys(this.defines).length>0&&(A.defines=this.defines),A.vertexShader=this.vertexShader,A.fragmentShader=this.fragmentShader,A.lights=this.lights,A.clipping=this.clipping;const e={};for(const t in this.extensions)!0===this.extensions[t]&&(e[t]=!0);return Object.keys(e).length>0&&(A.extensions=e),A}}class $s extends Ui{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new li,this.projectionMatrix=new li,this.projectionMatrixInverse=new li,this.coordinateSystem=Te}copy(t,A){return super.copy(t,A),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,A){super.updateWorldMatrix(t,A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const ta=new An,Aa=new $e,ea=new $e;class na extends $s{constructor(t=50,A=1,e=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=e,this.far=n,this.focus=10,this.aspect=A,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,A){return super.copy(t,A),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const A=.5*this.getFilmHeight()/t;this.fov=2*ze*Math.atan(A),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*qe*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*ze*Math.atan(Math.tan(.5*qe*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,A,e){ta.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),A.set(ta.x,ta.y).multiplyScalar(-t/ta.z),ta.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(ta.x,ta.y).multiplyScalar(-t/ta.z)}getViewSize(t,A){return this.getViewBounds(t,Aa,ea),A.subVectors(ea,Aa)}setViewOffset(t,A,e,n,i,s){this.aspect=t/A,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=A,this.view.offsetX=e,this.view.offsetY=n,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let A=t*Math.tan(.5*qe*this.fov)/this.zoom,e=2*A,n=this.aspect*e,i=-.5*n;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,a=s.fullHeight;i+=s.offsetX*n/t,A-=s.offsetY*e/a,n*=s.width/t,e*=s.height/a}const a=this.filmOffset;0!==a&&(i+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+n,A,A-e,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const A=super.toJSON(t);return A.object.fov=this.fov,A.object.zoom=this.zoom,A.object.near=this.near,A.object.far=this.far,A.object.focus=this.focus,A.object.aspect=this.aspect,null!==this.view&&(A.object.view=Object.assign({},this.view)),A.object.filmGauge=this.filmGauge,A.object.filmOffset=this.filmOffset,A}}const ia=-90;class sa extends Ui{constructor(t,A,e){super(),this.type="CubeCamera",this.renderTarget=e,this.coordinateSystem=null,this.activeMipmapLevel=0;const n=new na(ia,1,t,A);n.layers=this.layers,this.add(n);const i=new na(ia,1,t,A);i.layers=this.layers,this.add(i);const s=new na(ia,1,t,A);s.layers=this.layers,this.add(s);const a=new na(ia,1,t,A);a.layers=this.layers,this.add(a);const r=new na(ia,1,t,A);r.layers=this.layers,this.add(r);const o=new na(ia,1,t,A);o.layers=this.layers,this.add(o)}updateCoordinateSystem(){const t=this.coordinateSystem,A=this.children.concat(),[e,n,i,s,a,r]=A;for(const t of A)this.remove(t);if(t===Te)e.up.set(0,1,0),e.lookAt(1,0,0),n.up.set(0,1,0),n.lookAt(-1,0,0),i.up.set(0,0,-1),i.lookAt(0,1,0),s.up.set(0,0,1),s.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),r.up.set(0,1,0),r.lookAt(0,0,-1);else{if(t!==Ge)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);e.up.set(0,-1,0),e.lookAt(-1,0,0),n.up.set(0,-1,0),n.lookAt(1,0,0),i.up.set(0,0,1),i.lookAt(0,1,0),s.up.set(0,0,-1),s.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),r.up.set(0,-1,0),r.lookAt(0,0,-1)}for(const t of A)this.add(t),t.updateMatrixWorld()}update(t,A){null===this.parent&&this.updateMatrixWorld();const{renderTarget:e,activeMipmapLevel:n}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[i,s,a,r,o,g]=this.children,c=t.getRenderTarget(),l=t.getActiveCubeFace(),I=t.getActiveMipmapLevel(),h=t.xr.enabled;t.xr.enabled=!1;const u=e.texture.generateMipmaps;e.texture.generateMipmaps=!1,t.setRenderTarget(e,0,n),t.render(A,i),t.setRenderTarget(e,1,n),t.render(A,s),t.setRenderTarget(e,2,n),t.render(A,a),t.setRenderTarget(e,3,n),t.render(A,r),t.setRenderTarget(e,4,n),t.render(A,o),e.texture.generateMipmaps=u,t.setRenderTarget(e,5,n),t.render(A,g),t.setRenderTarget(c,l,I),t.xr.enabled=h,e.texture.needsPMREMUpdate=!0}}class aa extends bn{constructor(t=[],A=lt,e,n,i,s,a,r,o,g){super(t,A,e,n,i,s,a,r,o,g),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class ra extends Fn{constructor(t=1,A={}){super(t,t,A),this.isWebGLCubeRenderTarget=!0;const e={width:t,height:t,depth:1},n=[e,e,e,e,e,e];this.texture=new aa(n),this._setTextureOptions(A),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(t,A){this.texture.type=A.type,this.texture.colorSpace=A.colorSpace,this.texture.generateMipmaps=A.generateMipmaps,this.texture.minFilter=A.minFilter,this.texture.magFilter=A.magFilter;const e={tEquirect:{value:null}},n="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",i="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",s=new Ks(5,5,5),a=new Xs({name:"CubemapFromEquirect",uniforms:Vs(e),vertexShader:n,fragmentShader:i,side:B,blending:C});a.uniforms.tEquirect.value=A;const r=new zs(s,a),o=A.minFilter;return A.minFilter===Dt&&(A.minFilter=wt),new sa(1,10,this).update(t,r),A.minFilter=o,r.geometry.dispose(),r.material.dispose(),this}clear(t,A=!0,e=!0,n=!0){const i=t.getRenderTarget();for(let i=0;i<6;i++)t.setRenderTarget(this,i),t.clear(A,e,n);t.setRenderTarget(i)}}class oa extends Ui{constructor(){super(),this.isGroup=!0,this.type="Group"}}const ga={type:"move"};class ca{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new oa,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new oa,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new An,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new An),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new oa,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new An,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new An),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const A=this._hand;if(A)for(const e of t.hand.values())this._getHandJoint(A,e)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,A,e){let n=null,i=null,s=null;const a=this._targetRay,r=this._grip,o=this._hand;if(t&&"visible-blurred"!==A.session.visibilityState){if(o&&t.hand){s=!0;for(const n of t.hand.values()){const t=A.getJointPose(n,e),i=this._getHandJoint(o,n);null!==t&&(i.matrix.fromArray(t.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.matrixWorldNeedsUpdate=!0,i.jointRadius=t.radius),i.visible=null!==t}const n=o.joints["index-finger-tip"],i=o.joints["thumb-tip"],a=n.position.distanceTo(i.position),r=.02,g=.005;o.inputState.pinching&&a>r+g?(o.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!o.inputState.pinching&&a<=r-g&&(o.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==r&&t.gripSpace&&(i=A.getPose(t.gripSpace,e),null!==i&&(r.matrix.fromArray(i.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.matrixWorldNeedsUpdate=!0,i.linearVelocity?(r.hasLinearVelocity=!0,r.linearVelocity.copy(i.linearVelocity)):r.hasLinearVelocity=!1,i.angularVelocity?(r.hasAngularVelocity=!0,r.angularVelocity.copy(i.angularVelocity)):r.hasAngularVelocity=!1));null!==a&&(n=A.getPose(t.targetRaySpace,e),null===n&&null!==i&&(n=i),null!==n&&(a.matrix.fromArray(n.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,n.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(n.linearVelocity)):a.hasLinearVelocity=!1,n.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(n.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(ga)))}return null!==a&&(a.visible=null!==n),null!==r&&(r.visible=null!==i),null!==o&&(o.visible=null!==s),this}_getHandJoint(t,A){if(void 0===t.joints[A.jointName]){const e=new oa;e.matrixAutoUpdate=!1,e.visible=!1,t.joints[A.jointName]=e,t.add(e)}return t.joints[A.jointName]}}class la{constructor(t,A=25e-5){this.isFogExp2=!0,this.name="",this.color=new ns(t),this.density=A}clone(){return new la(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Ia{constructor(t,A=1,e=1e3){this.isFog=!0,this.name="",this.color=new ns(t),this.near=A,this.far=e}clone(){return new Ia(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class ha extends Ui{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new fi,this.environmentIntensity=1,this.environmentRotation=new fi,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,A){return super.copy(t,A),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const A=super.toJSON(t);return null!==this.fog&&(A.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(A.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(A.object.backgroundIntensity=this.backgroundIntensity),A.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(A.object.environmentIntensity=this.environmentIntensity),A.object.environmentRotation=this.environmentRotation.toArray(),A}}class ua{constructor(t,A){this.isInterleavedBuffer=!0,this.array=t,this.stride=A,this.count=void 0!==t?t.length/A:0,this.usage=xe,this.updateRanges=[],this.version=0,this.uuid=Oe()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,A){this.updateRanges.push({start:t,count:A})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,A,e){t*=this.stride,e*=A.stride;for(let n=0,i=this.stride;n<i;n++)this.array[t+n]=A.array[e+n];return this}set(t,A=0){return this.array.set(t,A),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Oe()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const A=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),e=new this.constructor(A,this.stride);return e.setUsage(this.usage),e}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Oe()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ba=new An;class da{constructor(t,A,e,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=A,this.offset=e,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let A=0,e=this.data.count;A<e;A++)Ba.fromBufferAttribute(this,A),Ba.applyMatrix4(t),this.setXYZ(A,Ba.x,Ba.y,Ba.z);return this}applyNormalMatrix(t){for(let A=0,e=this.count;A<e;A++)Ba.fromBufferAttribute(this,A),Ba.applyNormalMatrix(t),this.setXYZ(A,Ba.x,Ba.y,Ba.z);return this}transformDirection(t){for(let A=0,e=this.count;A<e;A++)Ba.fromBufferAttribute(this,A),Ba.transformDirection(t),this.setXYZ(A,Ba.x,Ba.y,Ba.z);return this}getComponent(t,A){let e=this.array[t*this.data.stride+this.offset+A];return this.normalized&&(e=je(e,this.array)),e}setComponent(t,A,e){return this.normalized&&(e=Ze(e,this.array)),this.data.array[t*this.data.stride+this.offset+A]=e,this}setX(t,A){return this.normalized&&(A=Ze(A,this.array)),this.data.array[t*this.data.stride+this.offset]=A,this}setY(t,A){return this.normalized&&(A=Ze(A,this.array)),this.data.array[t*this.data.stride+this.offset+1]=A,this}setZ(t,A){return this.normalized&&(A=Ze(A,this.array)),this.data.array[t*this.data.stride+this.offset+2]=A,this}setW(t,A){return this.normalized&&(A=Ze(A,this.array)),this.data.array[t*this.data.stride+this.offset+3]=A,this}getX(t){let A=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(A=je(A,this.array)),A}getY(t){let A=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(A=je(A,this.array)),A}getZ(t){let A=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(A=je(A,this.array)),A}getW(t){let A=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(A=je(A,this.array)),A}setXY(t,A,e){return t=t*this.data.stride+this.offset,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array)),this.data.array[t+0]=A,this.data.array[t+1]=e,this}setXYZ(t,A,e,n){return t=t*this.data.stride+this.offset,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array),n=Ze(n,this.array)),this.data.array[t+0]=A,this.data.array[t+1]=e,this.data.array[t+2]=n,this}setXYZW(t,A,e,n,i){return t=t*this.data.stride+this.offset,this.normalized&&(A=Ze(A,this.array),e=Ze(e,this.array),n=Ze(n,this.array),i=Ze(i,this.array)),this.data.array[t+0]=A,this.data.array[t+1]=e,this.data.array[t+2]=n,this.data.array[t+3]=i,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let A=0;A<this.count;A++){const e=A*this.data.stride+this.offset;for(let A=0;A<this.itemSize;A++)t.push(this.data.array[e+A])}return new ds(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new da(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let A=0;A<this.count;A++){const e=A*this.data.stride+this.offset;for(let A=0;A<this.itemSize;A++)t.push(this.data.array[e+A])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Ca extends as{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new ns(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let Ea;const Qa=new An,pa=new An,fa=new An,ma=new $e,ya=new $e,wa=new li,xa=new An,Sa=new An,Da=new An,va=new $e,Ma=new $e,ba=new $e;class _a extends Ui{constructor(t=new Ca){if(super(),this.isSprite=!0,this.type="Sprite",void 0===Ea){Ea=new Fs;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),A=new ua(t,5);Ea.setIndex([0,1,2,0,2,3]),Ea.setAttribute("position",new da(A,3,0,!1)),Ea.setAttribute("uv",new da(A,2,3,!1))}this.geometry=Ea,this.material=t,this.center=new $e(.5,.5),this.count=1}raycast(t,A){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),pa.setFromMatrixScale(this.matrixWorld),wa.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),fa.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&pa.multiplyScalar(-fa.z);const e=this.material.rotation;let n,i;0!==e&&(i=Math.cos(e),n=Math.sin(e));const s=this.center;Ra(xa.set(-.5,-.5,0),fa,s,pa,n,i),Ra(Sa.set(.5,-.5,0),fa,s,pa,n,i),Ra(Da.set(.5,.5,0),fa,s,pa,n,i),va.set(0,0),Ma.set(1,0),ba.set(1,1);let a=t.ray.intersectTriangle(xa,Sa,Da,!1,Qa);if(null===a&&(Ra(Sa.set(-.5,.5,0),fa,s,pa,n,i),Ma.set(0,1),a=t.ray.intersectTriangle(xa,Da,Sa,!1,Qa),null===a))return;const r=t.ray.origin.distanceTo(Qa);r<t.near||r>t.far||A.push({distance:r,point:Qa.clone(),uv:Xi.getInterpolation(Qa,xa,Sa,Da,va,Ma,ba,new $e),face:null,object:this})}copy(t,A){return super.copy(t,A),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function Ra(t,A,e,n,i,s){ma.subVectors(t,e).addScalar(.5).multiply(n),void 0!==i?(ya.x=s*ma.x-i*ma.y,ya.y=i*ma.x+s*ma.y):ya.copy(ma),t.copy(A),t.x+=ya.x,t.y+=ya.y,t.applyMatrix4(wa)}const Fa=new An,Na=new An;class ka extends Ui{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const A=t.levels;for(let t=0,e=A.length;t<e;t++){const e=A[t];this.addLevel(e.object.clone(),e.distance,e.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,A=0,e=0){A=Math.abs(A);const n=this.levels;let i;for(i=0;i<n.length&&!(A<n[i].distance);i++);return n.splice(i,0,{distance:A,hysteresis:e,object:t}),this.add(t),this}removeLevel(t){const A=this.levels;for(let e=0;e<A.length;e++)if(A[e].distance===t){const t=A.splice(e,1);return this.remove(t[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const A=this.levels;if(A.length>0){let e,n;for(e=1,n=A.length;e<n;e++){let n=A[e].distance;if(A[e].object.visible&&(n-=n*A[e].hysteresis),t<n)break}return A[e-1].object}return null}raycast(t,A){if(this.levels.length>0){Fa.setFromMatrixPosition(this.matrixWorld);const e=t.ray.origin.distanceTo(Fa);this.getObjectForDistance(e).raycast(t,A)}}update(t){const A=this.levels;if(A.length>1){Fa.setFromMatrixPosition(t.matrixWorld),Na.setFromMatrixPosition(this.matrixWorld);const e=Fa.distanceTo(Na)/t.zoom;let n,i;for(A[0].object.visible=!0,n=1,i=A.length;n<i;n++){let t=A[n].distance;if(A[n].object.visible&&(t-=t*A[n].hysteresis),!(e>=t))break;A[n-1].object.visible=!1,A[n].object.visible=!0}for(this._currentLevel=n-1;n<i;n++)A[n].object.visible=!1}}toJSON(t){const A=super.toJSON(t);!1===this.autoUpdate&&(A.object.autoUpdate=!1),A.object.levels=[];const e=this.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];A.object.levels.push({object:n.object.uuid,distance:n.distance,hysteresis:n.hysteresis})}return A}}const Ta=new An,Ga=new _n,Ua=new _n,La=new An,Ha=new li,Ya=new An,Pa=new ei,Ja=new li,qa=new ci;class za extends zs{constructor(t,A){super(t,A),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=ot,this.bindMatrix=new li,this.bindMatrixInverse=new li,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new Un),this.boundingBox.makeEmpty();const A=t.getAttribute("position");for(let t=0;t<A.count;t++)this.getVertexPosition(t,Ya),this.boundingBox.expandByPoint(Ya)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new ei),this.boundingSphere.makeEmpty();const A=t.getAttribute("position");for(let t=0;t<A.count;t++)this.getVertexPosition(t,Ya),this.boundingSphere.expandByPoint(Ya)}copy(t,A){return super.copy(t,A),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,A){const e=this.material,n=this.matrixWorld;void 0!==e&&(null===this.boundingSphere&&this.computeBoundingSphere(),Pa.copy(this.boundingSphere),Pa.applyMatrix4(n),!1!==t.ray.intersectsSphere(Pa)&&(Ja.copy(n).invert(),qa.copy(t.ray).applyMatrix4(Ja),null!==this.boundingBox&&!1===qa.intersectsBox(this.boundingBox)||this._computeIntersections(t,A,qa)))}getVertexPosition(t,A){return super.getVertexPosition(t,A),this.applyBoneTransform(t,A),A}bind(t,A){this.skeleton=t,void 0===A&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),A=this.matrixWorld),this.bindMatrix.copy(A),this.bindMatrixInverse.copy(A).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new _n,A=this.geometry.attributes.skinWeight;for(let e=0,n=A.count;e<n;e++){t.fromBufferAttribute(A,e);const n=1/t.manhattanLength();n!==1/0?t.multiplyScalar(n):t.set(1,0,0,0),A.setXYZW(e,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===ot?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===gt?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,A){const e=this.skeleton,n=this.geometry;Ga.fromBufferAttribute(n.attributes.skinIndex,t),Ua.fromBufferAttribute(n.attributes.skinWeight,t),Ta.copy(A).applyMatrix4(this.bindMatrix),A.set(0,0,0);for(let t=0;t<4;t++){const n=Ua.getComponent(t);if(0!==n){const i=Ga.getComponent(t);Ha.multiplyMatrices(e.bones[i].matrixWorld,e.boneInverses[i]),A.addScaledVector(La.copy(Ta).applyMatrix4(Ha),n)}}return A.applyMatrix4(this.bindMatrixInverse)}}class Oa extends Ui{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Ka extends bn{constructor(t=null,A=1,e=1,n,i,s,a,r,o=Qt,g=Qt,c,l){super(null,s,a,r,o,g,n,i,c,l),this.isDataTexture=!0,this.image={data:t,width:A,height:e},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Va=new li,Wa=new li;class ja{constructor(t=[],A=[]){this.uuid=Oe(),this.bones=t.slice(0),this.boneInverses=A,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,A=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===A.length)this.calculateInverses();else if(t.length!==A.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,A=this.bones.length;t<A;t++)this.boneInverses.push(new li)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,A=this.bones.length;t<A;t++){const A=new li;this.bones[t]&&A.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(A)}}pose(){for(let t=0,A=this.bones.length;t<A;t++){const A=this.bones[t];A&&A.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,A=this.bones.length;t<A;t++){const A=this.bones[t];A&&(A.parent&&A.parent.isBone?(A.matrix.copy(A.parent.matrixWorld).invert(),A.matrix.multiply(A.matrixWorld)):A.matrix.copy(A.matrixWorld),A.matrix.decompose(A.position,A.quaternion,A.scale))}}update(){const t=this.bones,A=this.boneInverses,e=this.boneMatrices,n=this.boneTexture;for(let n=0,i=t.length;n<i;n++){const i=t[n]?t[n].matrixWorld:Wa;Va.multiplyMatrices(i,A[n]),Va.toArray(e,16*n)}null!==n&&(n.needsUpdate=!0)}clone(){return new ja(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=4*Math.ceil(t/4),t=Math.max(t,4);const A=new Float32Array(t*t*4);A.set(this.boneMatrices);const e=new Ka(A,t,t,Jt,kt);return e.needsUpdate=!0,this.boneMatrices=A,this.boneTexture=e,this}getBoneByName(t){for(let A=0,e=this.bones.length;A<e;A++){const e=this.bones[A];if(e.name===t)return e}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,A){this.uuid=t.uuid;for(let e=0,n=t.bones.length;e<n;e++){const n=t.bones[e];let i=A[n];void 0===i&&(console.warn("THREE.Skeleton: No bone found with UUID:",n),i=new Oa),this.bones.push(i),this.boneInverses.push((new li).fromArray(t.boneInverses[e]))}return this.init(),this}toJSON(){const t={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const A=this.bones,e=this.boneInverses;for(let n=0,i=A.length;n<i;n++){const i=A[n];t.bones.push(i.uuid);const s=e[n];t.boneInverses.push(s.toArray())}return t}}class Za extends ds{constructor(t,A,e,n=1){super(t,A,e),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const Xa=new li,$a=new li,tr=[],Ar=new Un,er=new li,nr=new zs,ir=new ei;class sr extends zs{constructor(t,A,e){super(t,A),this.isInstancedMesh=!0,this.instanceMatrix=new Za(new Float32Array(16*e),16),this.instanceColor=null,this.morphTexture=null,this.count=e,this.boundingBox=null,this.boundingSphere=null;for(let t=0;t<e;t++)this.setMatrixAt(t,er)}computeBoundingBox(){const t=this.geometry,A=this.count;null===this.boundingBox&&(this.boundingBox=new Un),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let e=0;e<A;e++)this.getMatrixAt(e,Xa),Ar.copy(t.boundingBox).applyMatrix4(Xa),this.boundingBox.union(Ar)}computeBoundingSphere(){const t=this.geometry,A=this.count;null===this.boundingSphere&&(this.boundingSphere=new ei),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let e=0;e<A;e++)this.getMatrixAt(e,Xa),ir.copy(t.boundingSphere).applyMatrix4(Xa),this.boundingSphere.union(ir)}copy(t,A){return super.copy(t,A),this.instanceMatrix.copy(t.instanceMatrix),null!==t.morphTexture&&(this.morphTexture=t.morphTexture.clone()),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,A){A.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,A){A.fromArray(this.instanceMatrix.array,16*t)}getMorphAt(t,A){const e=A.morphTargetInfluences,n=this.morphTexture.source.data.data,i=t*(e.length+1)+1;for(let t=0;t<e.length;t++)e[t]=n[i+t]}raycast(t,A){const e=this.matrixWorld,n=this.count;if(nr.geometry=this.geometry,nr.material=this.material,void 0!==nr.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),ir.copy(this.boundingSphere),ir.applyMatrix4(e),!1!==t.ray.intersectsSphere(ir)))for(let i=0;i<n;i++){this.getMatrixAt(i,Xa),$a.multiplyMatrices(e,Xa),nr.matrixWorld=$a,nr.raycast(t,tr);for(let t=0,e=tr.length;t<e;t++){const e=tr[t];e.instanceId=i,e.object=this,A.push(e)}tr.length=0}}setColorAt(t,A){null===this.instanceColor&&(this.instanceColor=new Za(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),A.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,A){A.toArray(this.instanceMatrix.array,16*t)}setMorphAt(t,A){const e=A.morphTargetInfluences,n=e.length+1;null===this.morphTexture&&(this.morphTexture=new Ka(new Float32Array(n*this.count),n,this.count,Ot,kt));const i=this.morphTexture.source.data.data;let s=0;for(let t=0;t<e.length;t++)s+=e[t];const a=this.geometry.morphTargetsRelative?1:1-s,r=n*t;i[r]=a,i.set(e,r+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null)}}const ar=new An,rr=new An,or=new sn;class gr{constructor(t=new An(1,0,0),A=0){this.isPlane=!0,this.normal=t,this.constant=A}set(t,A){return this.normal.copy(t),this.constant=A,this}setComponents(t,A,e,n){return this.normal.set(t,A,e),this.constant=n,this}setFromNormalAndCoplanarPoint(t,A){return this.normal.copy(t),this.constant=-A.dot(this.normal),this}setFromCoplanarPoints(t,A,e){const n=ar.subVectors(e,A).cross(rr.subVectors(t,A)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,A){return A.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,A){const e=t.delta(ar),n=this.normal.dot(e);if(0===n)return 0===this.distanceToPoint(t.start)?A.copy(t.start):null;const i=-(t.start.dot(this.normal)+this.constant)/n;return i<0||i>1?null:A.copy(t.start).addScaledVector(e,i)}intersectsLine(t){const A=this.distanceToPoint(t.start),e=this.distanceToPoint(t.end);return A<0&&e>0||e<0&&A>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,A){const e=A||or.getNormalMatrix(t),n=this.coplanarPoint(ar).applyMatrix4(t),i=this.normal.applyMatrix3(e).normalize();return this.constant=-n.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const cr=new ei,lr=new $e(.5,.5),Ir=new An;class hr{constructor(t=new gr,A=new gr,e=new gr,n=new gr,i=new gr,s=new gr){this.planes=[t,A,e,n,i,s]}set(t,A,e,n,i,s){const a=this.planes;return a[0].copy(t),a[1].copy(A),a[2].copy(e),a[3].copy(n),a[4].copy(i),a[5].copy(s),this}copy(t){const A=this.planes;for(let e=0;e<6;e++)A[e].copy(t.planes[e]);return this}setFromProjectionMatrix(t,A=Te){const e=this.planes,n=t.elements,i=n[0],s=n[1],a=n[2],r=n[3],o=n[4],g=n[5],c=n[6],l=n[7],I=n[8],h=n[9],u=n[10],B=n[11],d=n[12],C=n[13],E=n[14],Q=n[15];if(e[0].setComponents(r-i,l-o,B-I,Q-d).normalize(),e[1].setComponents(r+i,l+o,B+I,Q+d).normalize(),e[2].setComponents(r+s,l+g,B+h,Q+C).normalize(),e[3].setComponents(r-s,l-g,B-h,Q-C).normalize(),e[4].setComponents(r-a,l-c,B-u,Q-E).normalize(),A===Te)e[5].setComponents(r+a,l+c,B+u,Q+E).normalize();else{if(A!==Ge)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+A);e[5].setComponents(a,c,u,E).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),cr.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const A=t.geometry;null===A.boundingSphere&&A.computeBoundingSphere(),cr.copy(A.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(cr)}intersectsSprite(t){cr.center.set(0,0,0);const A=lr.distanceTo(t.center);return cr.radius=.7071067811865476+A,cr.applyMatrix4(t.matrixWorld),this.intersectsSphere(cr)}intersectsSphere(t){const A=this.planes,e=t.center,n=-t.radius;for(let t=0;t<6;t++)if(A[t].distanceToPoint(e)<n)return!1;return!0}intersectsBox(t){const A=this.planes;for(let e=0;e<6;e++){const n=A[e];if(Ir.x=n.normal.x>0?t.max.x:t.min.x,Ir.y=n.normal.y>0?t.max.y:t.min.y,Ir.z=n.normal.z>0?t.max.z:t.min.z,n.distanceToPoint(Ir)<0)return!1}return!0}containsPoint(t){const A=this.planes;for(let e=0;e<6;e++)if(A[e].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}const ur=new li,Br=new hr;class dr{constructor(){this.coordinateSystem=Te}intersectsObject(t,A){if(!A.isArrayCamera||0===A.cameras.length)return!1;for(let e=0;e<A.cameras.length;e++){const n=A.cameras[e];if(ur.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Br.setFromProjectionMatrix(ur,this.coordinateSystem),Br.intersectsObject(t))return!0}return!1}intersectsSprite(t,A){if(!A||!A.cameras||0===A.cameras.length)return!1;for(let e=0;e<A.cameras.length;e++){const n=A.cameras[e];if(ur.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Br.setFromProjectionMatrix(ur,this.coordinateSystem),Br.intersectsSprite(t))return!0}return!1}intersectsSphere(t,A){if(!A||!A.cameras||0===A.cameras.length)return!1;for(let e=0;e<A.cameras.length;e++){const n=A.cameras[e];if(ur.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Br.setFromProjectionMatrix(ur,this.coordinateSystem),Br.intersectsSphere(t))return!0}return!1}intersectsBox(t,A){if(!A||!A.cameras||0===A.cameras.length)return!1;for(let e=0;e<A.cameras.length;e++){const n=A.cameras[e];if(ur.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Br.setFromProjectionMatrix(ur,this.coordinateSystem),Br.intersectsBox(t))return!0}return!1}containsPoint(t,A){if(!A||!A.cameras||0===A.cameras.length)return!1;for(let e=0;e<A.cameras.length;e++){const n=A.cameras[e];if(ur.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Br.setFromProjectionMatrix(ur,this.coordinateSystem),Br.containsPoint(t))return!0}return!1}clone(){return new dr}}function Cr(t,A){return t-A}function Er(t,A){return t.z-A.z}function Qr(t,A){return A.z-t.z}class pr{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,A,e,n){const i=this.pool,s=this.list;this.index>=i.length&&i.push({start:-1,count:-1,z:-1,index:-1});const a=i[this.index];s.push(a),this.index++,a.start=t,a.count=A,a.z=e,a.index=n}reset(){this.list.length=0,this.index=0}}const fr=new li,mr=new ns(1,1,1),yr=new hr,wr=new dr,xr=new Un,Sr=new ei,Dr=new An,vr=new An,Mr=new An,br=new pr,_r=new zs,Rr=[];function Fr(t,A,e=0){const n=A.itemSize;if(t.isInterleavedBufferAttribute||t.array.constructor!==A.array.constructor){const i=t.count;for(let s=0;s<i;s++)for(let i=0;i<n;i++)A.setComponent(s+e,i,t.getComponent(s,i))}else A.array.set(t.array,e*n);A.needsUpdate=!0}function Nr(t,A){if(t.constructor!==A.constructor){const e=Math.min(t.length,A.length);for(let n=0;n<e;n++)A[n]=t[n]}else{const e=Math.min(t.length,A.length);A.set(new t.constructor(t.buffer,0,e))}}class kr extends zs{constructor(t,A,e=2*A,n){super(new Fs,n),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=t,this._maxVertexCount=A,this._maxIndexCount=e,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let t=Math.sqrt(4*this._maxInstanceCount);t=4*Math.ceil(t/4),t=Math.max(t,4);const A=new Float32Array(t*t*4),e=new Ka(A,t,t,Jt,kt);this._matricesTexture=e}_initIndirectTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const A=new Uint32Array(t*t),e=new Ka(A,t,t,Kt,Nt);this._indirectTexture=e}_initColorsTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const A=new Float32Array(t*t*4).fill(1),e=new Ka(A,t,t,Jt,kt);e.colorSpace=pn.workingColorSpace,this._colorsTexture=e}_initializeGeometry(t){const A=this.geometry,e=this._maxVertexCount,n=this._maxIndexCount;if(!1===this._geometryInitialized){for(const n in t.attributes){const i=t.getAttribute(n),{array:s,itemSize:a,normalized:r}=i,o=new s.constructor(e*a),g=new ds(o,a,r);A.setAttribute(n,g)}if(null!==t.getIndex()){const t=e>65535?new Uint32Array(n):new Uint16Array(n);A.setIndex(new ds(t,1))}this._geometryInitialized=!0}}_validateGeometry(t){const A=this.geometry;if(Boolean(t.getIndex())!==Boolean(A.getIndex()))throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const e in A.attributes){if(!t.hasAttribute(e))throw new Error(`THREE.BatchedMesh: Added geometry missing "${e}". All geometries must have consistent attributes.`);const n=t.getAttribute(e),i=A.getAttribute(e);if(n.itemSize!==i.itemSize||n.normalized!==i.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(t){const A=this._instanceInfo;if(t<0||t>=A.length||!1===A[t].active)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`)}validateGeometryId(t){const A=this._geometryInfo;if(t<0||t>=A.length||!1===A[t].active)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`)}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Un);const t=this.boundingBox,A=this._instanceInfo;t.makeEmpty();for(let e=0,n=A.length;e<n;e++){if(!1===A[e].active)continue;const n=A[e].geometryIndex;this.getMatrixAt(e,fr),this.getBoundingBoxAt(n,xr).applyMatrix4(fr),t.union(xr)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new ei);const t=this.boundingSphere,A=this._instanceInfo;t.makeEmpty();for(let e=0,n=A.length;e<n;e++){if(!1===A[e].active)continue;const n=A[e].geometryIndex;this.getMatrixAt(e,fr),this.getBoundingSphereAt(n,Sr).applyMatrix4(fr),t.union(Sr)}}addInstance(t){if(this._instanceInfo.length>=this.maxInstanceCount&&0===this._availableInstanceIds.length)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const A={visible:!0,active:!0,geometryIndex:t};let e=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(Cr),e=this._availableInstanceIds.shift(),this._instanceInfo[e]=A):(e=this._instanceInfo.length,this._instanceInfo.push(A));const n=this._matricesTexture;fr.identity().toArray(n.image.data,16*e),n.needsUpdate=!0;const i=this._colorsTexture;return i&&(mr.toArray(i.image.data,4*e),i.needsUpdate=!0),this._visibilityChanged=!0,e}addGeometry(t,A=-1,e=-1){this._initializeGeometry(t),this._validateGeometry(t);const n={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},i=this._geometryInfo;n.vertexStart=this._nextVertexStart,n.reservedVertexCount=-1===A?t.getAttribute("position").count:A;const s=t.getIndex();if(null!==s&&(n.indexStart=this._nextIndexStart,n.reservedIndexCount=-1===e?s.count:e),-1!==n.indexStart&&n.indexStart+n.reservedIndexCount>this._maxIndexCount||n.vertexStart+n.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let a;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(Cr),a=this._availableGeometryIds.shift(),i[a]=n):(a=this._geometryCount,this._geometryCount++,i.push(n)),this.setGeometryAt(a,t),this._nextIndexStart=n.indexStart+n.reservedIndexCount,this._nextVertexStart=n.vertexStart+n.reservedVertexCount,a}setGeometryAt(t,A){if(t>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(A);const e=this.geometry,n=null!==e.getIndex(),i=e.getIndex(),s=A.getIndex(),a=this._geometryInfo[t];if(n&&s.count>a.reservedIndexCount||A.attributes.position.count>a.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const r=a.vertexStart,o=a.reservedVertexCount;a.vertexCount=A.getAttribute("position").count;for(const t in e.attributes){const n=A.getAttribute(t),i=e.getAttribute(t);Fr(n,i,r);const s=n.itemSize;for(let t=n.count,A=o;t<A;t++){const A=r+t;for(let t=0;t<s;t++)i.setComponent(A,t,0)}i.needsUpdate=!0,i.addUpdateRange(r*s,o*s)}if(n){const t=a.indexStart,e=a.reservedIndexCount;a.indexCount=A.getIndex().count;for(let A=0;A<s.count;A++)i.setX(t+A,r+s.getX(A));for(let A=s.count,n=e;A<n;A++)i.setX(t+A,r);i.needsUpdate=!0,i.addUpdateRange(t,a.reservedIndexCount)}return a.start=n?a.indexStart:a.vertexStart,a.count=n?a.indexCount:a.vertexCount,a.boundingBox=null,null!==A.boundingBox&&(a.boundingBox=A.boundingBox.clone()),a.boundingSphere=null,null!==A.boundingSphere&&(a.boundingSphere=A.boundingSphere.clone()),this._visibilityChanged=!0,t}deleteGeometry(t){const A=this._geometryInfo;if(t>=A.length||!1===A[t].active)return this;const e=this._instanceInfo;for(let A=0,n=e.length;A<n;A++)e[A].active&&e[A].geometryIndex===t&&this.deleteInstance(A);return A[t].active=!1,this._availableGeometryIds.push(t),this._visibilityChanged=!0,this}deleteInstance(t){return this.validateInstanceId(t),this._instanceInfo[t].active=!1,this._availableInstanceIds.push(t),this._visibilityChanged=!0,this}optimize(){let t=0,A=0;const e=this._geometryInfo,n=e.map((t,A)=>A).sort((t,A)=>e[t].vertexStart-e[A].vertexStart),i=this.geometry;for(let s=0,a=e.length;s<a;s++){const a=n[s],r=e[a];if(!1!==r.active){if(null!==i.index){if(r.indexStart!==A){const{indexStart:e,vertexStart:n,reservedIndexCount:s}=r,a=i.index,o=a.array,g=t-n;for(let t=e;t<e+s;t++)o[t]=o[t]+g;a.array.copyWithin(A,e,e+s),a.addUpdateRange(A,s),r.indexStart=A}A+=r.reservedIndexCount}if(r.vertexStart!==t){const{vertexStart:A,reservedVertexCount:e}=r,n=i.attributes;for(const i in n){const s=n[i],{array:a,itemSize:r}=s;a.copyWithin(t*r,A*r,(A+e)*r),s.addUpdateRange(t*r,e*r)}r.vertexStart=t}t+=r.reservedVertexCount,r.start=i.index?r.indexStart:r.vertexStart,this._nextIndexStart=i.index?r.indexStart+r.reservedIndexCount:0,this._nextVertexStart=r.vertexStart+r.reservedVertexCount}}return this}getBoundingBoxAt(t,A){if(t>=this._geometryCount)return null;const e=this.geometry,n=this._geometryInfo[t];if(null===n.boundingBox){const t=new Un,A=e.index,i=e.attributes.position;for(let e=n.start,s=n.start+n.count;e<s;e++){let n=e;A&&(n=A.getX(n)),t.expandByPoint(Dr.fromBufferAttribute(i,n))}n.boundingBox=t}return A.copy(n.boundingBox),A}getBoundingSphereAt(t,A){if(t>=this._geometryCount)return null;const e=this.geometry,n=this._geometryInfo[t];if(null===n.boundingSphere){const A=new ei;this.getBoundingBoxAt(t,xr),xr.getCenter(A.center);const i=e.index,s=e.attributes.position;let a=0;for(let t=n.start,e=n.start+n.count;t<e;t++){let e=t;i&&(e=i.getX(e)),Dr.fromBufferAttribute(s,e),a=Math.max(a,A.center.distanceToSquared(Dr))}A.radius=Math.sqrt(a),n.boundingSphere=A}return A.copy(n.boundingSphere),A}setMatrixAt(t,A){this.validateInstanceId(t);const e=this._matricesTexture,n=this._matricesTexture.image.data;return A.toArray(n,16*t),e.needsUpdate=!0,this}getMatrixAt(t,A){return this.validateInstanceId(t),A.fromArray(this._matricesTexture.image.data,16*t)}setColorAt(t,A){return this.validateInstanceId(t),null===this._colorsTexture&&this._initColorsTexture(),A.toArray(this._colorsTexture.image.data,4*t),this._colorsTexture.needsUpdate=!0,this}getColorAt(t,A){return this.validateInstanceId(t),A.fromArray(this._colorsTexture.image.data,4*t)}setVisibleAt(t,A){return this.validateInstanceId(t),this._instanceInfo[t].visible===A||(this._instanceInfo[t].visible=A,this._visibilityChanged=!0),this}getVisibleAt(t){return this.validateInstanceId(t),this._instanceInfo[t].visible}setGeometryIdAt(t,A){return this.validateInstanceId(t),this.validateGeometryId(A),this._instanceInfo[t].geometryIndex=A,this}getGeometryIdAt(t){return this.validateInstanceId(t),this._instanceInfo[t].geometryIndex}getGeometryRangeAt(t,A={}){this.validateGeometryId(t);const e=this._geometryInfo[t];return A.vertexStart=e.vertexStart,A.vertexCount=e.vertexCount,A.reservedVertexCount=e.reservedVertexCount,A.indexStart=e.indexStart,A.indexCount=e.indexCount,A.reservedIndexCount=e.reservedIndexCount,A.start=e.start,A.count=e.count,A}setInstanceCount(t){const A=this._availableInstanceIds,e=this._instanceInfo;for(A.sort(Cr);A[A.length-1]===e.length;)e.pop(),A.pop();if(t<e.length)throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);const n=new Int32Array(t),i=new Int32Array(t);Nr(this._multiDrawCounts,n),Nr(this._multiDrawStarts,i),this._multiDrawCounts=n,this._multiDrawStarts=i,this._maxInstanceCount=t;const s=this._indirectTexture,a=this._matricesTexture,r=this._colorsTexture;s.dispose(),this._initIndirectTexture(),Nr(s.image.data,this._indirectTexture.image.data),a.dispose(),this._initMatricesTexture(),Nr(a.image.data,this._matricesTexture.image.data),r&&(r.dispose(),this._initColorsTexture(),Nr(r.image.data,this._colorsTexture.image.data))}setGeometrySize(t,A){const e=[...this._geometryInfo].filter(t=>t.active);if(Math.max(...e.map(t=>t.vertexStart+t.reservedVertexCount))>t)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${A}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...e.map(t=>t.indexStart+t.reservedIndexCount))>A)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${A}. Cannot shrink further.`);const n=this.geometry;n.dispose(),this._maxVertexCount=t,this._maxIndexCount=A,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new Fs,this._initializeGeometry(n));const i=this.geometry;n.index&&Nr(n.index.array,i.index.array);for(const t in n.attributes)Nr(n.attributes[t].array,i.attributes[t].array)}raycast(t,A){const e=this._instanceInfo,n=this._geometryInfo,i=this.matrixWorld,s=this.geometry;_r.material=this.material,_r.geometry.index=s.index,_r.geometry.attributes=s.attributes,null===_r.geometry.boundingBox&&(_r.geometry.boundingBox=new Un),null===_r.geometry.boundingSphere&&(_r.geometry.boundingSphere=new ei);for(let s=0,a=e.length;s<a;s++){if(!e[s].visible||!e[s].active)continue;const a=e[s].geometryIndex,r=n[a];_r.geometry.setDrawRange(r.start,r.count),this.getMatrixAt(s,_r.matrixWorld).premultiply(i),this.getBoundingBoxAt(a,_r.geometry.boundingBox),this.getBoundingSphereAt(a,_r.geometry.boundingSphere),_r.raycast(t,Rr);for(let t=0,e=Rr.length;t<e;t++){const e=Rr[t];e.object=this,e.batchId=s,A.push(e)}Rr.length=0}_r.material=null,_r.geometry.index=null,_r.geometry.attributes={},_r.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=null!==t.boundingBox?t.boundingBox.clone():null,this.boundingSphere=null!==t.boundingSphere?t.boundingSphere.clone():null,this._geometryInfo=t._geometryInfo.map(t=>({...t,boundingBox:null!==t.boundingBox?t.boundingBox.clone():null,boundingSphere:null!==t.boundingSphere?t.boundingSphere.clone():null})),this._instanceInfo=t._instanceInfo.map(t=>({...t})),this._availableInstanceIds=t._availableInstanceIds.slice(),this._availableGeometryIds=t._availableGeometryIds.slice(),this._nextIndexStart=t._nextIndexStart,this._nextVertexStart=t._nextVertexStart,this._geometryCount=t._geometryCount,this._maxInstanceCount=t._maxInstanceCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._indirectTexture=t._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),null!==this._colorsTexture&&(this._colorsTexture=t._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,null!==this._colorsTexture&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(t,A,e,n,i){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const s=n.getIndex(),a=null===s?1:s.array.BYTES_PER_ELEMENT,r=this._instanceInfo,o=this._multiDrawStarts,g=this._multiDrawCounts,c=this._geometryInfo,l=this.perObjectFrustumCulled,I=this._indirectTexture,h=I.image.data,u=e.isArrayCamera?wr:yr;l&&!e.isArrayCamera&&(fr.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse).multiply(this.matrixWorld),yr.setFromProjectionMatrix(fr,t.coordinateSystem));let B=0;if(this.sortObjects){fr.copy(this.matrixWorld).invert(),Dr.setFromMatrixPosition(e.matrixWorld).applyMatrix4(fr),vr.set(0,0,-1).transformDirection(e.matrixWorld).transformDirection(fr);for(let t=0,A=r.length;t<A;t++)if(r[t].visible&&r[t].active){const A=r[t].geometryIndex;this.getMatrixAt(t,fr),this.getBoundingSphereAt(A,Sr).applyMatrix4(fr);let n=!1;if(l&&(n=!u.intersectsSphere(Sr,e)),!n){const e=c[A],n=Mr.subVectors(Sr.center,Dr).dot(vr);br.push(e.start,e.count,n,t)}}const t=br.list,A=this.customSort;null===A?t.sort(i.transparent?Qr:Er):A.call(this,t,e);for(let A=0,e=t.length;A<e;A++){const e=t[A];o[B]=e.start*a,g[B]=e.count,h[B]=e.index,B++}br.reset()}else for(let t=0,A=r.length;t<A;t++)if(r[t].visible&&r[t].active){const A=r[t].geometryIndex;let n=!1;if(l&&(this.getMatrixAt(t,fr),this.getBoundingSphereAt(A,Sr).applyMatrix4(fr),n=!u.intersectsSphere(Sr,e)),!n){const e=c[A];o[B]=e.start*a,g[B]=e.count,h[B]=t,B++}}I.needsUpdate=!0,this._multiDrawCount=B,this._visibilityChanged=!1}onBeforeShadow(t,A,e,n,i,s){this.onBeforeRender(t,null,n,i,s)}}class Tr extends as{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new ns(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const Gr=new An,Ur=new An,Lr=new li,Hr=new ci,Yr=new ei,Pr=new An,Jr=new An;class qr extends Ui{constructor(t=new Fs,A=new Tr){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=A,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,A){return super.copy(t,A),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const A=t.attributes.position,e=[0];for(let t=1,n=A.count;t<n;t++)Gr.fromBufferAttribute(A,t-1),Ur.fromBufferAttribute(A,t),e[t]=e[t-1],e[t]+=Gr.distanceTo(Ur);t.setAttribute("lineDistance",new xs(e,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,A){const e=this.geometry,n=this.matrixWorld,i=t.params.Line.threshold,s=e.drawRange;if(null===e.boundingSphere&&e.computeBoundingSphere(),Yr.copy(e.boundingSphere),Yr.applyMatrix4(n),Yr.radius+=i,!1===t.ray.intersectsSphere(Yr))return;Lr.copy(n).invert(),Hr.copy(t.ray).applyMatrix4(Lr);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),r=a*a,o=this.isLineSegments?2:1,g=e.index,c=e.attributes.position;if(null!==g){const e=Math.max(0,s.start),n=Math.min(g.count,s.start+s.count);for(let i=e,s=n-1;i<s;i+=o){const e=g.getX(i),n=g.getX(i+1),s=zr(this,t,Hr,r,e,n,i);s&&A.push(s)}if(this.isLineLoop){const i=g.getX(n-1),s=g.getX(e),a=zr(this,t,Hr,r,i,s,n-1);a&&A.push(a)}}else{const e=Math.max(0,s.start),n=Math.min(c.count,s.start+s.count);for(let i=e,s=n-1;i<s;i+=o){const e=zr(this,t,Hr,r,i,i+1,i);e&&A.push(e)}if(this.isLineLoop){const i=zr(this,t,Hr,r,n-1,e,n-1);i&&A.push(i)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,A=Object.keys(t);if(A.length>0){const e=t[A[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,A=e.length;t<A;t++){const A=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[A]=t}}}}}function zr(t,A,e,n,i,s,a){const r=t.geometry.attributes.position;if(Gr.fromBufferAttribute(r,i),Ur.fromBufferAttribute(r,s),e.distanceSqToSegment(Gr,Ur,Pr,Jr)>n)return;Pr.applyMatrix4(t.matrixWorld);const o=A.ray.origin.distanceTo(Pr);return o<A.near||o>A.far?void 0:{distance:o,point:Jr.clone().applyMatrix4(t.matrixWorld),index:a,face:null,faceIndex:null,barycoord:null,object:t}}const Or=new An,Kr=new An;class Vr extends qr{constructor(t,A){super(t,A),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const A=t.attributes.position,e=[];for(let t=0,n=A.count;t<n;t+=2)Or.fromBufferAttribute(A,t),Kr.fromBufferAttribute(A,t+1),e[t]=0===t?0:e[t-1],e[t+1]=e[t]+Or.distanceTo(Kr);t.setAttribute("lineDistance",new xs(e,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Wr extends qr{constructor(t,A){super(t,A),this.isLineLoop=!0,this.type="LineLoop"}}class jr extends as{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new ns(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Zr=new li,Xr=new ci,$r=new ei,to=new An;class Ao extends Ui{constructor(t=new Fs,A=new jr){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=A,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,A){return super.copy(t,A),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,A){const e=this.geometry,n=this.matrixWorld,i=t.params.Points.threshold,s=e.drawRange;if(null===e.boundingSphere&&e.computeBoundingSphere(),$r.copy(e.boundingSphere),$r.applyMatrix4(n),$r.radius+=i,!1===t.ray.intersectsSphere($r))return;Zr.copy(n).invert(),Xr.copy(t.ray).applyMatrix4(Zr);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),r=a*a,o=e.index,g=e.attributes.position;if(null!==o)for(let e=Math.max(0,s.start),i=Math.min(o.count,s.start+s.count);e<i;e++){const i=o.getX(e);to.fromBufferAttribute(g,i),eo(to,i,r,n,t,A,this)}else for(let e=Math.max(0,s.start),i=Math.min(g.count,s.start+s.count);e<i;e++)to.fromBufferAttribute(g,e),eo(to,e,r,n,t,A,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,A=Object.keys(t);if(A.length>0){const e=t[A[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,A=e.length;t<A;t++){const A=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[A]=t}}}}}function eo(t,A,e,n,i,s,a){const r=Xr.distanceSqToPoint(t);if(r<e){const e=new An;Xr.closestPointToPoint(t,e),e.applyMatrix4(n);const o=i.ray.origin.distanceTo(e);if(o<i.near||o>i.far)return;s.push({distance:o,distanceToRay:Math.sqrt(r),point:e,index:A,face:null,faceIndex:null,barycoord:null,object:a})}}class no extends bn{constructor(t,A,e,n,i=wt,s=wt,a,r,o){super(t,A,e,n,i,s,a,r,o),this.isVideoTexture=!0,this.generateMipmaps=!1;const g=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(function A(){g.needsUpdate=!0,t.requestVideoFrameCallback(A)})}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class io extends no{constructor(t,A,e,n,i,s,a,r){super({},t,A,e,n,i,s,a,r),this.isVideoFrameTexture=!0}update(){}clone(){return(new this.constructor).copy(this)}setFrame(t){this.image=t,this.needsUpdate=!0}}class so extends bn{constructor(t,A){super({width:t,height:A}),this.isFramebufferTexture=!0,this.magFilter=Qt,this.minFilter=Qt,this.generateMipmaps=!1,this.needsUpdate=!0}}class ao extends bn{constructor(t,A,e,n,i,s,a,r,o,g,c,l){super(null,s,a,r,o,g,n,i,c,l),this.isCompressedTexture=!0,this.image={width:A,height:e},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class ro extends ao{constructor(t,A,e,n,i,s){super(t,A,e,i,s),this.isCompressedArrayTexture=!0,this.image.depth=n,this.wrapR=Ct,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class oo extends ao{constructor(t,A,e){super(void 0,t[0].width,t[0].height,A,e,lt),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=t}}class go extends bn{constructor(t,A,e,n,i,s,a,r,o){super(t,A,e,n,i,s,a,r,o),this.isCanvasTexture=!0,this.needsUpdate=!0}}class co extends bn{constructor(t,A,e=Nt,n,i,s,a=Qt,r=Qt,o,g=qt,c=1){if(g!==qt&&g!==zt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super({width:t,height:A,depth:c},n,i,s,a,r,g,e,o),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.source=new Sn(Object.assign({},t.image)),this.compareFunction=t.compareFunction,this}toJSON(t){const A=super.toJSON(t);return null!==this.compareFunction&&(A.compareFunction=this.compareFunction),A}}class lo extends Fs{constructor(t=1,A=1,e=4,n=8,i=1){super(),this.type="CapsuleGeometry",this.parameters={radius:t,height:A,capSegments:e,radialSegments:n,heightSegments:i},A=Math.max(0,A),e=Math.max(1,Math.floor(e)),n=Math.max(3,Math.floor(n)),i=Math.max(1,Math.floor(i));const s=[],a=[],r=[],o=[],g=A/2,c=Math.PI/2*t,l=A,I=2*c+l,h=2*e+i,u=n+1,B=new An,d=new An;for(let C=0;C<=h;C++){let E=0,Q=0,p=0,f=0;if(C<=e){const A=C/e,n=A*Math.PI/2;Q=-g-t*Math.cos(n),p=t*Math.sin(n),f=-t*Math.cos(n),E=A*c}else if(C<=e+i){const n=(C-e)/i;Q=n*A-g,p=t,f=0,E=c+n*l}else{const A=(C-e-i)/e,n=A*Math.PI/2;Q=g+t*Math.sin(n),p=t*Math.cos(n),f=t*Math.sin(n),E=c+l+A*c}const m=Math.max(0,Math.min(1,E/I));let y=0;0===C?y=.5/n:C===h&&(y=-.5/n);for(let t=0;t<=n;t++){const A=t/n,e=A*Math.PI*2,i=Math.sin(e),s=Math.cos(e);d.x=-p*s,d.y=Q,d.z=p*i,a.push(d.x,d.y,d.z),B.set(-p*s,f,p*i),B.normalize(),r.push(B.x,B.y,B.z),o.push(A+y,m)}if(C>0){const t=(C-1)*u;for(let A=0;A<n;A++){const e=t+A,n=t+A+1,i=C*u+A,a=C*u+A+1;s.push(e,n,i),s.push(n,a,i)}}}this.setIndex(s),this.setAttribute("position",new xs(a,3)),this.setAttribute("normal",new xs(r,3)),this.setAttribute("uv",new xs(o,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new lo(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)}}class Io extends Fs{constructor(t=1,A=32,e=0,n=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:A,thetaStart:e,thetaLength:n},A=Math.max(3,A);const i=[],s=[],a=[],r=[],o=new An,g=new $e;s.push(0,0,0),a.push(0,0,1),r.push(.5,.5);for(let i=0,c=3;i<=A;i++,c+=3){const l=e+i/A*n;o.x=t*Math.cos(l),o.y=t*Math.sin(l),s.push(o.x,o.y,o.z),a.push(0,0,1),g.x=(s[c]/t+1)/2,g.y=(s[c+1]/t+1)/2,r.push(g.x,g.y)}for(let t=1;t<=A;t++)i.push(t,t+1,0);this.setIndex(i),this.setAttribute("position",new xs(s,3)),this.setAttribute("normal",new xs(a,3)),this.setAttribute("uv",new xs(r,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Io(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class ho extends Fs{constructor(t=1,A=1,e=1,n=32,i=1,s=!1,a=0,r=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:A,height:e,radialSegments:n,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:r};const o=this;n=Math.floor(n),i=Math.floor(i);const g=[],c=[],l=[],I=[];let h=0;const u=[],B=e/2;let d=0;function C(e){const i=h,s=new $e,u=new An;let C=0;const E=!0===e?t:A,Q=!0===e?1:-1;for(let t=1;t<=n;t++)c.push(0,B*Q,0),l.push(0,Q,0),I.push(.5,.5),h++;const p=h;for(let t=0;t<=n;t++){const A=t/n*r+a,e=Math.cos(A),i=Math.sin(A);u.x=E*i,u.y=B*Q,u.z=E*e,c.push(u.x,u.y,u.z),l.push(0,Q,0),s.x=.5*e+.5,s.y=.5*i*Q+.5,I.push(s.x,s.y),h++}for(let t=0;t<n;t++){const A=i+t,n=p+t;!0===e?g.push(n,n+1,A):g.push(n+1,n,A),C+=3}o.addGroup(d,C,!0===e?1:2),d+=C}!function(){const s=new An,C=new An;let E=0;const Q=(A-t)/e;for(let o=0;o<=i;o++){const g=[],d=o/i,E=d*(A-t)+t;for(let t=0;t<=n;t++){const A=t/n,i=A*r+a,o=Math.sin(i),u=Math.cos(i);C.x=E*o,C.y=-d*e+B,C.z=E*u,c.push(C.x,C.y,C.z),s.set(o,Q,u).normalize(),l.push(s.x,s.y,s.z),I.push(A,1-d),g.push(h++)}u.push(g)}for(let e=0;e<n;e++)for(let n=0;n<i;n++){const s=u[n][e],a=u[n+1][e],r=u[n+1][e+1],o=u[n][e+1];(t>0||0!==n)&&(g.push(s,a,o),E+=3),(A>0||n!==i-1)&&(g.push(a,r,o),E+=3)}o.addGroup(d,E,0),d+=E}(),!1===s&&(t>0&&C(!0),A>0&&C(!1)),this.setIndex(g),this.setAttribute("position",new xs(c,3)),this.setAttribute("normal",new xs(l,3)),this.setAttribute("uv",new xs(I,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ho(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class uo extends ho{constructor(t=1,A=1,e=32,n=1,i=!1,s=0,a=2*Math.PI){super(0,t,A,e,n,i,s,a),this.type="ConeGeometry",this.parameters={radius:t,height:A,radialSegments:e,heightSegments:n,openEnded:i,thetaStart:s,thetaLength:a}}static fromJSON(t){return new uo(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Bo extends Fs{constructor(t=[],A=[],e=1,n=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:A,radius:e,detail:n};const i=[],s=[];function a(t,A,e,n){const i=n+1,s=[];for(let n=0;n<=i;n++){s[n]=[];const a=t.clone().lerp(e,n/i),r=A.clone().lerp(e,n/i),o=i-n;for(let t=0;t<=o;t++)s[n][t]=0===t&&n===i?a:a.clone().lerp(r,t/o)}for(let t=0;t<i;t++)for(let A=0;A<2*(i-t)-1;A++){const e=Math.floor(A/2);A%2==0?(r(s[t][e+1]),r(s[t+1][e]),r(s[t][e])):(r(s[t][e+1]),r(s[t+1][e+1]),r(s[t+1][e]))}}function r(t){i.push(t.x,t.y,t.z)}function o(A,e){const n=3*A;e.x=t[n+0],e.y=t[n+1],e.z=t[n+2]}function g(t,A,e,n){n<0&&1===t.x&&(s[A]=t.x-1),0===e.x&&0===e.z&&(s[A]=n/2/Math.PI+.5)}function c(t){return Math.atan2(t.z,-t.x)}function l(t){return Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))}!function(t){const e=new An,n=new An,i=new An;for(let s=0;s<A.length;s+=3)o(A[s+0],e),o(A[s+1],n),o(A[s+2],i),a(e,n,i,t)}(n),function(t){const A=new An;for(let e=0;e<i.length;e+=3)A.x=i[e+0],A.y=i[e+1],A.z=i[e+2],A.normalize().multiplyScalar(t),i[e+0]=A.x,i[e+1]=A.y,i[e+2]=A.z}(e),function(){const t=new An;for(let A=0;A<i.length;A+=3){t.x=i[A+0],t.y=i[A+1],t.z=i[A+2];const e=c(t)/2/Math.PI+.5,n=l(t)/Math.PI+.5;s.push(e,1-n)}(function(){const t=new An,A=new An,e=new An,n=new An,a=new $e,r=new $e,o=new $e;for(let l=0,I=0;l<i.length;l+=9,I+=6){t.set(i[l+0],i[l+1],i[l+2]),A.set(i[l+3],i[l+4],i[l+5]),e.set(i[l+6],i[l+7],i[l+8]),a.set(s[I+0],s[I+1]),r.set(s[I+2],s[I+3]),o.set(s[I+4],s[I+5]),n.copy(t).add(A).add(e).divideScalar(3);const h=c(n);g(a,I+0,t,h),g(r,I+2,A,h),g(o,I+4,e,h)}})(),function(){for(let t=0;t<s.length;t+=6){const A=s[t+0],e=s[t+2],n=s[t+4],i=Math.max(A,e,n),a=Math.min(A,e,n);i>.9&&a<.1&&(A<.2&&(s[t+0]+=1),e<.2&&(s[t+2]+=1),n<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new xs(i,3)),this.setAttribute("normal",new xs(i.slice(),3)),this.setAttribute("uv",new xs(s,2)),0===n?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Bo(t.vertices,t.indices,t.radius,t.details)}}class Co extends Bo{constructor(t=1,A=0){const e=(1+Math.sqrt(5))/2,n=1/e;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-n,-e,0,-n,e,0,n,-e,0,n,e,-n,-e,0,-n,e,0,n,-e,0,n,e,0,-e,0,-n,e,0,-n,-e,0,n,e,0,n],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,A),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:A}}static fromJSON(t){return new Co(t.radius,t.detail)}}const Eo=new An,Qo=new An,po=new An,fo=new Xi;class mo extends Fs{constructor(t=null,A=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:A},null!==t){const e=4,n=Math.pow(10,e),i=Math.cos(qe*A),s=t.getIndex(),a=t.getAttribute("position"),r=s?s.count:a.count,o=[0,0,0],g=["a","b","c"],c=new Array(3),l={},I=[];for(let t=0;t<r;t+=3){s?(o[0]=s.getX(t),o[1]=s.getX(t+1),o[2]=s.getX(t+2)):(o[0]=t,o[1]=t+1,o[2]=t+2);const{a:A,b:e,c:r}=fo;if(A.fromBufferAttribute(a,o[0]),e.fromBufferAttribute(a,o[1]),r.fromBufferAttribute(a,o[2]),fo.getNormal(po),c[0]=`${Math.round(A.x*n)},${Math.round(A.y*n)},${Math.round(A.z*n)}`,c[1]=`${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`,c[2]=`${Math.round(r.x*n)},${Math.round(r.y*n)},${Math.round(r.z*n)}`,c[0]!==c[1]&&c[1]!==c[2]&&c[2]!==c[0])for(let t=0;t<3;t++){const A=(t+1)%3,e=c[t],n=c[A],s=fo[g[t]],a=fo[g[A]],r=`${e}_${n}`,h=`${n}_${e}`;h in l&&l[h]?(po.dot(l[h].normal)<=i&&(I.push(s.x,s.y,s.z),I.push(a.x,a.y,a.z)),l[h]=null):r in l||(l[r]={index0:o[t],index1:o[A],normal:po.clone()})}}for(const t in l)if(l[t]){const{index0:A,index1:e}=l[t];Eo.fromBufferAttribute(a,A),Qo.fromBufferAttribute(a,e),I.push(Eo.x,Eo.y,Eo.z),I.push(Qo.x,Qo.y,Qo.z)}this.setAttribute("position",new xs(I,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class yo{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(t,A){const e=this.getUtoTmapping(t);return this.getPoint(e,A)}getPoints(t=5){const A=[];for(let e=0;e<=t;e++)A.push(this.getPoint(e/t));return A}getSpacedPoints(t=5){const A=[];for(let e=0;e<=t;e++)A.push(this.getPointAt(e/t));return A}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const A=[];let e,n=this.getPoint(0),i=0;A.push(0);for(let s=1;s<=t;s++)e=this.getPoint(s/t),i+=e.distanceTo(n),A.push(i),n=e;return this.cacheArcLengths=A,A}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,A=null){const e=this.getLengths();let n=0;const i=e.length;let s;s=A||t*e[i-1];let a,r=0,o=i-1;for(;r<=o;)if(n=Math.floor(r+(o-r)/2),a=e[n]-s,a<0)r=n+1;else{if(!(a>0)){o=n;break}o=n-1}if(n=o,e[n]===s)return n/(i-1);const g=e[n];return(n+(s-g)/(e[n+1]-g))/(i-1)}getTangent(t,A){const e=1e-4;let n=t-e,i=t+e;n<0&&(n=0),i>1&&(i=1);const s=this.getPoint(n),a=this.getPoint(i),r=A||(s.isVector2?new $e:new An);return r.copy(a).sub(s).normalize(),r}getTangentAt(t,A){const e=this.getUtoTmapping(t);return this.getTangent(e,A)}computeFrenetFrames(t,A=!1){const e=new An,n=[],i=[],s=[],a=new An,r=new li;for(let A=0;A<=t;A++){const e=A/t;n[A]=this.getTangentAt(e,new An)}i[0]=new An,s[0]=new An;let o=Number.MAX_VALUE;const g=Math.abs(n[0].x),c=Math.abs(n[0].y),l=Math.abs(n[0].z);g<=o&&(o=g,e.set(1,0,0)),c<=o&&(o=c,e.set(0,1,0)),l<=o&&e.set(0,0,1),a.crossVectors(n[0],e).normalize(),i[0].crossVectors(n[0],a),s[0].crossVectors(n[0],i[0]);for(let A=1;A<=t;A++){if(i[A]=i[A-1].clone(),s[A]=s[A-1].clone(),a.crossVectors(n[A-1],n[A]),a.length()>Number.EPSILON){a.normalize();const t=Math.acos(Ke(n[A-1].dot(n[A]),-1,1));i[A].applyMatrix4(r.makeRotationAxis(a,t))}s[A].crossVectors(n[A],i[A])}if(!0===A){let A=Math.acos(Ke(i[0].dot(i[t]),-1,1));A/=t,n[0].dot(a.crossVectors(i[0],i[t]))>0&&(A=-A);for(let e=1;e<=t;e++)i[e].applyMatrix4(r.makeRotationAxis(n[e],A*e)),s[e].crossVectors(n[e],i[e])}return{tangents:n,normals:i,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class wo extends yo{constructor(t=0,A=0,e=1,n=1,i=0,s=2*Math.PI,a=!1,r=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=A,this.xRadius=e,this.yRadius=n,this.aStartAngle=i,this.aEndAngle=s,this.aClockwise=a,this.aRotation=r}getPoint(t,A=new $e){const e=A,n=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const s=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=n;for(;i>n;)i-=n;i<Number.EPSILON&&(i=s?0:n),!0!==this.aClockwise||s||(i===n?i=-n:i-=n);const a=this.aStartAngle+t*i;let r=this.aX+this.xRadius*Math.cos(a),o=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const t=Math.cos(this.aRotation),A=Math.sin(this.aRotation),e=r-this.aX,n=o-this.aY;r=e*t-n*A+this.aX,o=e*A+n*t+this.aY}return e.set(r,o)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class xo extends wo{constructor(t,A,e,n,i,s){super(t,A,e,e,n,i,s),this.isArcCurve=!0,this.type="ArcCurve"}}function So(){let t=0,A=0,e=0,n=0;function i(i,s,a,r){t=i,A=a,e=-3*i+3*s-2*a-r,n=2*i-2*s+a+r}return{initCatmullRom:function(t,A,e,n,s){i(A,e,s*(e-t),s*(n-A))},initNonuniformCatmullRom:function(t,A,e,n,s,a,r){let o=(A-t)/s-(e-t)/(s+a)+(e-A)/a,g=(e-A)/a-(n-A)/(a+r)+(n-e)/r;o*=a,g*=a,i(A,e,o,g)},calc:function(i){const s=i*i;return t+A*i+e*s+n*(s*i)}}}const Do=new An,vo=new So,Mo=new So,bo=new So;class _o extends yo{constructor(t=[],A=!1,e="centripetal",n=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=A,this.curveType=e,this.tension=n}getPoint(t,A=new An){const e=A,n=this.points,i=n.length,s=(i-(this.closed?0:1))*t;let a,r,o=Math.floor(s),g=s-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/i)+1)*i:0===g&&o===i-1&&(o=i-2,g=1),this.closed||o>0?a=n[(o-1)%i]:(Do.subVectors(n[0],n[1]).add(n[0]),a=Do);const c=n[o%i],l=n[(o+1)%i];if(this.closed||o+2<i?r=n[(o+2)%i]:(Do.subVectors(n[i-1],n[i-2]).add(n[i-1]),r=Do),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let A=Math.pow(a.distanceToSquared(c),t),e=Math.pow(c.distanceToSquared(l),t),n=Math.pow(l.distanceToSquared(r),t);e<1e-4&&(e=1),A<1e-4&&(A=e),n<1e-4&&(n=e),vo.initNonuniformCatmullRom(a.x,c.x,l.x,r.x,A,e,n),Mo.initNonuniformCatmullRom(a.y,c.y,l.y,r.y,A,e,n),bo.initNonuniformCatmullRom(a.z,c.z,l.z,r.z,A,e,n)}else"catmullrom"===this.curveType&&(vo.initCatmullRom(a.x,c.x,l.x,r.x,this.tension),Mo.initCatmullRom(a.y,c.y,l.y,r.y,this.tension),bo.initCatmullRom(a.z,c.z,l.z,r.z,this.tension));return e.set(vo.calc(g),Mo.calc(g),bo.calc(g)),e}copy(t){super.copy(t),this.points=[];for(let A=0,e=t.points.length;A<e;A++){const e=t.points[A];this.points.push(e.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let A=0,e=this.points.length;A<e;A++){const e=this.points[A];t.points.push(e.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let A=0,e=t.points.length;A<e;A++){const e=t.points[A];this.points.push((new An).fromArray(e))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function Ro(t,A,e,n,i){const s=.5*(n-A),a=.5*(i-e),r=t*t;return(2*e-2*n+s+a)*(t*r)+(-3*e+3*n-2*s-a)*r+s*t+e}function Fo(t,A,e,n){return function(t,A){const e=1-t;return e*e*A}(t,A)+function(t,A){return 2*(1-t)*t*A}(t,e)+function(t,A){return t*t*A}(t,n)}function No(t,A,e,n,i){return function(t,A){const e=1-t;return e*e*e*A}(t,A)+function(t,A){const e=1-t;return 3*e*e*t*A}(t,e)+function(t,A){return 3*(1-t)*t*t*A}(t,n)+function(t,A){return t*t*t*A}(t,i)}class ko extends yo{constructor(t=new $e,A=new $e,e=new $e,n=new $e){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=A,this.v2=e,this.v3=n}getPoint(t,A=new $e){const e=A,n=this.v0,i=this.v1,s=this.v2,a=this.v3;return e.set(No(t,n.x,i.x,s.x,a.x),No(t,n.y,i.y,s.y,a.y)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class To extends yo{constructor(t=new An,A=new An,e=new An,n=new An){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=A,this.v2=e,this.v3=n}getPoint(t,A=new An){const e=A,n=this.v0,i=this.v1,s=this.v2,a=this.v3;return e.set(No(t,n.x,i.x,s.x,a.x),No(t,n.y,i.y,s.y,a.y),No(t,n.z,i.z,s.z,a.z)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Go extends yo{constructor(t=new $e,A=new $e){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=A}getPoint(t,A=new $e){const e=A;return 1===t?e.copy(this.v2):(e.copy(this.v2).sub(this.v1),e.multiplyScalar(t).add(this.v1)),e}getPointAt(t,A){return this.getPoint(t,A)}getTangent(t,A=new $e){return A.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,A){return this.getTangent(t,A)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Uo extends yo{constructor(t=new An,A=new An){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=A}getPoint(t,A=new An){const e=A;return 1===t?e.copy(this.v2):(e.copy(this.v2).sub(this.v1),e.multiplyScalar(t).add(this.v1)),e}getPointAt(t,A){return this.getPoint(t,A)}getTangent(t,A=new An){return A.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,A){return this.getTangent(t,A)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Lo extends yo{constructor(t=new $e,A=new $e,e=new $e){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=A,this.v2=e}getPoint(t,A=new $e){const e=A,n=this.v0,i=this.v1,s=this.v2;return e.set(Fo(t,n.x,i.x,s.x),Fo(t,n.y,i.y,s.y)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Ho extends yo{constructor(t=new An,A=new An,e=new An){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=A,this.v2=e}getPoint(t,A=new An){const e=A,n=this.v0,i=this.v1,s=this.v2;return e.set(Fo(t,n.x,i.x,s.x),Fo(t,n.y,i.y,s.y),Fo(t,n.z,i.z,s.z)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Yo extends yo{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,A=new $e){const e=A,n=this.points,i=(n.length-1)*t,s=Math.floor(i),a=i-s,r=n[0===s?s:s-1],o=n[s],g=n[s>n.length-2?n.length-1:s+1],c=n[s>n.length-3?n.length-1:s+2];return e.set(Ro(a,r.x,o.x,g.x,c.x),Ro(a,r.y,o.y,g.y,c.y)),e}copy(t){super.copy(t),this.points=[];for(let A=0,e=t.points.length;A<e;A++){const e=t.points[A];this.points.push(e.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let A=0,e=this.points.length;A<e;A++){const e=this.points[A];t.points.push(e.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let A=0,e=t.points.length;A<e;A++){const e=t.points[A];this.points.push((new $e).fromArray(e))}return this}}var Po=Object.freeze({__proto__:null,ArcCurve:xo,CatmullRomCurve3:_o,CubicBezierCurve:ko,CubicBezierCurve3:To,EllipseCurve:wo,LineCurve:Go,LineCurve3:Uo,QuadraticBezierCurve:Lo,QuadraticBezierCurve3:Ho,SplineCurve:Yo});class Jo extends yo{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),A=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(A)){const e=!0===t.isVector2?"LineCurve":"LineCurve3";this.curves.push(new Po[e](A,t))}return this}getPoint(t,A){const e=t*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=e){const t=n[i]-e,s=this.curves[i],a=s.getLength(),r=0===a?0:1-t/a;return s.getPointAt(r,A)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let A=0;for(let e=0,n=this.curves.length;e<n;e++)A+=this.curves[e].getLength(),t.push(A);return this.cacheLengths=t,t}getSpacedPoints(t=40){const A=[];for(let e=0;e<=t;e++)A.push(this.getPoint(e/t));return this.autoClose&&A.push(A[0]),A}getPoints(t=12){const A=[];let e;for(let n=0,i=this.curves;n<i.length;n++){const s=i[n],a=s.isEllipseCurve?2*t:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?t*s.points.length:t,r=s.getPoints(a);for(let t=0;t<r.length;t++){const n=r[t];e&&e.equals(n)||(A.push(n),e=n)}}return this.autoClose&&A.length>1&&!A[A.length-1].equals(A[0])&&A.push(A[0]),A}copy(t){super.copy(t),this.curves=[];for(let A=0,e=t.curves.length;A<e;A++){const e=t.curves[A];this.curves.push(e.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let A=0,e=this.curves.length;A<e;A++){const e=this.curves[A];t.curves.push(e.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let A=0,e=t.curves.length;A<e;A++){const e=t.curves[A];this.curves.push((new Po[e.type]).fromJSON(e))}return this}}class qo extends Jo{constructor(t){super(),this.type="Path",this.currentPoint=new $e,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let A=1,e=t.length;A<e;A++)this.lineTo(t[A].x,t[A].y);return this}moveTo(t,A){return this.currentPoint.set(t,A),this}lineTo(t,A){const e=new Go(this.currentPoint.clone(),new $e(t,A));return this.curves.push(e),this.currentPoint.set(t,A),this}quadraticCurveTo(t,A,e,n){const i=new Lo(this.currentPoint.clone(),new $e(t,A),new $e(e,n));return this.curves.push(i),this.currentPoint.set(e,n),this}bezierCurveTo(t,A,e,n,i,s){const a=new ko(this.currentPoint.clone(),new $e(t,A),new $e(e,n),new $e(i,s));return this.curves.push(a),this.currentPoint.set(i,s),this}splineThru(t){const A=[this.currentPoint.clone()].concat(t),e=new Yo(A);return this.curves.push(e),this.currentPoint.copy(t[t.length-1]),this}arc(t,A,e,n,i,s){const a=this.currentPoint.x,r=this.currentPoint.y;return this.absarc(t+a,A+r,e,n,i,s),this}absarc(t,A,e,n,i,s){return this.absellipse(t,A,e,e,n,i,s),this}ellipse(t,A,e,n,i,s,a,r){const o=this.currentPoint.x,g=this.currentPoint.y;return this.absellipse(t+o,A+g,e,n,i,s,a,r),this}absellipse(t,A,e,n,i,s,a,r){const o=new wo(t,A,e,n,i,s,a,r);if(this.curves.length>0){const t=o.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(o);const g=o.getPoint(1);return this.currentPoint.copy(g),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class zo extends qo{constructor(t){super(t),this.uuid=Oe(),this.type="Shape",this.holes=[]}getPointsHoles(t){const A=[];for(let e=0,n=this.holes.length;e<n;e++)A[e]=this.holes[e].getPoints(t);return A}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let A=0,e=t.holes.length;A<e;A++){const e=t.holes[A];this.holes.push(e.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let A=0,e=this.holes.length;A<e;A++){const e=this.holes[A];t.holes.push(e.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let A=0,e=t.holes.length;A<e;A++){const e=t.holes[A];this.holes.push((new qo).fromJSON(e))}return this}}function Oo(t,A,e,n,i){let s;if(i===function(t,A,e,n){let i=0;for(let s=A,a=e-n;s<e;s+=n)i+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return i}(t,A,e,n)>0)for(let i=A;i<e;i+=n)s=ug(i/n|0,t[i],t[i+1],s);else for(let i=e-n;i>=A;i-=n)s=ug(i/n|0,t[i],t[i+1],s);return s&&og(s,s.next)&&(Bg(s),s=s.next),s}function Ko(t,A){if(!t)return t;A||(A=t);let e,n=t;do{if(e=!1,n.steiner||!og(n,n.next)&&0!==rg(n.prev,n,n.next))n=n.next;else{if(Bg(n),n=A=n.prev,n===n.next)break;e=!0}}while(e||n!==A);return A}function Vo(t,A,e,n,i,s,a){if(!t)return;!a&&s&&function(t,A,e,n){let i=t;do{0===i.z&&(i.z=eg(i.x,i.y,A,e,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){let A,e=1;do{let n,i=t;t=null;let s=null;for(A=0;i;){A++;let a=i,r=0;for(let t=0;t<e&&(r++,a=a.nextZ,a);t++);let o=e;for(;r>0||o>0&&a;)0!==r&&(0===o||!a||i.z<=a.z)?(n=i,i=i.nextZ,r--):(n=a,a=a.nextZ,o--),s?s.nextZ=n:t=n,n.prevZ=s,s=n;i=a}s.nextZ=null,e*=2}while(A>1)}(i)}(t,n,i,s);let r=t;for(;t.prev!==t.next;){const o=t.prev,g=t.next;if(s?jo(t,n,i,s):Wo(t))A.push(o.i,t.i,g.i),Bg(t),t=g.next,r=g.next;else if((t=g)===r){a?1===a?Vo(t=Zo(Ko(t),A),A,e,n,i,s,2):2===a&&Xo(t,A,e,n,i,s):Vo(Ko(t),A,e,n,i,s,1);break}}}function Wo(t){const A=t.prev,e=t,n=t.next;if(rg(A,e,n)>=0)return!1;const i=A.x,s=e.x,a=n.x,r=A.y,o=e.y,g=n.y,c=Math.min(i,s,a),l=Math.min(r,o,g),I=Math.max(i,s,a),h=Math.max(r,o,g);let u=n.next;for(;u!==A;){if(u.x>=c&&u.x<=I&&u.y>=l&&u.y<=h&&sg(i,r,s,o,a,g,u.x,u.y)&&rg(u.prev,u,u.next)>=0)return!1;u=u.next}return!0}function jo(t,A,e,n){const i=t.prev,s=t,a=t.next;if(rg(i,s,a)>=0)return!1;const r=i.x,o=s.x,g=a.x,c=i.y,l=s.y,I=a.y,h=Math.min(r,o,g),u=Math.min(c,l,I),B=Math.max(r,o,g),d=Math.max(c,l,I),C=eg(h,u,A,e,n),E=eg(B,d,A,e,n);let Q=t.prevZ,p=t.nextZ;for(;Q&&Q.z>=C&&p&&p.z<=E;){if(Q.x>=h&&Q.x<=B&&Q.y>=u&&Q.y<=d&&Q!==i&&Q!==a&&sg(r,c,o,l,g,I,Q.x,Q.y)&&rg(Q.prev,Q,Q.next)>=0)return!1;if(Q=Q.prevZ,p.x>=h&&p.x<=B&&p.y>=u&&p.y<=d&&p!==i&&p!==a&&sg(r,c,o,l,g,I,p.x,p.y)&&rg(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(;Q&&Q.z>=C;){if(Q.x>=h&&Q.x<=B&&Q.y>=u&&Q.y<=d&&Q!==i&&Q!==a&&sg(r,c,o,l,g,I,Q.x,Q.y)&&rg(Q.prev,Q,Q.next)>=0)return!1;Q=Q.prevZ}for(;p&&p.z<=E;){if(p.x>=h&&p.x<=B&&p.y>=u&&p.y<=d&&p!==i&&p!==a&&sg(r,c,o,l,g,I,p.x,p.y)&&rg(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function Zo(t,A){let e=t;do{const n=e.prev,i=e.next.next;!og(n,i)&&gg(n,e,e.next,i)&&Ig(n,i)&&Ig(i,n)&&(A.push(n.i,e.i,i.i),Bg(e),Bg(e.next),e=t=i),e=e.next}while(e!==t);return Ko(e)}function Xo(t,A,e,n,i,s){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.i!==t.i&&ag(a,t)){let r=hg(a,t);return a=Ko(a,a.next),r=Ko(r,r.next),Vo(a,A,e,n,i,s,0),void Vo(r,A,e,n,i,s,0)}t=t.next}a=a.next}while(a!==t)}function $o(t,A){let e=t.x-A.x;return 0===e&&(e=t.y-A.y,0===e)&&(e=(t.next.y-t.y)/(t.next.x-t.x)-(A.next.y-A.y)/(A.next.x-A.x)),e}function tg(t,A){const e=function(t,A){let e=A;const n=t.x,i=t.y;let s,a=-1/0;if(og(t,e))return e;do{if(og(t,e.next))return e.next;if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const t=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(t<=n&&t>a&&(a=t,s=e.x<e.next.x?e:e.next,t===n))return s}e=e.next}while(e!==A);if(!s)return null;const r=s,o=s.x,g=s.y;let c=1/0;e=s;do{if(n>=e.x&&e.x>=o&&n!==e.x&&ig(i<g?n:a,i,o,g,i<g?a:n,i,e.x,e.y)){const A=Math.abs(i-e.y)/(n-e.x);Ig(e,t)&&(A<c||A===c&&(e.x>s.x||e.x===s.x&&Ag(s,e)))&&(s=e,c=A)}e=e.next}while(e!==r);return s}(t,A);if(!e)return A;const n=hg(e,t);return Ko(n,n.next),Ko(e,e.next)}function Ag(t,A){return rg(t.prev,t,A.prev)<0&&rg(A.next,t,t.next)<0}function eg(t,A,e,n,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-e)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))|(A=1431655765&((A=858993459&((A=252645135&((A=16711935&((A=(A-n)*i|0)|A<<8))|A<<4))|A<<2))|A<<1))<<1}function ng(t){let A=t,e=t;do{(A.x<e.x||A.x===e.x&&A.y<e.y)&&(e=A),A=A.next}while(A!==t);return e}function ig(t,A,e,n,i,s,a,r){return(i-a)*(A-r)>=(t-a)*(s-r)&&(t-a)*(n-r)>=(e-a)*(A-r)&&(e-a)*(s-r)>=(i-a)*(n-r)}function sg(t,A,e,n,i,s,a,r){return!(t===a&&A===r)&&ig(t,A,e,n,i,s,a,r)}function ag(t,A){return t.next.i!==A.i&&t.prev.i!==A.i&&!function(t,A){let e=t;do{if(e.i!==t.i&&e.next.i!==t.i&&e.i!==A.i&&e.next.i!==A.i&&gg(e,e.next,t,A))return!0;e=e.next}while(e!==t);return!1}(t,A)&&(Ig(t,A)&&Ig(A,t)&&function(t,A){let e=t,n=!1;const i=(t.x+A.x)/2,s=(t.y+A.y)/2;do{e.y>s!=e.next.y>s&&e.next.y!==e.y&&i<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next}while(e!==t);return n}(t,A)&&(rg(t.prev,t,A.prev)||rg(t,A.prev,A))||og(t,A)&&rg(t.prev,t,t.next)>0&&rg(A.prev,A,A.next)>0)}function rg(t,A,e){return(A.y-t.y)*(e.x-A.x)-(A.x-t.x)*(e.y-A.y)}function og(t,A){return t.x===A.x&&t.y===A.y}function gg(t,A,e,n){const i=lg(rg(t,A,e)),s=lg(rg(t,A,n)),a=lg(rg(e,n,t)),r=lg(rg(e,n,A));return i!==s&&a!==r||!(0!==i||!cg(t,e,A))||!(0!==s||!cg(t,n,A))||!(0!==a||!cg(e,t,n))||!(0!==r||!cg(e,A,n))}function cg(t,A,e){return A.x<=Math.max(t.x,e.x)&&A.x>=Math.min(t.x,e.x)&&A.y<=Math.max(t.y,e.y)&&A.y>=Math.min(t.y,e.y)}function lg(t){return t>0?1:t<0?-1:0}function Ig(t,A){return rg(t.prev,t,t.next)<0?rg(t,A,t.next)>=0&&rg(t,t.prev,A)>=0:rg(t,A,t.prev)<0||rg(t,t.next,A)<0}function hg(t,A){const e=dg(t.i,t.x,t.y),n=dg(A.i,A.x,A.y),i=t.next,s=A.prev;return t.next=A,A.prev=t,e.next=i,i.prev=e,n.next=e,e.prev=n,s.next=n,n.prev=s,n}function ug(t,A,e,n){const i=dg(t,A,e);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Bg(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function dg(t,A,e){return{i:t,x:A,y:e,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class Cg{static triangulate(t,A,e=2){return function(t,A,e=2){const n=A&&A.length,i=n?A[0]*e:t.length;let s=Oo(t,0,i,e,!0);const a=[];if(!s||s.next===s.prev)return a;let r,o,g;if(n&&(s=function(t,A,e,n){const i=[];for(let e=0,s=A.length;e<s;e++){const a=Oo(t,A[e]*n,e<s-1?A[e+1]*n:t.length,n,!1);a===a.next&&(a.steiner=!0),i.push(ng(a))}i.sort($o);for(let t=0;t<i.length;t++)e=tg(i[t],e);return e}(t,A,s,e)),t.length>80*e){r=1/0,o=1/0;let A=-1/0,n=-1/0;for(let s=e;s<i;s+=e){const e=t[s],i=t[s+1];e<r&&(r=e),i<o&&(o=i),e>A&&(A=e),i>n&&(n=i)}g=Math.max(A-r,n-o),g=0!==g?32767/g:0}return Vo(s,a,e,r,o,g,0),a}(t,A,e)}}class Eg{static area(t){const A=t.length;let e=0;for(let n=A-1,i=0;i<A;n=i++)e+=t[n].x*t[i].y-t[i].x*t[n].y;return.5*e}static isClockWise(t){return Eg.area(t)<0}static triangulateShape(t,A){const e=[],n=[],i=[];Qg(t),pg(e,t);let s=t.length;A.forEach(Qg);for(let t=0;t<A.length;t++)n.push(s),s+=A[t].length,pg(e,A[t]);const a=Cg.triangulate(e,n);for(let t=0;t<a.length;t+=3)i.push(a.slice(t,t+3));return i}}function Qg(t){const A=t.length;A>2&&t[A-1].equals(t[0])&&t.pop()}function pg(t,A){for(let e=0;e<A.length;e++)t.push(A[e].x),t.push(A[e].y)}class fg extends Fs{constructor(t=new zo([new $e(.5,.5),new $e(-.5,.5),new $e(-.5,-.5),new $e(.5,-.5)]),A={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:A},t=Array.isArray(t)?t:[t];const e=this,n=[],i=[];for(let A=0,e=t.length;A<e;A++)s(t[A]);function s(t){const s=[],a=void 0!==A.curveSegments?A.curveSegments:12,r=void 0!==A.steps?A.steps:1,o=void 0!==A.depth?A.depth:1;let g=void 0===A.bevelEnabled||A.bevelEnabled,c=void 0!==A.bevelThickness?A.bevelThickness:.2,l=void 0!==A.bevelSize?A.bevelSize:c-.1,I=void 0!==A.bevelOffset?A.bevelOffset:0,h=void 0!==A.bevelSegments?A.bevelSegments:3;const u=A.extrudePath,B=void 0!==A.UVGenerator?A.UVGenerator:mg;let d,C,E,Q,p,f=!1;u&&(d=u.getSpacedPoints(r),f=!0,g=!1,C=u.computeFrenetFrames(r,!1),E=new An,Q=new An,p=new An),g||(h=0,c=0,l=0,I=0);const m=t.extractPoints(a);let y=m.shape;const w=m.holes;if(!Eg.isClockWise(y)){y=y.reverse();for(let t=0,A=w.length;t<A;t++){const A=w[t];Eg.isClockWise(A)&&(w[t]=A.reverse())}}function x(t){const A=1e-10*1e-10;let e=t[0];for(let n=1;n<=t.length;n++){const i=n%t.length,s=t[i],a=s.x-e.x,r=s.y-e.y,o=a*a+r*r,g=Math.max(Math.abs(s.x),Math.abs(s.y),Math.abs(e.x),Math.abs(e.y));o<=A*g*g?(t.splice(i,1),n--):e=s}}x(y),w.forEach(x);const S=w.length,D=y;for(let t=0;t<S;t++){const A=w[t];y=y.concat(A)}function v(t,A,e){return A||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(A,e)}const M=y.length;function b(t,A,e){let n,i,s;const a=t.x-A.x,r=t.y-A.y,o=e.x-t.x,g=e.y-t.y,c=a*a+r*r,l=a*g-r*o;if(Math.abs(l)>Number.EPSILON){const l=Math.sqrt(c),I=Math.sqrt(o*o+g*g),h=A.x-r/l,u=A.y+a/l,B=((e.x-g/I-h)*g-(e.y+o/I-u)*o)/(a*g-r*o);n=h+a*B-t.x,i=u+r*B-t.y;const d=n*n+i*i;if(d<=2)return new $e(n,i);s=Math.sqrt(d/2)}else{let t=!1;a>Number.EPSILON?o>Number.EPSILON&&(t=!0):a<-Number.EPSILON?o<-Number.EPSILON&&(t=!0):Math.sign(r)===Math.sign(g)&&(t=!0),t?(n=-r,i=a,s=Math.sqrt(c)):(n=a,i=r,s=Math.sqrt(c/2))}return new $e(n/s,i/s)}const _=[];for(let t=0,A=D.length,e=A-1,n=t+1;t<A;t++,e++,n++)e===A&&(e=0),n===A&&(n=0),_[t]=b(D[t],D[e],D[n]);const R=[];let F,N,k=_.concat();for(let t=0,A=S;t<A;t++){const A=w[t];F=[];for(let t=0,e=A.length,n=e-1,i=t+1;t<e;t++,n++,i++)n===e&&(n=0),i===e&&(i=0),F[t]=b(A[t],A[n],A[i]);R.push(F),k=k.concat(F)}if(0===h)N=Eg.triangulateShape(D,w);else{const t=[],A=[];for(let e=0;e<h;e++){const n=e/h,i=c*Math.cos(n*Math.PI/2),s=l*Math.sin(n*Math.PI/2)+I;for(let A=0,e=D.length;A<e;A++){const e=v(D[A],_[A],s);L(e.x,e.y,-i),0===n&&t.push(e)}for(let t=0,e=S;t<e;t++){const e=w[t];F=R[t];const a=[];for(let t=0,A=e.length;t<A;t++){const A=v(e[t],F[t],s);L(A.x,A.y,-i),0===n&&a.push(A)}0===n&&A.push(a)}}N=Eg.triangulateShape(t,A)}const T=N.length,G=l+I;for(let t=0;t<M;t++){const A=g?v(y[t],k[t],G):y[t];f?(Q.copy(C.normals[0]).multiplyScalar(A.x),E.copy(C.binormals[0]).multiplyScalar(A.y),p.copy(d[0]).add(Q).add(E),L(p.x,p.y,p.z)):L(A.x,A.y,0)}for(let t=1;t<=r;t++)for(let A=0;A<M;A++){const e=g?v(y[A],k[A],G):y[A];f?(Q.copy(C.normals[t]).multiplyScalar(e.x),E.copy(C.binormals[t]).multiplyScalar(e.y),p.copy(d[t]).add(Q).add(E),L(p.x,p.y,p.z)):L(e.x,e.y,o/r*t)}for(let t=h-1;t>=0;t--){const A=t/h,e=c*Math.cos(A*Math.PI/2),n=l*Math.sin(A*Math.PI/2)+I;for(let t=0,A=D.length;t<A;t++){const A=v(D[t],_[t],n);L(A.x,A.y,o+e)}for(let t=0,A=w.length;t<A;t++){const A=w[t];F=R[t];for(let t=0,i=A.length;t<i;t++){const i=v(A[t],F[t],n);f?L(i.x,i.y+d[r-1].y,d[r-1].x+e):L(i.x,i.y,o+e)}}}function U(t,A){let e=t.length;for(;--e>=0;){const n=e;let i=e-1;i<0&&(i=t.length-1);for(let t=0,e=r+2*h;t<e;t++){const e=M*t,s=M*(t+1);Y(A+n+e,A+i+e,A+i+s,A+n+s)}}}function L(t,A,e){s.push(t),s.push(A),s.push(e)}function H(t,A,i){P(t),P(A),P(i);const s=n.length/3,a=B.generateTopUV(e,n,s-3,s-2,s-1);J(a[0]),J(a[1]),J(a[2])}function Y(t,A,i,s){P(t),P(A),P(s),P(A),P(i),P(s);const a=n.length/3,r=B.generateSideWallUV(e,n,a-6,a-3,a-2,a-1);J(r[0]),J(r[1]),J(r[3]),J(r[1]),J(r[2]),J(r[3])}function P(t){n.push(s[3*t+0]),n.push(s[3*t+1]),n.push(s[3*t+2])}function J(t){i.push(t.x),i.push(t.y)}!function(){const t=n.length/3;if(g){let t=0,A=M*t;for(let t=0;t<T;t++){const e=N[t];H(e[2]+A,e[1]+A,e[0]+A)}t=r+2*h,A=M*t;for(let t=0;t<T;t++){const e=N[t];H(e[0]+A,e[1]+A,e[2]+A)}}else{for(let t=0;t<T;t++){const A=N[t];H(A[2],A[1],A[0])}for(let t=0;t<T;t++){const A=N[t];H(A[0]+M*r,A[1]+M*r,A[2]+M*r)}}e.addGroup(t,n.length/3-t,0)}(),function(){const t=n.length/3;let A=0;U(D,A),A+=D.length;for(let t=0,e=w.length;t<e;t++){const e=w[t];U(e,A),A+=e.length}e.addGroup(t,n.length/3-t,1)}()}this.setAttribute("position",new xs(n,3)),this.setAttribute("uv",new xs(i,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,A,e){if(e.shapes=[],Array.isArray(t))for(let A=0,n=t.length;A<n;A++){const n=t[A];e.shapes.push(n.uuid)}else e.shapes.push(t.uuid);return e.options=Object.assign({},A),void 0!==A.extrudePath&&(e.options.extrudePath=A.extrudePath.toJSON()),e}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,A){const e=[];for(let n=0,i=t.shapes.length;n<i;n++){const i=A[t.shapes[n]];e.push(i)}const n=t.options.extrudePath;return void 0!==n&&(t.options.extrudePath=(new Po[n.type]).fromJSON(n)),new fg(e,t.options)}}const mg={generateTopUV:function(t,A,e,n,i){const s=A[3*e],a=A[3*e+1],r=A[3*n],o=A[3*n+1],g=A[3*i],c=A[3*i+1];return[new $e(s,a),new $e(r,o),new $e(g,c)]},generateSideWallUV:function(t,A,e,n,i,s){const a=A[3*e],r=A[3*e+1],o=A[3*e+2],g=A[3*n],c=A[3*n+1],l=A[3*n+2],I=A[3*i],h=A[3*i+1],u=A[3*i+2],B=A[3*s],d=A[3*s+1],C=A[3*s+2];return Math.abs(r-c)<Math.abs(a-g)?[new $e(a,1-o),new $e(g,1-l),new $e(I,1-u),new $e(B,1-C)]:[new $e(r,1-o),new $e(c,1-l),new $e(h,1-u),new $e(d,1-C)]}};class yg extends Bo{constructor(t=1,A=0){const e=(1+Math.sqrt(5))/2;super([-1,e,0,1,e,0,-1,-e,0,1,-e,0,0,-1,e,0,1,e,0,-1,-e,0,1,-e,e,0,-1,e,0,1,-e,0,-1,-e,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,A),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:A}}static fromJSON(t){return new yg(t.radius,t.detail)}}class wg extends Fs{constructor(t=[new $e(0,-.5),new $e(.5,0),new $e(0,.5)],A=12,e=0,n=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:A,phiStart:e,phiLength:n},A=Math.floor(A),n=Ke(n,0,2*Math.PI);const i=[],s=[],a=[],r=[],o=[],g=1/A,c=new An,l=new $e,I=new An,h=new An,u=new An;let B=0,d=0;for(let A=0;A<=t.length-1;A++)switch(A){case 0:B=t[A+1].x-t[A].x,d=t[A+1].y-t[A].y,I.x=1*d,I.y=-B,I.z=0*d,u.copy(I),I.normalize(),r.push(I.x,I.y,I.z);break;case t.length-1:r.push(u.x,u.y,u.z);break;default:B=t[A+1].x-t[A].x,d=t[A+1].y-t[A].y,I.x=1*d,I.y=-B,I.z=0*d,h.copy(I),I.x+=u.x,I.y+=u.y,I.z+=u.z,I.normalize(),r.push(I.x,I.y,I.z),u.copy(h)}for(let i=0;i<=A;i++){const I=e+i*g*n,h=Math.sin(I),u=Math.cos(I);for(let e=0;e<=t.length-1;e++){c.x=t[e].x*h,c.y=t[e].y,c.z=t[e].x*u,s.push(c.x,c.y,c.z),l.x=i/A,l.y=e/(t.length-1),a.push(l.x,l.y);const n=r[3*e+0]*h,g=r[3*e+1],I=r[3*e+0]*u;o.push(n,g,I)}}for(let e=0;e<A;e++)for(let A=0;A<t.length-1;A++){const n=A+e*t.length,s=n,a=n+t.length,r=n+t.length+1,o=n+1;i.push(s,a,o),i.push(r,o,a)}this.setIndex(i),this.setAttribute("position",new xs(s,3)),this.setAttribute("uv",new xs(a,2)),this.setAttribute("normal",new xs(o,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new wg(t.points,t.segments,t.phiStart,t.phiLength)}}class xg extends Bo{constructor(t=1,A=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,A),this.type="OctahedronGeometry",this.parameters={radius:t,detail:A}}static fromJSON(t){return new xg(t.radius,t.detail)}}class Sg extends Fs{constructor(t=1,A=1,e=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:A,widthSegments:e,heightSegments:n};const i=t/2,s=A/2,a=Math.floor(e),r=Math.floor(n),o=a+1,g=r+1,c=t/a,l=A/r,I=[],h=[],u=[],B=[];for(let t=0;t<g;t++){const A=t*l-s;for(let e=0;e<o;e++){const n=e*c-i;h.push(n,-A,0),u.push(0,0,1),B.push(e/a),B.push(1-t/r)}}for(let t=0;t<r;t++)for(let A=0;A<a;A++){const e=A+o*t,n=A+o*(t+1),i=A+1+o*(t+1),s=A+1+o*t;I.push(e,n,s),I.push(n,i,s)}this.setIndex(I),this.setAttribute("position",new xs(h,3)),this.setAttribute("normal",new xs(u,3)),this.setAttribute("uv",new xs(B,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Sg(t.width,t.height,t.widthSegments,t.heightSegments)}}class Dg extends Fs{constructor(t=.5,A=1,e=32,n=1,i=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:A,thetaSegments:e,phiSegments:n,thetaStart:i,thetaLength:s},e=Math.max(3,e);const a=[],r=[],o=[],g=[];let c=t;const l=(A-t)/(n=Math.max(1,n)),I=new An,h=new $e;for(let t=0;t<=n;t++){for(let t=0;t<=e;t++){const n=i+t/e*s;I.x=c*Math.cos(n),I.y=c*Math.sin(n),r.push(I.x,I.y,I.z),o.push(0,0,1),h.x=(I.x/A+1)/2,h.y=(I.y/A+1)/2,g.push(h.x,h.y)}c+=l}for(let t=0;t<n;t++){const A=t*(e+1);for(let t=0;t<e;t++){const n=t+A,i=n,s=n+e+1,r=n+e+2,o=n+1;a.push(i,s,o),a.push(s,r,o)}}this.setIndex(a),this.setAttribute("position",new xs(r,3)),this.setAttribute("normal",new xs(o,3)),this.setAttribute("uv",new xs(g,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Dg(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class vg extends Fs{constructor(t=new zo([new $e(0,.5),new $e(-.5,-.5),new $e(.5,-.5)]),A=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:A};const e=[],n=[],i=[],s=[];let a=0,r=0;if(!1===Array.isArray(t))o(t);else for(let A=0;A<t.length;A++)o(t[A]),this.addGroup(a,r,A),a+=r,r=0;function o(t){const a=n.length/3,o=t.extractPoints(A);let g=o.shape;const c=o.holes;!1===Eg.isClockWise(g)&&(g=g.reverse());for(let t=0,A=c.length;t<A;t++){const A=c[t];!0===Eg.isClockWise(A)&&(c[t]=A.reverse())}const l=Eg.triangulateShape(g,c);for(let t=0,A=c.length;t<A;t++){const A=c[t];g=g.concat(A)}for(let t=0,A=g.length;t<A;t++){const A=g[t];n.push(A.x,A.y,0),i.push(0,0,1),s.push(A.x,A.y)}for(let t=0,A=l.length;t<A;t++){const A=l[t],n=A[0]+a,i=A[1]+a,s=A[2]+a;e.push(n,i,s),r+=3}}this.setIndex(e),this.setAttribute("position",new xs(n,3)),this.setAttribute("normal",new xs(i,3)),this.setAttribute("uv",new xs(s,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,A){if(A.shapes=[],Array.isArray(t))for(let e=0,n=t.length;e<n;e++){const n=t[e];A.shapes.push(n.uuid)}else A.shapes.push(t.uuid);return A}(this.parameters.shapes,t)}static fromJSON(t,A){const e=[];for(let n=0,i=t.shapes.length;n<i;n++){const i=A[t.shapes[n]];e.push(i)}return new vg(e,t.curveSegments)}}class Mg extends Fs{constructor(t=1,A=32,e=16,n=0,i=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:A,heightSegments:e,phiStart:n,phiLength:i,thetaStart:s,thetaLength:a},A=Math.max(3,Math.floor(A)),e=Math.max(2,Math.floor(e));const r=Math.min(s+a,Math.PI);let o=0;const g=[],c=new An,l=new An,I=[],h=[],u=[],B=[];for(let I=0;I<=e;I++){const d=[],C=I/e;let E=0;0===I&&0===s?E=.5/A:I===e&&r===Math.PI&&(E=-.5/A);for(let e=0;e<=A;e++){const r=e/A;c.x=-t*Math.cos(n+r*i)*Math.sin(s+C*a),c.y=t*Math.cos(s+C*a),c.z=t*Math.sin(n+r*i)*Math.sin(s+C*a),h.push(c.x,c.y,c.z),l.copy(c).normalize(),u.push(l.x,l.y,l.z),B.push(r+E,1-C),d.push(o++)}g.push(d)}for(let t=0;t<e;t++)for(let n=0;n<A;n++){const A=g[t][n+1],i=g[t][n],a=g[t+1][n],o=g[t+1][n+1];(0!==t||s>0)&&I.push(A,i,o),(t!==e-1||r<Math.PI)&&I.push(i,a,o)}this.setIndex(I),this.setAttribute("position",new xs(h,3)),this.setAttribute("normal",new xs(u,3)),this.setAttribute("uv",new xs(B,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Mg(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class bg extends Bo{constructor(t=1,A=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,A),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:A}}static fromJSON(t){return new bg(t.radius,t.detail)}}class _g extends Fs{constructor(t=1,A=.4,e=12,n=48,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:A,radialSegments:e,tubularSegments:n,arc:i},e=Math.floor(e),n=Math.floor(n);const s=[],a=[],r=[],o=[],g=new An,c=new An,l=new An;for(let s=0;s<=e;s++)for(let I=0;I<=n;I++){const h=I/n*i,u=s/e*Math.PI*2;c.x=(t+A*Math.cos(u))*Math.cos(h),c.y=(t+A*Math.cos(u))*Math.sin(h),c.z=A*Math.sin(u),a.push(c.x,c.y,c.z),g.x=t*Math.cos(h),g.y=t*Math.sin(h),l.subVectors(c,g).normalize(),r.push(l.x,l.y,l.z),o.push(I/n),o.push(s/e)}for(let t=1;t<=e;t++)for(let A=1;A<=n;A++){const e=(n+1)*t+A-1,i=(n+1)*(t-1)+A-1,a=(n+1)*(t-1)+A,r=(n+1)*t+A;s.push(e,i,r),s.push(i,a,r)}this.setIndex(s),this.setAttribute("position",new xs(a,3)),this.setAttribute("normal",new xs(r,3)),this.setAttribute("uv",new xs(o,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new _g(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Rg extends Fs{constructor(t=1,A=.4,e=64,n=8,i=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:A,tubularSegments:e,radialSegments:n,p:i,q:s},e=Math.floor(e),n=Math.floor(n);const a=[],r=[],o=[],g=[],c=new An,l=new An,I=new An,h=new An,u=new An,B=new An,d=new An;for(let a=0;a<=e;++a){const E=a/e*i*Math.PI*2;C(E,i,s,t,I),C(E+.01,i,s,t,h),B.subVectors(h,I),d.addVectors(h,I),u.crossVectors(B,d),d.crossVectors(u,B),u.normalize(),d.normalize();for(let t=0;t<=n;++t){const i=t/n*Math.PI*2,s=-A*Math.cos(i),h=A*Math.sin(i);c.x=I.x+(s*d.x+h*u.x),c.y=I.y+(s*d.y+h*u.y),c.z=I.z+(s*d.z+h*u.z),r.push(c.x,c.y,c.z),l.subVectors(c,I).normalize(),o.push(l.x,l.y,l.z),g.push(a/e),g.push(t/n)}}for(let t=1;t<=e;t++)for(let A=1;A<=n;A++){const e=(n+1)*(t-1)+(A-1),i=(n+1)*t+(A-1),s=(n+1)*t+A,r=(n+1)*(t-1)+A;a.push(e,i,r),a.push(i,s,r)}function C(t,A,e,n,i){const s=Math.cos(t),a=Math.sin(t),r=e/A*t,o=Math.cos(r);i.x=n*(2+o)*.5*s,i.y=n*(2+o)*a*.5,i.z=n*Math.sin(r)*.5}this.setIndex(a),this.setAttribute("position",new xs(r,3)),this.setAttribute("normal",new xs(o,3)),this.setAttribute("uv",new xs(g,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Rg(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class Fg extends Fs{constructor(t=new Ho(new An(-1,-1,0),new An(-1,1,0),new An(1,1,0)),A=64,e=1,n=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:A,radius:e,radialSegments:n,closed:i};const s=t.computeFrenetFrames(A,i);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const a=new An,r=new An,o=new $e;let g=new An;const c=[],l=[],I=[],h=[];function u(i){g=t.getPointAt(i/A,g);const o=s.normals[i],I=s.binormals[i];for(let t=0;t<=n;t++){const A=t/n*Math.PI*2,i=Math.sin(A),s=-Math.cos(A);r.x=s*o.x+i*I.x,r.y=s*o.y+i*I.y,r.z=s*o.z+i*I.z,r.normalize(),l.push(r.x,r.y,r.z),a.x=g.x+e*r.x,a.y=g.y+e*r.y,a.z=g.z+e*r.z,c.push(a.x,a.y,a.z)}}!function(){for(let t=0;t<A;t++)u(t);u(!1===i?A:0),function(){for(let t=0;t<=A;t++)for(let e=0;e<=n;e++)o.x=t/A,o.y=e/n,I.push(o.x,o.y)}(),function(){for(let t=1;t<=A;t++)for(let A=1;A<=n;A++){const e=(n+1)*(t-1)+(A-1),i=(n+1)*t+(A-1),s=(n+1)*t+A,a=(n+1)*(t-1)+A;h.push(e,i,a),h.push(i,s,a)}}()}(),this.setIndex(h),this.setAttribute("position",new xs(c,3)),this.setAttribute("normal",new xs(l,3)),this.setAttribute("uv",new xs(I,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new Fg((new Po[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class Ng extends Fs{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const A=[],e=new Set,n=new An,i=new An;if(null!==t.index){const s=t.attributes.position,a=t.index;let r=t.groups;0===r.length&&(r=[{start:0,count:a.count,materialIndex:0}]);for(let t=0,o=r.length;t<o;++t){const o=r[t],g=o.start;for(let t=g,r=g+o.count;t<r;t+=3)for(let r=0;r<3;r++){const o=a.getX(t+r),g=a.getX(t+(r+1)%3);n.fromBufferAttribute(s,o),i.fromBufferAttribute(s,g),!0===kg(n,i,e)&&(A.push(n.x,n.y,n.z),A.push(i.x,i.y,i.z))}}}else{const s=t.attributes.position;for(let t=0,a=s.count/3;t<a;t++)for(let a=0;a<3;a++){const r=3*t+a,o=3*t+(a+1)%3;n.fromBufferAttribute(s,r),i.fromBufferAttribute(s,o),!0===kg(n,i,e)&&(A.push(n.x,n.y,n.z),A.push(i.x,i.y,i.z))}}this.setAttribute("position",new xs(A,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function kg(t,A,e){const n=`${t.x},${t.y},${t.z}-${A.x},${A.y},${A.z}`,i=`${A.x},${A.y},${A.z}-${t.x},${t.y},${t.z}`;return!0!==e.has(n)&&!0!==e.has(i)&&(e.add(n),e.add(i),!0)}var Tg=Object.freeze({__proto__:null,BoxGeometry:Ks,CapsuleGeometry:lo,CircleGeometry:Io,ConeGeometry:uo,CylinderGeometry:ho,DodecahedronGeometry:Co,EdgesGeometry:mo,ExtrudeGeometry:fg,IcosahedronGeometry:yg,LatheGeometry:wg,OctahedronGeometry:xg,PlaneGeometry:Sg,PolyhedronGeometry:Bo,RingGeometry:Dg,ShapeGeometry:vg,SphereGeometry:Mg,TetrahedronGeometry:bg,TorusGeometry:_g,TorusKnotGeometry:Rg,TubeGeometry:Fg,WireframeGeometry:Ng});class Gg extends as{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new ns(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class Ug extends Xs{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Lg extends as{constructor(t){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new ns(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ns(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=VA,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new fi,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Hg extends Lg{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new $e(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ke(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new ns(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new ns(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ns(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class Yg extends as{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new ns(16777215),this.specular=new ns(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ns(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=VA,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new fi,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Pg extends as{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ns(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ns(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=VA,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class Jg extends as{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=VA,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class qg extends as{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new ns(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ns(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=VA,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new fi,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class zg extends as{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=qA,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Og extends as{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}class Kg extends as{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ns(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=VA,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Vg extends Tr{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function Wg(t,A){return t&&t.constructor!==A?"number"==typeof A.BYTES_PER_ELEMENT?new A(t):Array.prototype.slice.call(t):t}function jg(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Zg(t){const A=t.length,e=new Array(A);for(let t=0;t!==A;++t)e[t]=t;return e.sort(function(A,e){return t[A]-t[e]}),e}function Xg(t,A,e){const n=t.length,i=new t.constructor(n);for(let s=0,a=0;a!==n;++s){const n=e[s]*A;for(let e=0;e!==A;++e)i[a++]=t[n+e]}return i}function $g(t,A,e,n){let i=1,s=t[0];for(;void 0!==s&&void 0===s[n];)s=t[i++];if(void 0===s)return;let a=s[n];if(void 0!==a)if(Array.isArray(a))do{a=s[n],void 0!==a&&(A.push(s.time),e.push(...a)),s=t[i++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[n],void 0!==a&&(A.push(s.time),a.toArray(e,e.length)),s=t[i++]}while(void 0!==s);else do{a=s[n],void 0!==a&&(A.push(s.time),e.push(a)),s=t[i++]}while(void 0!==s)}class tc{static convertArray(t,A){return Wg(t,A)}static isTypedArray(t){return jg(t)}static getKeyframeOrder(t){return Zg(t)}static sortedArray(t,A,e){return Xg(t,A,e)}static flattenJSON(t,A,e,n){$g(t,A,e,n)}static subclip(t,A,e,n,i=30){return function(t,A,e,n,i=30){const s=t.clone();s.name=A;const a=[];for(let t=0;t<s.tracks.length;++t){const A=s.tracks[t],r=A.getValueSize(),o=[],g=[];for(let t=0;t<A.times.length;++t){const s=A.times[t]*i;if(!(s<e||s>=n)){o.push(A.times[t]);for(let e=0;e<r;++e)g.push(A.values[t*r+e])}}0!==o.length&&(A.times=Wg(o,A.times.constructor),A.values=Wg(g,A.values.constructor),a.push(A))}s.tracks=a;let r=1/0;for(let t=0;t<s.tracks.length;++t)r>s.tracks[t].times[0]&&(r=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*r);return s.resetDuration(),s}(t,A,e,n,i)}static makeClipAdditive(t,A=0,e=t,n=30){return function(t,A=0,e=t,n=30){n<=0&&(n=30);const i=e.tracks.length,s=A/n;for(let A=0;A<i;++A){const n=e.tracks[A],i=n.ValueTypeName;if("bool"===i||"string"===i)continue;const a=t.tracks.find(function(t){return t.name===n.name&&t.ValueTypeName===i});if(void 0===a)continue;let r=0;const o=n.getValueSize();n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(r=o/3);let g=0;const c=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(g=c/3);const l=n.times.length-1;let I;if(s<=n.times[0]){const t=r,A=o-r;I=n.values.slice(t,A)}else if(s>=n.times[l]){const t=l*o+r,A=t+o-r;I=n.values.slice(t,A)}else{const t=n.createInterpolant(),A=r,e=o-r;t.evaluate(s),I=t.resultBuffer.slice(A,e)}"quaternion"===i&&(new tn).fromArray(I).normalize().conjugate().toArray(I);const h=a.times.length;for(let t=0;t<h;++t){const A=t*c+g;if("quaternion"===i)tn.multiplyQuaternionsFlat(a.values,A,I,0,a.values,A);else{const t=c-2*g;for(let e=0;e<t;++e)a.values[A+e]-=I[e]}}}return t.blendMode=HA,t}(t,A,e,n)}}class Ac{constructor(t,A,e,n){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==n?n:new A.constructor(e),this.sampleValues=A,this.valueSize=e,this.settings=null,this.DefaultSettings_={}}evaluate(t){const A=this.parameterPositions;let e=this._cachedIndex,n=A[e],i=A[e-1];t:{A:{let s;e:{n:if(!(t<n)){for(let s=e+2;;){if(void 0===n){if(t<i)break n;return e=A.length,this._cachedIndex=e,this.copySampleValue_(e-1)}if(e===s)break;if(i=n,n=A[++e],t<n)break A}s=A.length;break e}if(!(t>=i)){const a=A[1];t<a&&(e=2,i=a);for(let s=e-2;;){if(void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(e===s)break;if(n=i,i=A[--e-1],t>=i)break A}s=e,e=0;break e}break t}for(;e<s;){const n=e+s>>>1;t<A[n]?s=n:e=n+1}if(n=A[e],i=A[e-1],void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===n)return e=A.length,this._cachedIndex=e,this.copySampleValue_(e-1)}this._cachedIndex=e,this.intervalChanged_(e,i,n)}return this.interpolate_(e,i,t,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const A=this.resultBuffer,e=this.sampleValues,n=this.valueSize,i=t*n;for(let t=0;t!==n;++t)A[t]=e[i+t];return A}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class ec extends Ac{constructor(t,A,e,n){super(t,A,e,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:TA,endingEnd:TA}}intervalChanged_(t,A,e){const n=this.parameterPositions;let i=t-2,s=t+1,a=n[i],r=n[s];if(void 0===a)switch(this.getSettings_().endingStart){case GA:i=t,a=2*A-e;break;case UA:i=n.length-2,a=A+n[i]-n[i+1];break;default:i=t,a=e}if(void 0===r)switch(this.getSettings_().endingEnd){case GA:s=t,r=2*e-A;break;case UA:s=1,r=e+n[1]-n[0];break;default:s=t-1,r=A}const o=.5*(e-A),g=this.valueSize;this._weightPrev=o/(A-a),this._weightNext=o/(r-e),this._offsetPrev=i*g,this._offsetNext=s*g}interpolate_(t,A,e,n){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,r=t*a,o=r-a,g=this._offsetPrev,c=this._offsetNext,l=this._weightPrev,I=this._weightNext,h=(e-A)/(n-A),u=h*h,B=u*h,d=-l*B+2*l*u-l*h,C=(1+l)*B+(-1.5-2*l)*u+(-.5+l)*h+1,E=(-1-I)*B+(1.5+I)*u+.5*h,Q=I*B-I*u;for(let t=0;t!==a;++t)i[t]=d*s[g+t]+C*s[o+t]+E*s[r+t]+Q*s[c+t];return i}}class nc extends Ac{constructor(t,A,e,n){super(t,A,e,n)}interpolate_(t,A,e,n){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,r=t*a,o=r-a,g=(e-A)/(n-A),c=1-g;for(let t=0;t!==a;++t)i[t]=s[o+t]*c+s[r+t]*g;return i}}class ic extends Ac{constructor(t,A,e,n){super(t,A,e,n)}interpolate_(t){return this.copySampleValue_(t-1)}}class sc{constructor(t,A,e,n){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===A||0===A.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Wg(A,this.TimeBufferType),this.values=Wg(e,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(t){const A=t.constructor;let e;if(A.toJSON!==this.toJSON)e=A.toJSON(t);else{e={name:t.name,times:Wg(t.times,Array),values:Wg(t.values,Array)};const A=t.getInterpolation();A!==t.DefaultInterpolation&&(e.interpolation=A)}return e.type=t.ValueTypeName,e}InterpolantFactoryMethodDiscrete(t){return new ic(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new nc(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new ec(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let A;switch(t){case FA:A=this.InterpolantFactoryMethodDiscrete;break;case NA:A=this.InterpolantFactoryMethodLinear;break;case kA:A=this.InterpolantFactoryMethodSmooth}if(void 0===A){const A="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(A);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",A),this}return this.createInterpolant=A,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return FA;case this.InterpolantFactoryMethodLinear:return NA;case this.InterpolantFactoryMethodSmooth:return kA}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const A=this.times;for(let e=0,n=A.length;e!==n;++e)A[e]+=t}return this}scale(t){if(1!==t){const A=this.times;for(let e=0,n=A.length;e!==n;++e)A[e]*=t}return this}trim(t,A){const e=this.times,n=e.length;let i=0,s=n-1;for(;i!==n&&e[i]<t;)++i;for(;-1!==s&&e[s]>A;)--s;if(++s,0!==i||s!==n){i>=s&&(s=Math.max(s,1),i=s-1);const t=this.getValueSize();this.times=e.slice(i,s),this.values=this.values.slice(i*t,s*t)}return this}validate(){let t=!0;const A=this.getValueSize();A-Math.floor(A)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const e=this.times,n=this.values,i=e.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let A=0;A!==i;A++){const n=e[A];if("number"==typeof n&&isNaN(n)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,A,n),t=!1;break}if(null!==s&&s>n){console.error("THREE.KeyframeTrack: Out of order keys.",this,A,n,s),t=!1;break}s=n}if(void 0!==n&&jg(n))for(let A=0,e=n.length;A!==e;++A){const e=n[A];if(isNaN(e)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,A,e),t=!1;break}}return t}optimize(){const t=this.times.slice(),A=this.values.slice(),e=this.getValueSize(),n=this.getInterpolation()===kA,i=t.length-1;let s=1;for(let a=1;a<i;++a){let i=!1;const r=t[a];if(r!==t[a+1]&&(1!==a||r!==t[0]))if(n)i=!0;else{const t=a*e,n=t-e,s=t+e;for(let a=0;a!==e;++a){const e=A[t+a];if(e!==A[n+a]||e!==A[s+a]){i=!0;break}}}if(i){if(a!==s){t[s]=t[a];const n=a*e,i=s*e;for(let t=0;t!==e;++t)A[i+t]=A[n+t]}++s}}if(i>0){t[s]=t[i];for(let t=i*e,n=s*e,a=0;a!==e;++a)A[n+a]=A[t+a];++s}return s!==t.length?(this.times=t.slice(0,s),this.values=A.slice(0,s*e)):(this.times=t,this.values=A),this}clone(){const t=this.times.slice(),A=this.values.slice(),e=new(0,this.constructor)(this.name,t,A);return e.createInterpolant=this.createInterpolant,e}}sc.prototype.ValueTypeName="",sc.prototype.TimeBufferType=Float32Array,sc.prototype.ValueBufferType=Float32Array,sc.prototype.DefaultInterpolation=NA;class ac extends sc{constructor(t,A,e){super(t,A,e)}}ac.prototype.ValueTypeName="bool",ac.prototype.ValueBufferType=Array,ac.prototype.DefaultInterpolation=FA,ac.prototype.InterpolantFactoryMethodLinear=void 0,ac.prototype.InterpolantFactoryMethodSmooth=void 0;class rc extends sc{constructor(t,A,e,n){super(t,A,e,n)}}rc.prototype.ValueTypeName="color";class oc extends sc{constructor(t,A,e,n){super(t,A,e,n)}}oc.prototype.ValueTypeName="number";class gc extends Ac{constructor(t,A,e,n){super(t,A,e,n)}interpolate_(t,A,e,n){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,r=(e-A)/(n-A);let o=t*a;for(let t=o+a;o!==t;o+=4)tn.slerpFlat(i,0,s,o-a,s,o,r);return i}}class cc extends sc{constructor(t,A,e,n){super(t,A,e,n)}InterpolantFactoryMethodLinear(t){return new gc(this.times,this.values,this.getValueSize(),t)}}cc.prototype.ValueTypeName="quaternion",cc.prototype.InterpolantFactoryMethodSmooth=void 0;class lc extends sc{constructor(t,A,e){super(t,A,e)}}lc.prototype.ValueTypeName="string",lc.prototype.ValueBufferType=Array,lc.prototype.DefaultInterpolation=FA,lc.prototype.InterpolantFactoryMethodLinear=void 0,lc.prototype.InterpolantFactoryMethodSmooth=void 0;class Ic extends sc{constructor(t,A,e,n){super(t,A,e,n)}}Ic.prototype.ValueTypeName="vector";class hc{constructor(t="",A=-1,e=[],n=LA){this.name=t,this.tracks=e,this.duration=A,this.blendMode=n,this.uuid=Oe(),this.duration<0&&this.resetDuration()}static parse(t){const A=[],e=t.tracks,n=1/(t.fps||1);for(let t=0,i=e.length;t!==i;++t)A.push(uc(e[t]).scale(n));const i=new this(t.name,t.duration,A,t.blendMode);return i.uuid=t.uuid,i}static toJSON(t){const A=[],e=t.tracks,n={name:t.name,duration:t.duration,tracks:A,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,n=e.length;t!==n;++t)A.push(sc.toJSON(e[t]));return n}static CreateFromMorphTargetSequence(t,A,e,n){const i=A.length,s=[];for(let t=0;t<i;t++){let a=[],r=[];a.push((t+i-1)%i,t,(t+1)%i),r.push(0,1,0);const o=Zg(a);a=Xg(a,1,o),r=Xg(r,1,o),n||0!==a[0]||(a.push(i),r.push(r[0])),s.push(new oc(".morphTargetInfluences["+A[t].name+"]",a,r).scale(1/e))}return new this(t,-1,s)}static findByName(t,A){let e=t;if(!Array.isArray(t)){const A=t;e=A.geometry&&A.geometry.animations||A.animations}for(let t=0;t<e.length;t++)if(e[t].name===A)return e[t];return null}static CreateClipsFromMorphTargetSequences(t,A,e){const n={},i=/^([\w-]*?)([\d]+)$/;for(let A=0,e=t.length;A<e;A++){const e=t[A],s=e.name.match(i);if(s&&s.length>1){const t=s[1];let A=n[t];A||(n[t]=A=[]),A.push(e)}}const s=[];for(const t in n)s.push(this.CreateFromMorphTargetSequence(t,n[t],A,e));return s}static parseAnimation(t,A){if(console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const e=function(t,A,e,n,i){if(0!==e.length){const s=[],a=[];$g(e,s,a,n),0!==s.length&&i.push(new t(A,s,a))}},n=[],i=t.name||"default",s=t.fps||30,a=t.blendMode;let r=t.length||-1;const o=t.hierarchy||[];for(let t=0;t<o.length;t++){const i=o[t].keys;if(i&&0!==i.length)if(i[0].morphTargets){const t={};let A;for(A=0;A<i.length;A++)if(i[A].morphTargets)for(let e=0;e<i[A].morphTargets.length;e++)t[i[A].morphTargets[e]]=-1;for(const e in t){const t=[],s=[];for(let n=0;n!==i[A].morphTargets.length;++n){const n=i[A];t.push(n.time),s.push(n.morphTarget===e?1:0)}n.push(new oc(".morphTargetInfluence["+e+"]",t,s))}r=t.length*s}else{const s=".bones["+A[t].name+"]";e(Ic,s+".position",i,"pos",n),e(cc,s+".quaternion",i,"rot",n),e(Ic,s+".scale",i,"scl",n)}}return 0===n.length?null:new this(i,r,n,a)}resetDuration(){let t=0;for(let A=0,e=this.tracks.length;A!==e;++A){const e=this.tracks[A];t=Math.max(t,e.times[e.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let A=0;A<this.tracks.length;A++)t=t&&this.tracks[A].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let A=0;A<this.tracks.length;A++)t.push(this.tracks[A].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function uc(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const A=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return oc;case"vector":case"vector2":case"vector3":case"vector4":return Ic;case"color":return rc;case"quaternion":return cc;case"bool":case"boolean":return ac;case"string":return lc}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const A=[],e=[];$g(t.keys,A,e,"value"),t.times=A,t.values=e}return void 0!==A.parse?A.parse(t):new A(t.name,t.times,t.values,t.interpolation)}const Bc={enabled:!1,files:{},add:function(t,A){!1!==this.enabled&&(this.files[t]=A)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class dc{constructor(t,A,e){const n=this;let i,s=!1,a=0,r=0;const o=[];this.onStart=void 0,this.onLoad=t,this.onProgress=A,this.onError=e,this.itemStart=function(t){r++,!1===s&&void 0!==n.onStart&&n.onStart(t,a,r),s=!0},this.itemEnd=function(t){a++,void 0!==n.onProgress&&n.onProgress(t,a,r),a===r&&(s=!1,void 0!==n.onLoad&&n.onLoad())},this.itemError=function(t){void 0!==n.onError&&n.onError(t)},this.resolveURL=function(t){return i?i(t):t},this.setURLModifier=function(t){return i=t,this},this.addHandler=function(t,A){return o.push(t,A),this},this.removeHandler=function(t){const A=o.indexOf(t);return-1!==A&&o.splice(A,2),this},this.getHandler=function(t){for(let A=0,e=o.length;A<e;A+=2){const e=o[A],n=o[A+1];if(e.global&&(e.lastIndex=0),e.test(t))return n}return null}}}const Cc=new dc;class Ec{constructor(t){this.manager=void 0!==t?t:Cc,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,A){const e=this;return new Promise(function(n,i){e.load(t,n,A,i)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}Ec.DEFAULT_MATERIAL_NAME="__DEFAULT";const Qc={};class pc extends Error{constructor(t,A){super(t),this.response=A}}class fc extends Ec{constructor(t){super(t),this.mimeType="",this.responseType=""}load(t,A,e,n){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=Bc.get(`file:${t}`);if(void 0!==i)return this.manager.itemStart(t),setTimeout(()=>{A&&A(i),this.manager.itemEnd(t)},0),i;if(void 0!==Qc[t])return void Qc[t].push({onLoad:A,onProgress:e,onError:n});Qc[t]=[],Qc[t].push({onLoad:A,onProgress:e,onError:n});const s=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,r=this.responseType;fetch(s).then(A=>{if(200===A.status||0===A.status){if(0===A.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===A.body||void 0===A.body.getReader)return A;const e=Qc[t],n=A.body.getReader(),i=A.headers.get("X-File-Size")||A.headers.get("Content-Length"),s=i?parseInt(i):0,a=0!==s;let r=0;const o=new ReadableStream({start(t){!function A(){n.read().then(({done:n,value:i})=>{if(n)t.close();else{r+=i.byteLength;const n=new ProgressEvent("progress",{lengthComputable:a,loaded:r,total:s});for(let t=0,A=e.length;t<A;t++){const A=e[t];A.onProgress&&A.onProgress(n)}t.enqueue(i),A()}},A=>{t.error(A)})}()}});return new Response(o)}throw new pc(`fetch for "${A.url}" responded with ${A.status}: ${A.statusText}`,A)}).then(t=>{switch(r){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then(t=>(new DOMParser).parseFromString(t,a));case"json":return t.json();default:if(""===a)return t.text();{const A=/charset="?([^;"\s]*)"?/i.exec(a),e=A&&A[1]?A[1].toLowerCase():void 0,n=new TextDecoder(e);return t.arrayBuffer().then(t=>n.decode(t))}}}).then(A=>{Bc.add(`file:${t}`,A);const e=Qc[t];delete Qc[t];for(let t=0,n=e.length;t<n;t++){const n=e[t];n.onLoad&&n.onLoad(A)}}).catch(A=>{const e=Qc[t];if(void 0===e)throw this.manager.itemError(t),A;delete Qc[t];for(let t=0,n=e.length;t<n;t++){const n=e[t];n.onError&&n.onError(A)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class mc extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=this,s=new fc(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(e){try{A(i.parse(JSON.parse(e)))}catch(A){n?n(A):console.error(A),i.manager.itemError(t)}},e,n)}parse(t){const A=[];for(let e=0;e<t.length;e++){const n=hc.parse(t[e]);A.push(n)}return A}}class yc extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=this,s=[],a=new ao,r=new fc(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(i.withCredentials);let o=0;function g(g){r.load(t[g],function(t){const e=i.parse(t,!0);s[g]={width:e.width,height:e.height,format:e.format,mipmaps:e.mipmaps},o+=1,6===o&&(1===e.mipmapCount&&(a.minFilter=wt),a.image=s,a.format=e.format,a.needsUpdate=!0,A&&A(a))},e,n)}if(Array.isArray(t))for(let A=0,e=t.length;A<e;++A)g(A);else r.load(t,function(t){const e=i.parse(t,!0);if(e.isCubemap){const t=e.mipmaps.length/e.mipmapCount;for(let A=0;A<t;A++){s[A]={mipmaps:[]};for(let t=0;t<e.mipmapCount;t++)s[A].mipmaps.push(e.mipmaps[A*e.mipmapCount+t]),s[A].format=e.format,s[A].width=e.width,s[A].height=e.height}a.image=s}else a.image.width=e.width,a.image.height=e.height,a.mipmaps=e.mipmaps;1===e.mipmapCount&&(a.minFilter=wt),a.format=e.format,a.needsUpdate=!0,A&&A(a)},e,n);return a}}const wc=new WeakMap;class xc extends Ec{constructor(t){super(t)}load(t,A,e,n){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=Bc.get(`image:${t}`);if(void 0!==s){if(!0===s.complete)i.manager.itemStart(t),setTimeout(function(){A&&A(s),i.manager.itemEnd(t)},0);else{let t=wc.get(s);void 0===t&&(t=[],wc.set(s,t)),t.push({onLoad:A,onError:n})}return s}const a=cn("img");function r(){g(),A&&A(this);const e=wc.get(this)||[];for(let t=0;t<e.length;t++){const A=e[t];A.onLoad&&A.onLoad(this)}wc.delete(this),i.manager.itemEnd(t)}function o(A){g(),n&&n(A),Bc.remove(`image:${t}`);const e=wc.get(this)||[];for(let t=0;t<e.length;t++){const n=e[t];n.onError&&n.onError(A)}wc.delete(this),i.manager.itemError(t),i.manager.itemEnd(t)}function g(){a.removeEventListener("load",r,!1),a.removeEventListener("error",o,!1)}return a.addEventListener("load",r,!1),a.addEventListener("error",o,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),Bc.add(`image:${t}`,a),i.manager.itemStart(t),a.src=t,a}}class Sc extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=new aa;i.colorSpace=ZA;const s=new xc(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;function r(e){s.load(t[e],function(t){i.images[e]=t,a++,6===a&&(i.needsUpdate=!0,A&&A(i))},void 0,n)}for(let A=0;A<t.length;++A)r(A);return i}}class Dc extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=this,s=new Ka,a=new fc(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(i.withCredentials),a.load(t,function(t){let e;try{e=i.parse(t)}catch(t){if(void 0===n)return void console.error(t);n(t)}void 0!==e.image?s.image=e.image:void 0!==e.data&&(s.image.width=e.width,s.image.height=e.height,s.image.data=e.data),s.wrapS=void 0!==e.wrapS?e.wrapS:Ct,s.wrapT=void 0!==e.wrapT?e.wrapT:Ct,s.magFilter=void 0!==e.magFilter?e.magFilter:wt,s.minFilter=void 0!==e.minFilter?e.minFilter:wt,s.anisotropy=void 0!==e.anisotropy?e.anisotropy:1,void 0!==e.colorSpace&&(s.colorSpace=e.colorSpace),void 0!==e.flipY&&(s.flipY=e.flipY),void 0!==e.format&&(s.format=e.format),void 0!==e.type&&(s.type=e.type),void 0!==e.mipmaps&&(s.mipmaps=e.mipmaps,s.minFilter=Dt),1===e.mipmapCount&&(s.minFilter=wt),void 0!==e.generateMipmaps&&(s.generateMipmaps=e.generateMipmaps),s.needsUpdate=!0,A&&A(s,e)},e,n),s}}class vc extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=new bn,s=new xc(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(t){i.image=t,i.needsUpdate=!0,void 0!==A&&A(i)},e,n),i}}class Mc extends Ui{constructor(t,A=1){super(),this.isLight=!0,this.type="Light",this.color=new ns(t),this.intensity=A}dispose(){}copy(t,A){return super.copy(t,A),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const A=super.toJSON(t);return A.object.color=this.color.getHex(),A.object.intensity=this.intensity,void 0!==this.groundColor&&(A.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(A.object.distance=this.distance),void 0!==this.angle&&(A.object.angle=this.angle),void 0!==this.decay&&(A.object.decay=this.decay),void 0!==this.penumbra&&(A.object.penumbra=this.penumbra),void 0!==this.shadow&&(A.object.shadow=this.shadow.toJSON()),void 0!==this.target&&(A.object.target=this.target.uuid),A}}class bc extends Mc{constructor(t,A,e){super(t,e),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Ui.DEFAULT_UP),this.updateMatrix(),this.groundColor=new ns(A)}copy(t,A){return super.copy(t,A),this.groundColor.copy(t.groundColor),this}}const _c=new li,Rc=new An,Fc=new An;class Nc{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new $e(512,512),this.mapType=Mt,this.map=null,this.mapPass=null,this.matrix=new li,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new hr,this._frameExtents=new $e(1,1),this._viewportCount=1,this._viewports=[new _n(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const A=this.camera,e=this.matrix;Rc.setFromMatrixPosition(t.matrixWorld),A.position.copy(Rc),Fc.setFromMatrixPosition(t.target.matrixWorld),A.lookAt(Fc),A.updateMatrixWorld(),_c.multiplyMatrices(A.projectionMatrix,A.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_c),e.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),e.multiply(_c)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.autoUpdate=t.autoUpdate,this.needsUpdate=t.needsUpdate,this.normalBias=t.normalBias,this.blurSamples=t.blurSamples,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 1!==this.intensity&&(t.intensity=this.intensity),0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class kc extends Nc{constructor(){super(new na(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(t){const A=this.camera,e=2*ze*t.angle*this.focus,n=this.mapSize.width/this.mapSize.height*this.aspect,i=t.distance||A.far;e===A.fov&&n===A.aspect&&i===A.far||(A.fov=e,A.aspect=n,A.far=i,A.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Tc extends Mc{constructor(t,A,e=0,n=Math.PI/3,i=0,s=2){super(t,A),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Ui.DEFAULT_UP),this.updateMatrix(),this.target=new Ui,this.distance=e,this.angle=n,this.penumbra=i,this.decay=s,this.map=null,this.shadow=new kc}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,A){return super.copy(t,A),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Gc=new li,Uc=new An,Lc=new An;class Hc extends Nc{constructor(){super(new na(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new $e(4,2),this._viewportCount=6,this._viewports=[new _n(2,1,1,1),new _n(0,1,1,1),new _n(3,1,1,1),new _n(1,1,1,1),new _n(3,0,1,1),new _n(1,0,1,1)],this._cubeDirections=[new An(1,0,0),new An(-1,0,0),new An(0,0,1),new An(0,0,-1),new An(0,1,0),new An(0,-1,0)],this._cubeUps=[new An(0,1,0),new An(0,1,0),new An(0,1,0),new An(0,1,0),new An(0,0,1),new An(0,0,-1)]}updateMatrices(t,A=0){const e=this.camera,n=this.matrix,i=t.distance||e.far;i!==e.far&&(e.far=i,e.updateProjectionMatrix()),Uc.setFromMatrixPosition(t.matrixWorld),e.position.copy(Uc),Lc.copy(e.position),Lc.add(this._cubeDirections[A]),e.up.copy(this._cubeUps[A]),e.lookAt(Lc),e.updateMatrixWorld(),n.makeTranslation(-Uc.x,-Uc.y,-Uc.z),Gc.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Gc)}}class Yc extends Mc{constructor(t,A,e=0,n=2){super(t,A),this.isPointLight=!0,this.type="PointLight",this.distance=e,this.decay=n,this.shadow=new Hc}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,A){return super.copy(t,A),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class Pc extends $s{constructor(t=-1,A=1,e=1,n=-1,i=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=A,this.top=e,this.bottom=n,this.near=i,this.far=s,this.updateProjectionMatrix()}copy(t,A){return super.copy(t,A),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,A,e,n,i,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=A,this.view.offsetX=e,this.view.offsetY=n,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),A=(this.top-this.bottom)/(2*this.zoom),e=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let i=e-t,s=e+t,a=n+A,r=n-A;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,A=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=t*this.view.offsetX,s=i+t*this.view.width,a-=A*this.view.offsetY,r=a-A*this.view.height}this.projectionMatrix.makeOrthographic(i,s,a,r,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const A=super.toJSON(t);return A.object.zoom=this.zoom,A.object.left=this.left,A.object.right=this.right,A.object.top=this.top,A.object.bottom=this.bottom,A.object.near=this.near,A.object.far=this.far,null!==this.view&&(A.object.view=Object.assign({},this.view)),A}}class Jc extends Nc{constructor(){super(new Pc(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class qc extends Mc{constructor(t,A){super(t,A),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Ui.DEFAULT_UP),this.updateMatrix(),this.target=new Ui,this.shadow=new Jc}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class zc extends Mc{constructor(t,A){super(t,A),this.isAmbientLight=!0,this.type="AmbientLight"}}class Oc extends Mc{constructor(t,A,e=10,n=10){super(t,A),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=e,this.height=n}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const A=super.toJSON(t);return A.object.width=this.width,A.object.height=this.height,A}}class Kc{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new An)}set(t){for(let A=0;A<9;A++)this.coefficients[A].copy(t[A]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,A){const e=t.x,n=t.y,i=t.z,s=this.coefficients;return A.copy(s[0]).multiplyScalar(.282095),A.addScaledVector(s[1],.488603*n),A.addScaledVector(s[2],.488603*i),A.addScaledVector(s[3],.488603*e),A.addScaledVector(s[4],e*n*1.092548),A.addScaledVector(s[5],n*i*1.092548),A.addScaledVector(s[6],.315392*(3*i*i-1)),A.addScaledVector(s[7],e*i*1.092548),A.addScaledVector(s[8],.546274*(e*e-n*n)),A}getIrradianceAt(t,A){const e=t.x,n=t.y,i=t.z,s=this.coefficients;return A.copy(s[0]).multiplyScalar(.886227),A.addScaledVector(s[1],1.023328*n),A.addScaledVector(s[2],1.023328*i),A.addScaledVector(s[3],1.023328*e),A.addScaledVector(s[4],.858086*e*n),A.addScaledVector(s[5],.858086*n*i),A.addScaledVector(s[6],.743125*i*i-.247708),A.addScaledVector(s[7],.858086*e*i),A.addScaledVector(s[8],.429043*(e*e-n*n)),A}add(t){for(let A=0;A<9;A++)this.coefficients[A].add(t.coefficients[A]);return this}addScaledSH(t,A){for(let e=0;e<9;e++)this.coefficients[e].addScaledVector(t.coefficients[e],A);return this}scale(t){for(let A=0;A<9;A++)this.coefficients[A].multiplyScalar(t);return this}lerp(t,A){for(let e=0;e<9;e++)this.coefficients[e].lerp(t.coefficients[e],A);return this}equals(t){for(let A=0;A<9;A++)if(!this.coefficients[A].equals(t.coefficients[A]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,A=0){const e=this.coefficients;for(let n=0;n<9;n++)e[n].fromArray(t,A+3*n);return this}toArray(t=[],A=0){const e=this.coefficients;for(let n=0;n<9;n++)e[n].toArray(t,A+3*n);return t}static getBasisAt(t,A){const e=t.x,n=t.y,i=t.z;A[0]=.282095,A[1]=.488603*n,A[2]=.488603*i,A[3]=.488603*e,A[4]=1.092548*e*n,A[5]=1.092548*n*i,A[6]=.315392*(3*i*i-1),A[7]=1.092548*e*i,A[8]=.546274*(e*e-n*n)}}class Vc extends Mc{constructor(t=new Kc,A=1){super(void 0,A),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const A=super.toJSON(t);return A.object.sh=this.sh.toArray(),A}}class Wc extends Ec{constructor(t){super(t),this.textures={}}load(t,A,e,n){const i=this,s=new fc(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,function(e){try{A(i.parse(JSON.parse(e)))}catch(A){n?n(A):console.error(A),i.manager.itemError(t)}},e,n)}parse(t){const A=this.textures;function e(t){return void 0===A[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),A[t]}const n=this.createMaterialFromType(t.type);if(void 0!==t.uuid&&(n.uuid=t.uuid),void 0!==t.name&&(n.name=t.name),void 0!==t.color&&void 0!==n.color&&n.color.setHex(t.color),void 0!==t.roughness&&(n.roughness=t.roughness),void 0!==t.metalness&&(n.metalness=t.metalness),void 0!==t.sheen&&(n.sheen=t.sheen),void 0!==t.sheenColor&&(n.sheenColor=(new ns).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(n.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==n.emissive&&n.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==n.specular&&n.specular.setHex(t.specular),void 0!==t.specularIntensity&&(n.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==n.specularColor&&n.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(n.shininess=t.shininess),void 0!==t.clearcoat&&(n.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(n.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.dispersion&&(n.dispersion=t.dispersion),void 0!==t.iridescence&&(n.iridescence=t.iridescence),void 0!==t.iridescenceIOR&&(n.iridescenceIOR=t.iridescenceIOR),void 0!==t.iridescenceThicknessRange&&(n.iridescenceThicknessRange=t.iridescenceThicknessRange),void 0!==t.transmission&&(n.transmission=t.transmission),void 0!==t.thickness&&(n.thickness=t.thickness),void 0!==t.attenuationDistance&&(n.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==n.attenuationColor&&n.attenuationColor.setHex(t.attenuationColor),void 0!==t.anisotropy&&(n.anisotropy=t.anisotropy),void 0!==t.anisotropyRotation&&(n.anisotropyRotation=t.anisotropyRotation),void 0!==t.fog&&(n.fog=t.fog),void 0!==t.flatShading&&(n.flatShading=t.flatShading),void 0!==t.blending&&(n.blending=t.blending),void 0!==t.combine&&(n.combine=t.combine),void 0!==t.side&&(n.side=t.side),void 0!==t.shadowSide&&(n.shadowSide=t.shadowSide),void 0!==t.opacity&&(n.opacity=t.opacity),void 0!==t.transparent&&(n.transparent=t.transparent),void 0!==t.alphaTest&&(n.alphaTest=t.alphaTest),void 0!==t.alphaHash&&(n.alphaHash=t.alphaHash),void 0!==t.depthFunc&&(n.depthFunc=t.depthFunc),void 0!==t.depthTest&&(n.depthTest=t.depthTest),void 0!==t.depthWrite&&(n.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(n.colorWrite=t.colorWrite),void 0!==t.blendSrc&&(n.blendSrc=t.blendSrc),void 0!==t.blendDst&&(n.blendDst=t.blendDst),void 0!==t.blendEquation&&(n.blendEquation=t.blendEquation),void 0!==t.blendSrcAlpha&&(n.blendSrcAlpha=t.blendSrcAlpha),void 0!==t.blendDstAlpha&&(n.blendDstAlpha=t.blendDstAlpha),void 0!==t.blendEquationAlpha&&(n.blendEquationAlpha=t.blendEquationAlpha),void 0!==t.blendColor&&void 0!==n.blendColor&&n.blendColor.setHex(t.blendColor),void 0!==t.blendAlpha&&(n.blendAlpha=t.blendAlpha),void 0!==t.stencilWriteMask&&(n.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(n.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(n.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(n.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(n.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(n.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(n.stencilZPass=t.stencilZPass),void 0!==t.stencilWrite&&(n.stencilWrite=t.stencilWrite),void 0!==t.wireframe&&(n.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(n.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(n.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(n.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(n.rotation=t.rotation),void 0!==t.linewidth&&(n.linewidth=t.linewidth),void 0!==t.dashSize&&(n.dashSize=t.dashSize),void 0!==t.gapSize&&(n.gapSize=t.gapSize),void 0!==t.scale&&(n.scale=t.scale),void 0!==t.polygonOffset&&(n.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(n.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(n.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(n.dithering=t.dithering),void 0!==t.alphaToCoverage&&(n.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(n.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.forceSinglePass&&(n.forceSinglePass=t.forceSinglePass),void 0!==t.visible&&(n.visible=t.visible),void 0!==t.toneMapped&&(n.toneMapped=t.toneMapped),void 0!==t.userData&&(n.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?n.vertexColors=t.vertexColors>0:n.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const A in t.uniforms){const i=t.uniforms[A];switch(n.uniforms[A]={},i.type){case"t":n.uniforms[A].value=e(i.value);break;case"c":n.uniforms[A].value=(new ns).setHex(i.value);break;case"v2":n.uniforms[A].value=(new $e).fromArray(i.value);break;case"v3":n.uniforms[A].value=(new An).fromArray(i.value);break;case"v4":n.uniforms[A].value=(new _n).fromArray(i.value);break;case"m3":n.uniforms[A].value=(new sn).fromArray(i.value);break;case"m4":n.uniforms[A].value=(new li).fromArray(i.value);break;default:n.uniforms[A].value=i.value}}if(void 0!==t.defines&&(n.defines=t.defines),void 0!==t.vertexShader&&(n.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(n.fragmentShader=t.fragmentShader),void 0!==t.glslVersion&&(n.glslVersion=t.glslVersion),void 0!==t.extensions)for(const A in t.extensions)n.extensions[A]=t.extensions[A];if(void 0!==t.lights&&(n.lights=t.lights),void 0!==t.clipping&&(n.clipping=t.clipping),void 0!==t.size&&(n.size=t.size),void 0!==t.sizeAttenuation&&(n.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(n.map=e(t.map)),void 0!==t.matcap&&(n.matcap=e(t.matcap)),void 0!==t.alphaMap&&(n.alphaMap=e(t.alphaMap)),void 0!==t.bumpMap&&(n.bumpMap=e(t.bumpMap)),void 0!==t.bumpScale&&(n.bumpScale=t.bumpScale),void 0!==t.normalMap&&(n.normalMap=e(t.normalMap)),void 0!==t.normalMapType&&(n.normalMapType=t.normalMapType),void 0!==t.normalScale){let A=t.normalScale;!1===Array.isArray(A)&&(A=[A,A]),n.normalScale=(new $e).fromArray(A)}return void 0!==t.displacementMap&&(n.displacementMap=e(t.displacementMap)),void 0!==t.displacementScale&&(n.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(n.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(n.roughnessMap=e(t.roughnessMap)),void 0!==t.metalnessMap&&(n.metalnessMap=e(t.metalnessMap)),void 0!==t.emissiveMap&&(n.emissiveMap=e(t.emissiveMap)),void 0!==t.emissiveIntensity&&(n.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(n.specularMap=e(t.specularMap)),void 0!==t.specularIntensityMap&&(n.specularIntensityMap=e(t.specularIntensityMap)),void 0!==t.specularColorMap&&(n.specularColorMap=e(t.specularColorMap)),void 0!==t.envMap&&(n.envMap=e(t.envMap)),void 0!==t.envMapRotation&&n.envMapRotation.fromArray(t.envMapRotation),void 0!==t.envMapIntensity&&(n.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(n.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(n.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(n.lightMap=e(t.lightMap)),void 0!==t.lightMapIntensity&&(n.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(n.aoMap=e(t.aoMap)),void 0!==t.aoMapIntensity&&(n.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(n.gradientMap=e(t.gradientMap)),void 0!==t.clearcoatMap&&(n.clearcoatMap=e(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap=e(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(n.clearcoatNormalMap=e(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(n.clearcoatNormalScale=(new $e).fromArray(t.clearcoatNormalScale)),void 0!==t.iridescenceMap&&(n.iridescenceMap=e(t.iridescenceMap)),void 0!==t.iridescenceThicknessMap&&(n.iridescenceThicknessMap=e(t.iridescenceThicknessMap)),void 0!==t.transmissionMap&&(n.transmissionMap=e(t.transmissionMap)),void 0!==t.thicknessMap&&(n.thicknessMap=e(t.thicknessMap)),void 0!==t.anisotropyMap&&(n.anisotropyMap=e(t.anisotropyMap)),void 0!==t.sheenColorMap&&(n.sheenColorMap=e(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(n.sheenRoughnessMap=e(t.sheenRoughnessMap)),n}setTextures(t){return this.textures=t,this}createMaterialFromType(t){return Wc.createMaterialFromType(t)}static createMaterialFromType(t){return new{ShadowMaterial:Gg,SpriteMaterial:Ca,RawShaderMaterial:Ug,ShaderMaterial:Xs,PointsMaterial:jr,MeshPhysicalMaterial:Hg,MeshStandardMaterial:Lg,MeshPhongMaterial:Yg,MeshToonMaterial:Pg,MeshNormalMaterial:Jg,MeshLambertMaterial:qg,MeshDepthMaterial:zg,MeshDistanceMaterial:Og,MeshBasicMaterial:rs,MeshMatcapMaterial:Kg,LineDashedMaterial:Vg,LineBasicMaterial:Tr,Material:as}[t]}}class jc{static extractUrlBase(t){const A=t.lastIndexOf("/");return-1===A?"./":t.slice(0,A+1)}static resolveURL(t,A){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(A)&&/^\//.test(t)&&(A=A.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:A+t)}}class Zc extends Fs{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class Xc extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=this,s=new fc(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,function(e){try{A(i.parse(JSON.parse(e)))}catch(A){n?n(A):console.error(A),i.manager.itemError(t)}},e,n)}parse(t){const A={},e={};function n(t,n){if(void 0!==A[n])return A[n];const i=t.interleavedBuffers[n],s=function(t,A){if(void 0!==e[A])return e[A];const n=t.arrayBuffers[A],i=new Uint32Array(n).buffer;return e[A]=i,i}(t,i.buffer),a=gn(i.type,s),r=new ua(a,i.stride);return r.uuid=i.uuid,A[n]=r,r}const i=t.isInstancedBufferGeometry?new Zc:new Fs,s=t.data.index;if(void 0!==s){const t=gn(s.type,s.array);i.setIndex(new ds(t,1))}const a=t.data.attributes;for(const A in a){const e=a[A];let s;if(e.isInterleavedBufferAttribute){const A=n(t.data,e.data);s=new da(A,e.itemSize,e.offset,e.normalized)}else{const t=gn(e.type,e.array);s=new(e.isInstancedBufferAttribute?Za:ds)(t,e.itemSize,e.normalized)}void 0!==e.name&&(s.name=e.name),void 0!==e.usage&&s.setUsage(e.usage),i.setAttribute(A,s)}const r=t.data.morphAttributes;if(r)for(const A in r){const e=r[A],s=[];for(let A=0,i=e.length;A<i;A++){const i=e[A];let a;if(i.isInterleavedBufferAttribute){const A=n(t.data,i.data);a=new da(A,i.itemSize,i.offset,i.normalized)}else{const t=gn(i.type,i.array);a=new ds(t,i.itemSize,i.normalized)}void 0!==i.name&&(a.name=i.name),s.push(a)}i.morphAttributes[A]=s}t.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const o=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==o)for(let t=0,A=o.length;t!==A;++t){const A=o[t];i.addGroup(A.start,A.count,A.materialIndex)}const g=t.data.boundingSphere;return void 0!==g&&(i.boundingSphere=(new ei).fromJSON(g)),t.name&&(i.name=t.name),t.userData&&(i.userData=t.userData),i}}class $c extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=this,s=""===this.path?jc.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const a=new fc(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(e){let s=null;try{s=JSON.parse(e)}catch(A){return void 0!==n&&n(A),void console.error("THREE:ObjectLoader: Can't parse "+t+".",A.message)}const a=s.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())return void 0!==n&&n(new Error("THREE.ObjectLoader: Can't load "+t)),void console.error("THREE.ObjectLoader: Can't load "+t);i.parse(s,A)},e,n)}async loadAsync(t,A){const e=""===this.path?jc.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||e;const n=new fc(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials);const i=await n.loadAsync(t,A),s=JSON.parse(i),a=s.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(s)}parse(t,A){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,n),s=this.parseImages(t.images,function(){void 0!==A&&A(o)}),a=this.parseTextures(t.textures,s),r=this.parseMaterials(t.materials,a),o=this.parseObject(t.object,i,r,a,e),g=this.parseSkeletons(t.skeletons,o);if(this.bindSkeletons(o,g),this.bindLightTargets(o),void 0!==A){let t=!1;for(const A in s)if(s[A].data instanceof HTMLImageElement){t=!0;break}!1===t&&A(o)}return o}async parseAsync(t){const A=this.parseAnimations(t.animations),e=this.parseShapes(t.shapes),n=this.parseGeometries(t.geometries,e),i=await this.parseImagesAsync(t.images),s=this.parseTextures(t.textures,i),a=this.parseMaterials(t.materials,s),r=this.parseObject(t.object,n,a,s,A),o=this.parseSkeletons(t.skeletons,r);return this.bindSkeletons(r,o),this.bindLightTargets(r),r}parseShapes(t){const A={};if(void 0!==t)for(let e=0,n=t.length;e<n;e++){const n=(new zo).fromJSON(t[e]);A[n.uuid]=n}return A}parseSkeletons(t,A){const e={},n={};if(A.traverse(function(t){t.isBone&&(n[t.uuid]=t)}),void 0!==t)for(let A=0,i=t.length;A<i;A++){const i=(new ja).fromJSON(t[A],n);e[i.uuid]=i}return e}parseGeometries(t,A){const e={};if(void 0!==t){const n=new Xc;for(let i=0,s=t.length;i<s;i++){let s;const a=t[i];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":s=n.parse(a);break;default:a.type in Tg?s=Tg[a.type].fromJSON(a,A):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}s.uuid=a.uuid,void 0!==a.name&&(s.name=a.name),void 0!==a.userData&&(s.userData=a.userData),e[a.uuid]=s}}return e}parseMaterials(t,A){const e={},n={};if(void 0!==t){const i=new Wc;i.setTextures(A);for(let A=0,s=t.length;A<s;A++){const s=t[A];void 0===e[s.uuid]&&(e[s.uuid]=i.parse(s)),n[s.uuid]=e[s.uuid]}}return n}parseAnimations(t){const A={};if(void 0!==t)for(let e=0;e<t.length;e++){const n=t[e],i=hc.parse(n);A[i.uuid]=i}return A}parseImages(t,A){const e=this,n={};let i;function s(t){if("string"==typeof t){const A=t;return function(t){return e.manager.itemStart(t),i.load(t,function(){e.manager.itemEnd(t)},void 0,function(){e.manager.itemError(t),e.manager.itemEnd(t)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(A)?A:e.resourcePath+A)}return t.data?{data:gn(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const e=new dc(A);i=new xc(e),i.setCrossOrigin(this.crossOrigin);for(let A=0,e=t.length;A<e;A++){const e=t[A],i=e.url;if(Array.isArray(i)){const t=[];for(let A=0,e=i.length;A<e;A++){const e=s(i[A]);null!==e&&(e instanceof HTMLImageElement?t.push(e):t.push(new Ka(e.data,e.width,e.height)))}n[e.uuid]=new Sn(t)}else{const t=s(e.url);n[e.uuid]=new Sn(t)}}}return n}async parseImagesAsync(t){const A=this,e={};let n;async function i(t){if("string"==typeof t){const e=t,i=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:A.resourcePath+e;return await n.loadAsync(i)}return t.data?{data:gn(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){n=new xc(this.manager),n.setCrossOrigin(this.crossOrigin);for(let A=0,n=t.length;A<n;A++){const n=t[A],s=n.url;if(Array.isArray(s)){const t=[];for(let A=0,e=s.length;A<e;A++){const e=s[A],n=await i(e);null!==n&&(n instanceof HTMLImageElement?t.push(n):t.push(new Ka(n.data,n.width,n.height)))}e[n.uuid]=new Sn(t)}else{const t=await i(n.url);e[n.uuid]=new Sn(t)}}}return e}parseTextures(t,A){function e(t,A){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),A[t])}const n={};if(void 0!==t)for(let i=0,s=t.length;i<s;i++){const s=t[i];void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===A[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const a=A[s.image],r=a.data;let o;Array.isArray(r)?(o=new aa,6===r.length&&(o.needsUpdate=!0)):(o=r&&r.data?new Ka:new bn,r&&(o.needsUpdate=!0)),o.source=a,o.uuid=s.uuid,void 0!==s.name&&(o.name=s.name),void 0!==s.mapping&&(o.mapping=e(s.mapping,tl)),void 0!==s.channel&&(o.channel=s.channel),void 0!==s.offset&&o.offset.fromArray(s.offset),void 0!==s.repeat&&o.repeat.fromArray(s.repeat),void 0!==s.center&&o.center.fromArray(s.center),void 0!==s.rotation&&(o.rotation=s.rotation),void 0!==s.wrap&&(o.wrapS=e(s.wrap[0],Al),o.wrapT=e(s.wrap[1],Al)),void 0!==s.format&&(o.format=s.format),void 0!==s.internalFormat&&(o.internalFormat=s.internalFormat),void 0!==s.type&&(o.type=s.type),void 0!==s.colorSpace&&(o.colorSpace=s.colorSpace),void 0!==s.minFilter&&(o.minFilter=e(s.minFilter,el)),void 0!==s.magFilter&&(o.magFilter=e(s.magFilter,el)),void 0!==s.anisotropy&&(o.anisotropy=s.anisotropy),void 0!==s.flipY&&(o.flipY=s.flipY),void 0!==s.generateMipmaps&&(o.generateMipmaps=s.generateMipmaps),void 0!==s.premultiplyAlpha&&(o.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(o.unpackAlignment=s.unpackAlignment),void 0!==s.compareFunction&&(o.compareFunction=s.compareFunction),void 0!==s.userData&&(o.userData=s.userData),n[s.uuid]=o}return n}parseObject(t,A,e,n,i){let s,a,r;function o(t){return void 0===A[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),A[t]}function g(t){if(void 0!==t){if(Array.isArray(t)){const A=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];void 0===e[i]&&console.warn("THREE.ObjectLoader: Undefined material",i),A.push(e[i])}return A}return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),e[t]}}function c(t){return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),n[t]}switch(t.type){case"Scene":s=new ha,void 0!==t.background&&(Number.isInteger(t.background)?s.background=new ns(t.background):s.background=c(t.background)),void 0!==t.environment&&(s.environment=c(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?s.fog=new Ia(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(s.fog=new la(t.fog.color,t.fog.density)),""!==t.fog.name&&(s.fog.name=t.fog.name)),void 0!==t.backgroundBlurriness&&(s.backgroundBlurriness=t.backgroundBlurriness),void 0!==t.backgroundIntensity&&(s.backgroundIntensity=t.backgroundIntensity),void 0!==t.backgroundRotation&&s.backgroundRotation.fromArray(t.backgroundRotation),void 0!==t.environmentIntensity&&(s.environmentIntensity=t.environmentIntensity),void 0!==t.environmentRotation&&s.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":s=new na(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(s.focus=t.focus),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.filmGauge&&(s.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(s.filmOffset=t.filmOffset),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"OrthographicCamera":s=new Pc(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"AmbientLight":s=new zc(t.color,t.intensity);break;case"DirectionalLight":s=new qc(t.color,t.intensity),s.target=t.target||"";break;case"PointLight":s=new Yc(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":s=new Oc(t.color,t.intensity,t.width,t.height);break;case"SpotLight":s=new Tc(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay),s.target=t.target||"";break;case"HemisphereLight":s=new bc(t.color,t.groundColor,t.intensity);break;case"LightProbe":s=(new Vc).fromJSON(t);break;case"SkinnedMesh":a=o(t.geometry),r=g(t.material),s=new za(a,r),void 0!==t.bindMode&&(s.bindMode=t.bindMode),void 0!==t.bindMatrix&&s.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(s.skeleton=t.skeleton);break;case"Mesh":a=o(t.geometry),r=g(t.material),s=new zs(a,r);break;case"InstancedMesh":a=o(t.geometry),r=g(t.material);const A=t.count,e=t.instanceMatrix,n=t.instanceColor;s=new sr(a,r,A),s.instanceMatrix=new Za(new Float32Array(e.array),16),void 0!==n&&(s.instanceColor=new Za(new Float32Array(n.array),n.itemSize));break;case"BatchedMesh":a=o(t.geometry),r=g(t.material),s=new kr(t.maxInstanceCount,t.maxVertexCount,t.maxIndexCount,r),s.geometry=a,s.perObjectFrustumCulled=t.perObjectFrustumCulled,s.sortObjects=t.sortObjects,s._drawRanges=t.drawRanges,s._reservedRanges=t.reservedRanges,s._geometryInfo=t.geometryInfo.map(t=>{let A=null,e=null;return void 0!==t.boundingBox&&(A=(new Un).fromJSON(t.boundingBox)),void 0!==t.boundingSphere&&(e=(new ei).fromJSON(t.boundingSphere)),{...t,boundingBox:A,boundingSphere:e}}),s._instanceInfo=t.instanceInfo,s._availableInstanceIds=t._availableInstanceIds,s._availableGeometryIds=t._availableGeometryIds,s._nextIndexStart=t.nextIndexStart,s._nextVertexStart=t.nextVertexStart,s._geometryCount=t.geometryCount,s._maxInstanceCount=t.maxInstanceCount,s._maxVertexCount=t.maxVertexCount,s._maxIndexCount=t.maxIndexCount,s._geometryInitialized=t.geometryInitialized,s._matricesTexture=c(t.matricesTexture.uuid),s._indirectTexture=c(t.indirectTexture.uuid),void 0!==t.colorsTexture&&(s._colorsTexture=c(t.colorsTexture.uuid)),void 0!==t.boundingSphere&&(s.boundingSphere=(new ei).fromJSON(t.boundingSphere)),void 0!==t.boundingBox&&(s.boundingBox=(new Un).fromJSON(t.boundingBox));break;case"LOD":s=new ka;break;case"Line":s=new qr(o(t.geometry),g(t.material));break;case"LineLoop":s=new Wr(o(t.geometry),g(t.material));break;case"LineSegments":s=new Vr(o(t.geometry),g(t.material));break;case"PointCloud":case"Points":s=new Ao(o(t.geometry),g(t.material));break;case"Sprite":s=new _a(g(t.material));break;case"Group":s=new oa;break;case"Bone":s=new Oa;break;default:s=new Ui}if(s.uuid=t.uuid,void 0!==t.name&&(s.name=t.name),void 0!==t.matrix?(s.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(s.matrixAutoUpdate=t.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==t.position&&s.position.fromArray(t.position),void 0!==t.rotation&&s.rotation.fromArray(t.rotation),void 0!==t.quaternion&&s.quaternion.fromArray(t.quaternion),void 0!==t.scale&&s.scale.fromArray(t.scale)),void 0!==t.up&&s.up.fromArray(t.up),void 0!==t.castShadow&&(s.castShadow=t.castShadow),void 0!==t.receiveShadow&&(s.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.intensity&&(s.shadow.intensity=t.shadow.intensity),void 0!==t.shadow.bias&&(s.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(s.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(s.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&s.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(s.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(s.visible=t.visible),void 0!==t.frustumCulled&&(s.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(s.renderOrder=t.renderOrder),void 0!==t.userData&&(s.userData=t.userData),void 0!==t.layers&&(s.layers.mask=t.layers),void 0!==t.children){const a=t.children;for(let t=0;t<a.length;t++)s.add(this.parseObject(a[t],A,e,n,i))}if(void 0!==t.animations){const A=t.animations;for(let t=0;t<A.length;t++){const e=A[t];s.animations.push(i[e])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(s.autoUpdate=t.autoUpdate);const A=t.levels;for(let t=0;t<A.length;t++){const e=A[t],n=s.getObjectByProperty("uuid",e.object);void 0!==n&&s.addLevel(n,e.distance,e.hysteresis)}}return s}bindSkeletons(t,A){0!==Object.keys(A).length&&t.traverse(function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const e=A[t.skeleton];void 0===e?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(e,t.bindMatrix)}})}bindLightTargets(t){t.traverse(function(A){if(A.isDirectionalLight||A.isSpotLight){const e=A.target,n=t.getObjectByProperty("uuid",e);A.target=void 0!==n?n:new Ui}})}}const tl={UVMapping:ct,CubeReflectionMapping:lt,CubeRefractionMapping:It,EquirectangularReflectionMapping:ht,EquirectangularRefractionMapping:ut,CubeUVReflectionMapping:Bt},Al={RepeatWrapping:dt,ClampToEdgeWrapping:Ct,MirroredRepeatWrapping:Et},el={NearestFilter:Qt,NearestMipmapNearestFilter:pt,NearestMipmapLinearFilter:mt,LinearFilter:wt,LinearMipmapNearestFilter:xt,LinearMipmapLinearFilter:Dt},nl=new WeakMap;class il extends Ec{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,A,e,n){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=Bc.get(`image-bitmap:${t}`);if(void 0!==s)return i.manager.itemStart(t),s.then?void s.then(e=>{if(!0!==nl.has(s))return A&&A(e),i.manager.itemEnd(t),e;n&&n(nl.get(s)),i.manager.itemError(t),i.manager.itemEnd(t)}):(setTimeout(function(){A&&A(s),i.manager.itemEnd(t)},0),s);const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader;const r=fetch(t,a).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(e){return Bc.add(`image-bitmap:${t}`,e),A&&A(e),i.manager.itemEnd(t),e}).catch(function(A){n&&n(A),nl.set(r,A),Bc.remove(`image-bitmap:${t}`),i.manager.itemError(t),i.manager.itemEnd(t)});Bc.add(`image-bitmap:${t}`,r),i.manager.itemStart(t)}}let sl;class al{static getContext(){return void 0===sl&&(sl=new(window.AudioContext||window.webkitAudioContext)),sl}static setContext(t){sl=t}}class rl extends Ec{constructor(t){super(t)}load(t,A,e,n){const i=this,s=new fc(this.manager);function a(A){n?n(A):console.error(A),i.manager.itemError(t)}s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(t){try{const e=t.slice(0);al.getContext().decodeAudioData(e,function(t){A(t)}).catch(a)}catch(t){a(t)}},e,n)}}const ol=new li,gl=new li,cl=new li;class ll{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new na,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new na,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const A=this._cache;if(A.focus!==t.focus||A.fov!==t.fov||A.aspect!==t.aspect*this.aspect||A.near!==t.near||A.far!==t.far||A.zoom!==t.zoom||A.eyeSep!==this.eyeSep){A.focus=t.focus,A.fov=t.fov,A.aspect=t.aspect*this.aspect,A.near=t.near,A.far=t.far,A.zoom=t.zoom,A.eyeSep=this.eyeSep,cl.copy(t.projectionMatrix);const e=A.eyeSep/2,n=e*A.near/A.focus,i=A.near*Math.tan(qe*A.fov*.5)/A.zoom;let s,a;gl.elements[12]=-e,ol.elements[12]=e,s=-i*A.aspect+n,a=i*A.aspect+n,cl.elements[0]=2*A.near/(a-s),cl.elements[8]=(a+s)/(a-s),this.cameraL.projectionMatrix.copy(cl),s=-i*A.aspect-n,a=i*A.aspect-n,cl.elements[0]=2*A.near/(a-s),cl.elements[8]=(a+s)/(a-s),this.cameraR.projectionMatrix.copy(cl)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(gl),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(ol)}}class Il extends na{constructor(t=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=t}}class hl{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const A=performance.now();t=(A-this.oldTime)/1e3,this.oldTime=A,this.elapsedTime+=t}return t}}const ul=new An,Bl=new tn,dl=new An,Cl=new An,El=new An;class Ql extends Ui{constructor(){super(),this.type="AudioListener",this.context=al.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new hl}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const A=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(ul,Bl,dl),Cl.set(0,0,-1).applyQuaternion(Bl),El.set(0,1,0).applyQuaternion(Bl),A.positionX){const t=this.context.currentTime+this.timeDelta;A.positionX.linearRampToValueAtTime(ul.x,t),A.positionY.linearRampToValueAtTime(ul.y,t),A.positionZ.linearRampToValueAtTime(ul.z,t),A.forwardX.linearRampToValueAtTime(Cl.x,t),A.forwardY.linearRampToValueAtTime(Cl.y,t),A.forwardZ.linearRampToValueAtTime(Cl.z,t),A.upX.linearRampToValueAtTime(El.x,t),A.upY.linearRampToValueAtTime(El.y,t),A.upZ.linearRampToValueAtTime(El.z,t)}else A.setPosition(ul.x,ul.y,ul.z),A.setOrientation(Cl.x,Cl.y,Cl.z,El.x,El.y,El.z)}}class pl extends Ui{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const A=this.context.createBufferSource();return A.buffer=this.buffer,A.loop=this.loop,A.loopStart=this.loopStart,A.loopEnd=this.loopEnd,A.onended=this.onEnded.bind(this),A.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=A,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(t=0){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(this.context.currentTime+t),this.source.onended=null),this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,A=this.filters.length;t<A;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,A=this.filters.length;t<A;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){return this.detune=t,!0===this.isPlaying&&void 0!==this.source.detune&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}copy(t,A){return super.copy(t,A),"buffer"!==t.sourceType?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=t.autoplay,this.buffer=t.buffer,this.detune=t.detune,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.offset=t.offset,this.duration=t.duration,this.playbackRate=t.playbackRate,this.hasPlaybackControl=t.hasPlaybackControl,this.sourceType=t.sourceType,this.filters=t.filters.slice(),this)}clone(t){return new this.constructor(this.listener).copy(this,t)}}const fl=new An,ml=new tn,yl=new An,wl=new An;class xl extends pl{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,A,e){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=A,this.panner.coneOuterGain=e,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(fl,ml,yl),wl.set(0,0,1).applyQuaternion(ml);const A=this.panner;if(A.positionX){const t=this.context.currentTime+this.listener.timeDelta;A.positionX.linearRampToValueAtTime(fl.x,t),A.positionY.linearRampToValueAtTime(fl.y,t),A.positionZ.linearRampToValueAtTime(fl.z,t),A.orientationX.linearRampToValueAtTime(wl.x,t),A.orientationY.linearRampToValueAtTime(wl.y,t),A.orientationZ.linearRampToValueAtTime(wl.z,t)}else A.setPosition(fl.x,fl.y,fl.z),A.setOrientation(wl.x,wl.y,wl.z)}}class Sl{constructor(t,A=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=A,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const A=this.getFrequencyData();for(let e=0;e<A.length;e++)t+=A[e];return t/A.length}}class Dl{constructor(t,A,e){let n,i,s;switch(this.binding=t,this.valueSize=e,A){case"quaternion":n=this._slerp,i=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*e),this._workIndex=5;break;case"string":case"bool":n=this._select,i=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*e);break;default:n=this._lerp,i=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*e)}this._mixBufferRegion=n,this._mixBufferRegionAdditive=i,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,A){const e=this.buffer,n=this.valueSize,i=t*n+n;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==n;++t)e[i+t]=e[t];s=A}else{s+=A;const t=A/s;this._mixBufferRegion(e,i,0,t,n)}this.cumulativeWeight=s}accumulateAdditive(t){const A=this.buffer,e=this.valueSize,n=e*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(A,n,0,t,e),this.cumulativeWeightAdditive+=t}apply(t){const A=this.valueSize,e=this.buffer,n=t*A+A,i=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const t=A*this._origIndex;this._mixBufferRegion(e,n,t,1-i,A)}s>0&&this._mixBufferRegionAdditive(e,n,this._addIndex*A,1,A);for(let t=A,i=A+A;t!==i;++t)if(e[t]!==e[t+A]){a.setValue(e,n);break}}saveOriginalState(){const t=this.binding,A=this.buffer,e=this.valueSize,n=e*this._origIndex;t.getValue(A,n);for(let t=e,i=n;t!==i;++t)A[t]=A[n+t%e];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,A=t+this.valueSize;for(let e=t;e<A;e++)this.buffer[e]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,A=this._addIndex*this.valueSize;for(let e=0;e<this.valueSize;e++)this.buffer[A+e]=this.buffer[t+e]}_select(t,A,e,n,i){if(n>=.5)for(let n=0;n!==i;++n)t[A+n]=t[e+n]}_slerp(t,A,e,n){tn.slerpFlat(t,A,t,A,t,e,n)}_slerpAdditive(t,A,e,n,i){const s=this._workIndex*i;tn.multiplyQuaternionsFlat(t,s,t,A,t,e),tn.slerpFlat(t,A,t,A,t,s,n)}_lerp(t,A,e,n,i){const s=1-n;for(let a=0;a!==i;++a){const i=A+a;t[i]=t[i]*s+t[e+a]*n}}_lerpAdditive(t,A,e,n,i){for(let s=0;s!==i;++s){const i=A+s;t[i]=t[i]+t[e+s]*n}}}const vl="\\[\\]\\.:\\/",Ml=new RegExp("["+vl+"]","g"),bl="[^"+vl+"]",_l="[^"+vl.replace("\\.","")+"]",Rl=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",bl)+/(WCOD+)?/.source.replace("WCOD",_l)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",bl)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",bl)+"$"),Fl=["material","materials","bones","map"];class Nl{constructor(t,A,e){this.path=A,this.parsedPath=e||Nl.parseTrackName(A),this.node=Nl.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,A,e){return t&&t.isAnimationObjectGroup?new Nl.Composite(t,A,e):new Nl(t,A,e)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Ml,"")}static parseTrackName(t){const A=Rl.exec(t);if(null===A)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const e={nodeName:A[2],objectName:A[3],objectIndex:A[4],propertyName:A[5],propertyIndex:A[6]},n=e.nodeName&&e.nodeName.lastIndexOf(".");if(void 0!==n&&-1!==n){const t=e.nodeName.substring(n+1);-1!==Fl.indexOf(t)&&(e.nodeName=e.nodeName.substring(0,n),e.objectName=t)}if(null===e.propertyName||0===e.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return e}static findNode(t,A){if(void 0===A||""===A||"."===A||-1===A||A===t.name||A===t.uuid)return t;if(t.skeleton){const e=t.skeleton.getBoneByName(A);if(void 0!==e)return e}if(t.children){const e=function(t){for(let n=0;n<t.length;n++){const i=t[n];if(i.name===A||i.uuid===A)return i;const s=e(i.children);if(s)return s}return null},n=e(t.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,A){t[A]=this.targetObject[this.propertyName]}_getValue_array(t,A){const e=this.resolvedProperty;for(let n=0,i=e.length;n!==i;++n)t[A++]=e[n]}_getValue_arrayElement(t,A){t[A]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,A){this.resolvedProperty.toArray(t,A)}_setValue_direct(t,A){this.targetObject[this.propertyName]=t[A]}_setValue_direct_setNeedsUpdate(t,A){this.targetObject[this.propertyName]=t[A],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,A){this.targetObject[this.propertyName]=t[A],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,A){const e=this.resolvedProperty;for(let n=0,i=e.length;n!==i;++n)e[n]=t[A++]}_setValue_array_setNeedsUpdate(t,A){const e=this.resolvedProperty;for(let n=0,i=e.length;n!==i;++n)e[n]=t[A++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,A){const e=this.resolvedProperty;for(let n=0,i=e.length;n!==i;++n)e[n]=t[A++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,A){this.resolvedProperty[this.propertyIndex]=t[A]}_setValue_arrayElement_setNeedsUpdate(t,A){this.resolvedProperty[this.propertyIndex]=t[A],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,A){this.resolvedProperty[this.propertyIndex]=t[A],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,A){this.resolvedProperty.fromArray(t,A)}_setValue_fromArray_setNeedsUpdate(t,A){this.resolvedProperty.fromArray(t,A),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,A){this.resolvedProperty.fromArray(t,A),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,A){this.bind(),this.getValue(t,A)}_setValue_unbound(t,A){this.bind(),this.setValue(t,A)}bind(){let t=this.node;const A=this.parsedPath,e=A.objectName,n=A.propertyName;let i=A.propertyIndex;if(t||(t=Nl.findNode(this.rootNode,A.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");if(e){let n=A.objectIndex;switch(e){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let A=0;A<t.length;A++)if(t[A].name===n){n=A;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);t=t.material.map;break;default:if(void 0===t[e])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[e]}if(void 0!==n){if(void 0===t[n])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[n]}}const s=t[n];if(void 0===s){const e=A.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+e+"."+n+" but it wasn't found.",t)}let a=this.Versioning.None;this.targetObject=t,!0===t.isMaterial?a=this.Versioning.NeedsUpdate:!0===t.isObject3D&&(a=this.Versioning.MatrixWorldNeedsUpdate);let r=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===n){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[i]&&(i=t.morphTargetDictionary[i])}r=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else void 0!==s.fromArray&&void 0!==s.toArray?(r=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(r=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=n;this.getValue=this.GetterByBindingType[r],this.setValue=this.SetterByBindingTypeAndVersioning[r][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Nl.Composite=class{constructor(t,A,e){const n=e||Nl.parseTrackName(A);this._targetGroup=t,this._bindings=t.subscribe_(A,n)}getValue(t,A){this.bind();const e=this._targetGroup.nCachedObjects_,n=this._bindings[e];void 0!==n&&n.getValue(t,A)}setValue(t,A){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,i=e.length;n!==i;++n)e[n].setValue(t,A)}bind(){const t=this._bindings;for(let A=this._targetGroup.nCachedObjects_,e=t.length;A!==e;++A)t[A].bind()}unbind(){const t=this._bindings;for(let A=this._targetGroup.nCachedObjects_,e=t.length;A!==e;++A)t[A].unbind()}},Nl.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Nl.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Nl.prototype.GetterByBindingType=[Nl.prototype._getValue_direct,Nl.prototype._getValue_array,Nl.prototype._getValue_arrayElement,Nl.prototype._getValue_toArray],Nl.prototype.SetterByBindingTypeAndVersioning=[[Nl.prototype._setValue_direct,Nl.prototype._setValue_direct_setNeedsUpdate,Nl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Nl.prototype._setValue_array,Nl.prototype._setValue_array_setNeedsUpdate,Nl.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Nl.prototype._setValue_arrayElement,Nl.prototype._setValue_arrayElement_setNeedsUpdate,Nl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Nl.prototype._setValue_fromArray,Nl.prototype._setValue_fromArray_setNeedsUpdate,Nl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class kl{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Oe(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let A=0,e=arguments.length;A!==e;++A)t[arguments[A].uuid]=A;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const A=this;this.stats={objects:{get total(){return A._objects.length},get inUse(){return this.total-A.nCachedObjects_}},get bindingsPerObject(){return A._bindings.length}}}add(){const t=this._objects,A=this._indicesByUUID,e=this._paths,n=this._parsedPaths,i=this._bindings,s=i.length;let a,r=t.length,o=this.nCachedObjects_;for(let g=0,c=arguments.length;g!==c;++g){const c=arguments[g],l=c.uuid;let I=A[l];if(void 0===I){I=r++,A[l]=I,t.push(c);for(let t=0,A=s;t!==A;++t)i[t].push(new Nl(c,e[t],n[t]))}else if(I<o){a=t[I];const r=--o,g=t[r];A[g.uuid]=I,t[I]=g,A[l]=r,t[r]=c;for(let t=0,A=s;t!==A;++t){const A=i[t],s=A[r];let a=A[I];A[I]=s,void 0===a&&(a=new Nl(c,e[t],n[t])),A[r]=a}}else t[I]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=o}remove(){const t=this._objects,A=this._indicesByUUID,e=this._bindings,n=e.length;let i=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s],r=a.uuid,o=A[r];if(void 0!==o&&o>=i){const s=i++,g=t[s];A[g.uuid]=o,t[o]=g,A[r]=s,t[s]=a;for(let t=0,A=n;t!==A;++t){const A=e[t],n=A[s],i=A[o];A[o]=n,A[s]=i}}}this.nCachedObjects_=i}uncache(){const t=this._objects,A=this._indicesByUUID,e=this._bindings,n=e.length;let i=this.nCachedObjects_,s=t.length;for(let a=0,r=arguments.length;a!==r;++a){const r=arguments[a].uuid,o=A[r];if(void 0!==o)if(delete A[r],o<i){const a=--i,r=t[a],g=--s,c=t[g];A[r.uuid]=o,t[o]=r,A[c.uuid]=a,t[a]=c,t.pop();for(let t=0,A=n;t!==A;++t){const A=e[t],n=A[a],i=A[g];A[o]=n,A[a]=i,A.pop()}}else{const i=--s,a=t[i];i>0&&(A[a.uuid]=o),t[o]=a,t.pop();for(let t=0,A=n;t!==A;++t){const A=e[t];A[o]=A[i],A.pop()}}}this.nCachedObjects_=i}subscribe_(t,A){const e=this._bindingsIndicesByPath;let n=e[t];const i=this._bindings;if(void 0!==n)return i[n];const s=this._paths,a=this._parsedPaths,r=this._objects,o=r.length,g=this.nCachedObjects_,c=new Array(o);n=i.length,e[t]=n,s.push(t),a.push(A),i.push(c);for(let e=g,n=r.length;e!==n;++e){const n=r[e];c[e]=new Nl(n,t,A)}return c}unsubscribe_(t){const A=this._bindingsIndicesByPath,e=A[t];if(void 0!==e){const n=this._paths,i=this._parsedPaths,s=this._bindings,a=s.length-1,r=s[a];A[t[a]]=e,s[e]=r,s.pop(),i[e]=i[a],i.pop(),n[e]=n[a],n.pop()}}}class Tl{constructor(t,A,e=null,n=A.blendMode){this._mixer=t,this._clip=A,this._localRoot=e,this.blendMode=n;const i=A.tracks,s=i.length,a=new Array(s),r={endingStart:TA,endingEnd:TA};for(let t=0;t!==s;++t){const A=i[t].createInterpolant(null);a[t]=A,A.settings=r}this._interpolantSettings=r,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=_A,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,A){return this.loop=t,this.repetitions=A,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,A,e=!1){if(t.fadeOut(A),this.fadeIn(A),!0===e){const e=this._clip.duration,n=t._clip.duration,i=n/e,s=e/n;t.warp(1,i,A),this.warp(s,1,A)}return this}crossFadeTo(t,A,e=!1){return t.crossFadeFrom(this,A,e)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,A,e){const n=this._mixer,i=n.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=n._lendControlInterpolant(),this._timeScaleInterpolant=a);const r=a.parameterPositions,o=a.sampleValues;return r[0]=i,r[1]=i+e,o[0]=t/s,o[1]=A/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,A,e,n){if(!this.enabled)return void this._updateWeight(t);const i=this._startTime;if(null!==i){const n=(t-i)*e;n<0||0===e?A=0:(this._startTime=null,A=e*n)}A*=this._updateTimeScale(t);const s=this._updateTime(A),a=this._updateWeight(t);if(a>0){const t=this._interpolants,A=this._propertyBindings;if(this.blendMode===HA)for(let e=0,n=t.length;e!==n;++e)t[e].evaluate(s),A[e].accumulateAdditive(a);else for(let e=0,i=t.length;e!==i;++e)t[e].evaluate(s),A[e].accumulate(n,a)}}_updateWeight(t){let A=0;if(this.enabled){A=this.weight;const e=this._weightInterpolant;if(null!==e){const n=e.evaluate(t)[0];A*=n,t>e.parameterPositions[1]&&(this.stopFading(),0===n&&(this.enabled=!1))}}return this._effectiveWeight=A,A}_updateTimeScale(t){let A=0;if(!this.paused){A=this.timeScale;const e=this._timeScaleInterpolant;null!==e&&(A*=e.evaluate(t)[0],t>e.parameterPositions[1]&&(this.stopWarping(),0===A?this.paused=!0:this.timeScale=A))}return this._effectiveTimeScale=A,A}_updateTime(t){const A=this._clip.duration,e=this.loop;let n=this.time+t,i=this._loopCount;const s=e===RA;if(0===t)return-1===i||!s||1&~i?n:A-n;if(e===bA){-1===i&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(n>=A)n=A;else{if(!(n<0)){this.time=n;break t}n=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===i&&(t>=0?(i=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),n>=A||n<0){const e=Math.floor(n/A);n-=A*e,i+=Math.abs(e);const a=this.repetitions-i;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,n=t>0?A:0,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===a){const A=t<0;this._setEndings(A,!A,s)}else this._setEndings(!1,!1,s);this._loopCount=i,this.time=n,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:e})}}else this.time=n;if(s&&!(1&~i))return A-n}return n}_setEndings(t,A,e){const n=this._interpolantSettings;e?(n.endingStart=GA,n.endingEnd=GA):(n.endingStart=t?this.zeroSlopeAtStart?GA:TA:UA,n.endingEnd=A?this.zeroSlopeAtEnd?GA:TA:UA)}_scheduleFading(t,A,e){const n=this._mixer,i=n.time;let s=this._weightInterpolant;null===s&&(s=n._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,r=s.sampleValues;return a[0]=i,r[0]=A,a[1]=i+t,r[1]=e,this}}const Gl=new Float32Array(1);class Ul extends Ye{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,A){const e=t._localRoot||this._root,n=t._clip.tracks,i=n.length,s=t._propertyBindings,a=t._interpolants,r=e.uuid,o=this._bindingsByRootAndName;let g=o[r];void 0===g&&(g={},o[r]=g);for(let t=0;t!==i;++t){const i=n[t],o=i.name;let c=g[o];if(void 0!==c)++c.referenceCount,s[t]=c;else{if(c=s[t],void 0!==c){null===c._cacheIndex&&(++c.referenceCount,this._addInactiveBinding(c,r,o));continue}const n=A&&A._propertyBindings[t].binding.parsedPath;c=new Dl(Nl.create(e,o,n),i.ValueTypeName,i.getValueSize()),++c.referenceCount,this._addInactiveBinding(c,r,o),s[t]=c}a[t].resultBuffer=c.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const A=(t._localRoot||this._root).uuid,e=t._clip.uuid,n=this._actionsByClip[e];this._bindAction(t,n&&n.knownActions[0]),this._addInactiveAction(t,e,A)}const A=t._propertyBindings;for(let t=0,e=A.length;t!==e;++t){const e=A[t];0===e.useCount++&&(this._lendBinding(e),e.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const A=t._propertyBindings;for(let t=0,e=A.length;t!==e;++t){const e=A[t];0===--e.useCount&&(e.restoreOriginalState(),this._takeBackBinding(e))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const A=t._cacheIndex;return null!==A&&A<this._nActiveActions}_addInactiveAction(t,A,e){const n=this._actions,i=this._actionsByClip;let s=i[A];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,i[A]=s;else{const A=s.knownActions;t._byClipCacheIndex=A.length,A.push(t)}t._cacheIndex=n.length,n.push(t),s.actionByRoot[e]=t}_removeInactiveAction(t){const A=this._actions,e=A[A.length-1],n=t._cacheIndex;e._cacheIndex=n,A[n]=e,A.pop(),t._cacheIndex=null;const i=t._clip.uuid,s=this._actionsByClip,a=s[i],r=a.knownActions,o=r[r.length-1],g=t._byClipCacheIndex;o._byClipCacheIndex=g,r[g]=o,r.pop(),t._byClipCacheIndex=null,delete a.actionByRoot[(t._localRoot||this._root).uuid],0===r.length&&delete s[i],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const A=t._propertyBindings;for(let t=0,e=A.length;t!==e;++t){const e=A[t];0===--e.referenceCount&&this._removeInactiveBinding(e)}}_lendAction(t){const A=this._actions,e=t._cacheIndex,n=this._nActiveActions++,i=A[n];t._cacheIndex=n,A[n]=t,i._cacheIndex=e,A[e]=i}_takeBackAction(t){const A=this._actions,e=t._cacheIndex,n=--this._nActiveActions,i=A[n];t._cacheIndex=n,A[n]=t,i._cacheIndex=e,A[e]=i}_addInactiveBinding(t,A,e){const n=this._bindingsByRootAndName,i=this._bindings;let s=n[A];void 0===s&&(s={},n[A]=s),s[e]=t,t._cacheIndex=i.length,i.push(t)}_removeInactiveBinding(t){const A=this._bindings,e=t.binding,n=e.rootNode.uuid,i=e.path,s=this._bindingsByRootAndName,a=s[n],r=A[A.length-1],o=t._cacheIndex;r._cacheIndex=o,A[o]=r,A.pop(),delete a[i],0===Object.keys(a).length&&delete s[n]}_lendBinding(t){const A=this._bindings,e=t._cacheIndex,n=this._nActiveBindings++,i=A[n];t._cacheIndex=n,A[n]=t,i._cacheIndex=e,A[e]=i}_takeBackBinding(t){const A=this._bindings,e=t._cacheIndex,n=--this._nActiveBindings,i=A[n];t._cacheIndex=n,A[n]=t,i._cacheIndex=e,A[e]=i}_lendControlInterpolant(){const t=this._controlInterpolants,A=this._nActiveControlInterpolants++;let e=t[A];return void 0===e&&(e=new nc(new Float32Array(2),new Float32Array(2),1,Gl),e.__cacheIndex=A,t[A]=e),e}_takeBackControlInterpolant(t){const A=this._controlInterpolants,e=t.__cacheIndex,n=--this._nActiveControlInterpolants,i=A[n];t.__cacheIndex=n,A[n]=t,i.__cacheIndex=e,A[e]=i}clipAction(t,A,e){const n=A||this._root,i=n.uuid;let s="string"==typeof t?hc.findByName(n,t):t;const a=null!==s?s.uuid:t,r=this._actionsByClip[a];let o=null;if(void 0===e&&(e=null!==s?s.blendMode:LA),void 0!==r){const t=r.actionByRoot[i];if(void 0!==t&&t.blendMode===e)return t;o=r.knownActions[0],null===s&&(s=o._clip)}if(null===s)return null;const g=new Tl(this,s,A,e);return this._bindAction(g,o),this._addInactiveAction(g,a,i),g}existingAction(t,A){const e=A||this._root,n=e.uuid,i="string"==typeof t?hc.findByName(e,t):t,s=i?i.uuid:t,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[n]||null}stopAllAction(){const t=this._actions;for(let A=this._nActiveActions-1;A>=0;--A)t[A].stop();return this}update(t){t*=this.timeScale;const A=this._actions,e=this._nActiveActions,n=this.time+=t,i=Math.sign(t),s=this._accuIndex^=1;for(let a=0;a!==e;++a)A[a]._update(n,t,i,s);const a=this._bindings,r=this._nActiveBindings;for(let t=0;t!==r;++t)a[t].apply(s);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const A=this._actions,e=t.uuid,n=this._actionsByClip,i=n[e];if(void 0!==i){const t=i.knownActions;for(let e=0,n=t.length;e!==n;++e){const n=t[e];this._deactivateAction(n);const i=n._cacheIndex,s=A[A.length-1];n._cacheIndex=null,n._byClipCacheIndex=null,s._cacheIndex=i,A[i]=s,A.pop(),this._removeInactiveBindingsForAction(n)}delete n[e]}}uncacheRoot(t){const A=t.uuid,e=this._actionsByClip;for(const t in e){const n=e[t].actionByRoot[A];void 0!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}const n=this._bindingsByRootAndName[A];if(void 0!==n)for(const t in n){const A=n[t];A.restoreOriginalState(),this._removeInactiveBinding(A)}}uncacheAction(t,A){const e=this.existingAction(t,A);null!==e&&(this._deactivateAction(e),this._removeInactiveAction(e))}}class Ll extends Rn{constructor(t=1,A=1,e=1,n={}){super(t,A,n),this.isRenderTarget3D=!0,this.depth=e,this.texture=new Tn(null,t,A,e),this._setTextureOptions(n),this.texture.isRenderTargetTexture=!0}}class Hl{constructor(t){this.value=t}clone(){return new Hl(void 0===this.value.clone?this.value:this.value.clone())}}let Yl=0;class Pl extends Ye{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Yl++}),this.name="",this.usage=xe,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const A=this.uniforms.indexOf(t);return-1!==A&&this.uniforms.splice(A,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(t){this.name=t.name,this.usage=t.usage;const A=t.uniforms;this.uniforms.length=0;for(let t=0,e=A.length;t<e;t++){const e=Array.isArray(A[t])?A[t]:[A[t]];for(let t=0;t<e.length;t++)this.uniforms.push(e[t].clone())}return this}clone(){return(new this.constructor).copy(this)}}class Jl extends ua{constructor(t,A,e=1){super(t,A),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=e}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const A=super.clone(t);return A.meshPerAttribute=this.meshPerAttribute,A}toJSON(t){const A=super.toJSON(t);return A.isInstancedInterleavedBuffer=!0,A.meshPerAttribute=this.meshPerAttribute,A}}class ql{constructor(t,A,e,n,i,s=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=A,this.itemSize=e,this.elementSize=n,this.count=i,this.normalized=s,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,A){return this.type=t,this.elementSize=A,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}const zl=new li;class Ol{constructor(t,A,e=0,n=1/0){this.ray=new ci(t,A),this.near=e,this.far=n,this.camera=null,this.layers=new mi,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,A){this.ray.set(t,A)}setFromCamera(t,A){A.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(A.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(A).sub(this.ray.origin).normalize(),this.camera=A):A.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(A.near+A.far)/(A.near-A.far)).unproject(A),this.ray.direction.set(0,0,-1).transformDirection(A.matrixWorld),this.camera=A):console.error("THREE.Raycaster: Unsupported camera type: "+A.type)}setFromXRController(t){return zl.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(zl),this}intersectObject(t,A=!0,e=[]){return Vl(t,this,e,A),e.sort(Kl),e}intersectObjects(t,A=!0,e=[]){for(let n=0,i=t.length;n<i;n++)Vl(t[n],this,e,A);return e.sort(Kl),e}}function Kl(t,A){return t.distance-A.distance}function Vl(t,A,e,n){let i=!0;if(t.layers.test(A.layers)&&!1===t.raycast(A,e)&&(i=!1),!0===i&&!0===n){const n=t.children;for(let t=0,i=n.length;t<i;t++)Vl(n[t],A,e,!0)}}class Wl{constructor(t=1,A=0,e=0){this.radius=t,this.phi=A,this.theta=e}set(t,A,e){return this.radius=t,this.phi=A,this.theta=e,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Ke(this.phi,t,Math.PI-t),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,A,e){return this.radius=Math.sqrt(t*t+A*A+e*e),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,e),this.phi=Math.acos(Ke(A/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class jl{constructor(t=1,A=0,e=0){this.radius=t,this.theta=A,this.y=e}set(t,A,e){return this.radius=t,this.theta=A,this.y=e,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,A,e){return this.radius=Math.sqrt(t*t+e*e),this.theta=Math.atan2(t,e),this.y=A,this}clone(){return(new this.constructor).copy(this)}}class Zl{constructor(t,A,e,n){Zl.prototype.isMatrix2=!0,this.elements=[1,0,0,1],void 0!==t&&this.set(t,A,e,n)}identity(){return this.set(1,0,0,1),this}fromArray(t,A=0){for(let e=0;e<4;e++)this.elements[e]=t[e+A];return this}set(t,A,e,n){const i=this.elements;return i[0]=t,i[2]=A,i[1]=e,i[3]=n,this}}const Xl=new $e;class $l{constructor(t=new $e(1/0,1/0),A=new $e(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=A}set(t,A){return this.min.copy(t),this.max.copy(A),this}setFromPoints(t){this.makeEmpty();for(let A=0,e=t.length;A<e;A++)this.expandByPoint(t[A]);return this}setFromCenterAndSize(t,A){const e=Xl.copy(A).multiplyScalar(.5);return this.min.copy(t).sub(e),this.max.copy(t).add(e),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,A){return A.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y}clampPoint(t,A){return A.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Xl).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const tI=new An,AI=new An;class eI{constructor(t=new An,A=new An){this.start=t,this.end=A}set(t,A){return this.start.copy(t),this.end.copy(A),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,A){return this.delta(A).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,A){tI.subVectors(t,this.start),AI.subVectors(this.end,this.start);const e=AI.dot(AI);let n=AI.dot(tI)/e;return A&&(n=Ke(n,0,1)),n}closestPointToPoint(t,A,e){const n=this.closestPointToPointParameter(t,A);return this.delta(e).multiplyScalar(n).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const nI=new An;class iI extends Ui{constructor(t,A){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=A,this.type="SpotLightHelper";const e=new Fs,n=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,A=1,e=32;t<e;t++,A++){const i=t/e*Math.PI*2,s=A/e*Math.PI*2;n.push(Math.cos(i),Math.sin(i),1,Math.cos(s),Math.sin(s),1)}e.setAttribute("position",new xs(n,3));const i=new Tr({fog:!1,toneMapped:!1});this.cone=new Vr(e,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,A=t*Math.tan(this.light.angle);this.cone.scale.set(A,A,t),nI.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(nI),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const sI=new An,aI=new li,rI=new li;class oI extends Vr{constructor(t){const A=gI(t),e=new Fs,n=[],i=[],s=new ns(0,0,1),a=new ns(0,1,0);for(let t=0;t<A.length;t++){const e=A[t];e.parent&&e.parent.isBone&&(n.push(0,0,0),n.push(0,0,0),i.push(s.r,s.g,s.b),i.push(a.r,a.g,a.b))}e.setAttribute("position",new xs(n,3)),e.setAttribute("color",new xs(i,3)),super(e,new Tr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=A,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const A=this.bones,e=this.geometry,n=e.getAttribute("position");rI.copy(this.root.matrixWorld).invert();for(let t=0,e=0;t<A.length;t++){const i=A[t];i.parent&&i.parent.isBone&&(aI.multiplyMatrices(rI,i.matrixWorld),sI.setFromMatrixPosition(aI),n.setXYZ(e,sI.x,sI.y,sI.z),aI.multiplyMatrices(rI,i.parent.matrixWorld),sI.setFromMatrixPosition(aI),n.setXYZ(e+1,sI.x,sI.y,sI.z),e+=2)}e.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose()}}function gI(t){const A=[];!0===t.isBone&&A.push(t);for(let e=0;e<t.children.length;e++)A.push(...gI(t.children[e]));return A}class cI extends zs{constructor(t,A,e){super(new Mg(A,4,2),new rs({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=e,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const lI=new An,II=new ns,hI=new ns;class uI extends Ui{constructor(t,A,e){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e,this.type="HemisphereLightHelper";const n=new xg(A);n.rotateY(.5*Math.PI),this.material=new rs({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const i=n.getAttribute("position"),s=new Float32Array(3*i.count);n.setAttribute("color",new ds(s,3)),this.add(new zs(n,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const A=t.geometry.getAttribute("color");II.copy(this.light.color),hI.copy(this.light.groundColor);for(let t=0,e=A.count;t<e;t++){const n=t<e/2?II:hI;A.setXYZ(t,n.r,n.g,n.b)}A.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),t.lookAt(lI.setFromMatrixPosition(this.light.matrixWorld).negate())}}class BI extends Vr{constructor(t=10,A=10,e=4473924,n=8947848){e=new ns(e),n=new ns(n);const i=A/2,s=t/A,a=t/2,r=[],o=[];for(let t=0,g=0,c=-a;t<=A;t++,c+=s){r.push(-a,0,c,a,0,c),r.push(c,0,-a,c,0,a);const A=t===i?e:n;A.toArray(o,g),g+=3,A.toArray(o,g),g+=3,A.toArray(o,g),g+=3,A.toArray(o,g),g+=3}const g=new Fs;g.setAttribute("position",new xs(r,3)),g.setAttribute("color",new xs(o,3)),super(g,new Tr({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class dI extends Vr{constructor(t=10,A=16,e=8,n=64,i=4473924,s=8947848){i=new ns(i),s=new ns(s);const a=[],r=[];if(A>1)for(let e=0;e<A;e++){const n=e/A*(2*Math.PI),o=Math.sin(n)*t,g=Math.cos(n)*t;a.push(0,0,0),a.push(o,0,g);const c=1&e?i:s;r.push(c.r,c.g,c.b),r.push(c.r,c.g,c.b)}for(let A=0;A<e;A++){const o=1&A?i:s,g=t-t/e*A;for(let t=0;t<n;t++){let A=t/n*(2*Math.PI),e=Math.sin(A)*g,i=Math.cos(A)*g;a.push(e,0,i),r.push(o.r,o.g,o.b),A=(t+1)/n*(2*Math.PI),e=Math.sin(A)*g,i=Math.cos(A)*g,a.push(e,0,i),r.push(o.r,o.g,o.b)}}const o=new Fs;o.setAttribute("position",new xs(a,3)),o.setAttribute("color",new xs(r,3)),super(o,new Tr({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const CI=new An,EI=new An,QI=new An;class pI extends Ui{constructor(t,A,e){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e,this.type="DirectionalLightHelper",void 0===A&&(A=1);let n=new Fs;n.setAttribute("position",new xs([-A,A,0,A,A,0,A,-A,0,-A,-A,0,-A,A,0],3));const i=new Tr({fog:!1,toneMapped:!1});this.lightPlane=new qr(n,i),this.add(this.lightPlane),n=new Fs,n.setAttribute("position",new xs([0,0,0,0,0,1],3)),this.targetLine=new qr(n,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),CI.setFromMatrixPosition(this.light.matrixWorld),EI.setFromMatrixPosition(this.light.target.matrixWorld),QI.subVectors(EI,CI),this.lightPlane.lookAt(EI),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(EI),this.targetLine.scale.z=QI.length()}}const fI=new An,mI=new $s;class yI extends Vr{constructor(t){const A=new Fs,e=new Tr({color:16777215,vertexColors:!0,toneMapped:!1}),n=[],i=[],s={};function a(t,A){r(t),r(A)}function r(t){n.push(0,0,0),i.push(0,0,0),void 0===s[t]&&(s[t]=[]),s[t].push(n.length/3-1)}a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4"),A.setAttribute("position",new xs(n,3)),A.setAttribute("color",new xs(i,3)),super(A,e),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update();const o=new ns(16755200),g=new ns(16711680),c=new ns(43775),l=new ns(16777215),I=new ns(3355443);this.setColors(o,g,c,l,I)}setColors(t,A,e,n,i){const s=this.geometry.getAttribute("color");s.setXYZ(0,t.r,t.g,t.b),s.setXYZ(1,t.r,t.g,t.b),s.setXYZ(2,t.r,t.g,t.b),s.setXYZ(3,t.r,t.g,t.b),s.setXYZ(4,t.r,t.g,t.b),s.setXYZ(5,t.r,t.g,t.b),s.setXYZ(6,t.r,t.g,t.b),s.setXYZ(7,t.r,t.g,t.b),s.setXYZ(8,t.r,t.g,t.b),s.setXYZ(9,t.r,t.g,t.b),s.setXYZ(10,t.r,t.g,t.b),s.setXYZ(11,t.r,t.g,t.b),s.setXYZ(12,t.r,t.g,t.b),s.setXYZ(13,t.r,t.g,t.b),s.setXYZ(14,t.r,t.g,t.b),s.setXYZ(15,t.r,t.g,t.b),s.setXYZ(16,t.r,t.g,t.b),s.setXYZ(17,t.r,t.g,t.b),s.setXYZ(18,t.r,t.g,t.b),s.setXYZ(19,t.r,t.g,t.b),s.setXYZ(20,t.r,t.g,t.b),s.setXYZ(21,t.r,t.g,t.b),s.setXYZ(22,t.r,t.g,t.b),s.setXYZ(23,t.r,t.g,t.b),s.setXYZ(24,A.r,A.g,A.b),s.setXYZ(25,A.r,A.g,A.b),s.setXYZ(26,A.r,A.g,A.b),s.setXYZ(27,A.r,A.g,A.b),s.setXYZ(28,A.r,A.g,A.b),s.setXYZ(29,A.r,A.g,A.b),s.setXYZ(30,A.r,A.g,A.b),s.setXYZ(31,A.r,A.g,A.b),s.setXYZ(32,e.r,e.g,e.b),s.setXYZ(33,e.r,e.g,e.b),s.setXYZ(34,e.r,e.g,e.b),s.setXYZ(35,e.r,e.g,e.b),s.setXYZ(36,e.r,e.g,e.b),s.setXYZ(37,e.r,e.g,e.b),s.setXYZ(38,n.r,n.g,n.b),s.setXYZ(39,n.r,n.g,n.b),s.setXYZ(40,i.r,i.g,i.b),s.setXYZ(41,i.r,i.g,i.b),s.setXYZ(42,i.r,i.g,i.b),s.setXYZ(43,i.r,i.g,i.b),s.setXYZ(44,i.r,i.g,i.b),s.setXYZ(45,i.r,i.g,i.b),s.setXYZ(46,i.r,i.g,i.b),s.setXYZ(47,i.r,i.g,i.b),s.setXYZ(48,i.r,i.g,i.b),s.setXYZ(49,i.r,i.g,i.b),s.needsUpdate=!0}update(){const t=this.geometry,A=this.pointMap;mI.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);const e=this.camera.coordinateSystem===Te?-1:0;wI("c",A,t,mI,0,0,e),wI("t",A,t,mI,0,0,1),wI("n1",A,t,mI,-1,-1,e),wI("n2",A,t,mI,1,-1,e),wI("n3",A,t,mI,-1,1,e),wI("n4",A,t,mI,1,1,e),wI("f1",A,t,mI,-1,-1,1),wI("f2",A,t,mI,1,-1,1),wI("f3",A,t,mI,-1,1,1),wI("f4",A,t,mI,1,1,1),wI("u1",A,t,mI,.7,1.1,e),wI("u2",A,t,mI,-.7,1.1,e),wI("u3",A,t,mI,0,2,e),wI("cf1",A,t,mI,-1,0,1),wI("cf2",A,t,mI,1,0,1),wI("cf3",A,t,mI,0,-1,1),wI("cf4",A,t,mI,0,1,1),wI("cn1",A,t,mI,-1,0,e),wI("cn2",A,t,mI,1,0,e),wI("cn3",A,t,mI,0,-1,e),wI("cn4",A,t,mI,0,1,e),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function wI(t,A,e,n,i,s,a){fI.set(i,s,a).unproject(n);const r=A[t];if(void 0!==r){const t=e.getAttribute("position");for(let A=0,e=r.length;A<e;A++)t.setXYZ(r[A],fI.x,fI.y,fI.z)}}const xI=new Un;class SI extends Vr{constructor(t,A=16776960){const e=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),i=new Fs;i.setIndex(new ds(e,1)),i.setAttribute("position",new ds(n,3)),super(i,new Tr({color:A,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(void 0!==this.object&&xI.setFromObject(this.object),xI.isEmpty())return;const t=xI.min,A=xI.max,e=this.geometry.attributes.position,n=e.array;n[0]=A.x,n[1]=A.y,n[2]=A.z,n[3]=t.x,n[4]=A.y,n[5]=A.z,n[6]=t.x,n[7]=t.y,n[8]=A.z,n[9]=A.x,n[10]=t.y,n[11]=A.z,n[12]=A.x,n[13]=A.y,n[14]=t.z,n[15]=t.x,n[16]=A.y,n[17]=t.z,n[18]=t.x,n[19]=t.y,n[20]=t.z,n[21]=A.x,n[22]=t.y,n[23]=t.z,e.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,A){return super.copy(t,A),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class DI extends Vr{constructor(t,A=16776960){const e=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Fs;n.setIndex(new ds(e,1)),n.setAttribute("position",new xs([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(n,new Tr({color:A,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const A=this.box;A.isEmpty()||(A.getCenter(this.position),A.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}}class vI extends qr{constructor(t,A=1,e=16776960){const n=e,i=new Fs;i.setAttribute("position",new xs([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),i.computeBoundingSphere(),super(i,new Tr({color:n,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=A;const s=new Fs;s.setAttribute("position",new xs([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),s.computeBoundingSphere(),this.add(new zs(s,new rs({color:n,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const MI=new An;let bI,_I;class RI extends Ui{constructor(t=new An(0,0,1),A=new An(0,0,0),e=1,n=16776960,i=.2*e,s=.2*i){super(),this.type="ArrowHelper",void 0===bI&&(bI=new Fs,bI.setAttribute("position",new xs([0,0,0,0,1,0],3)),_I=new uo(.5,1,5,1),_I.translate(0,-.5,0)),this.position.copy(A),this.line=new qr(bI,new Tr({color:n,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new zs(_I,new rs({color:n,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(e,i,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{MI.set(t.z,0,-t.x).normalize();const A=Math.acos(t.y);this.quaternion.setFromAxisAngle(MI,A)}}setLength(t,A=.2*t,e=.2*A){this.line.scale.set(1,Math.max(1e-4,t-A),1),this.line.updateMatrix(),this.cone.scale.set(e,A,e),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class FI extends Vr{constructor(t=1){const A=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],e=new Fs;e.setAttribute("position",new xs(A,3)),e.setAttribute("color",new xs([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(e,new Tr({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,A,e){const n=new ns,i=this.geometry.attributes.color.array;return n.set(t),n.toArray(i,0),n.toArray(i,3),n.set(A),n.toArray(i,6),n.toArray(i,9),n.set(e),n.toArray(i,12),n.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class NI{constructor(){this.type="ShapePath",this.color=new ns,this.subPaths=[],this.currentPath=null}moveTo(t,A){return this.currentPath=new qo,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,A),this}lineTo(t,A){return this.currentPath.lineTo(t,A),this}quadraticCurveTo(t,A,e,n){return this.currentPath.quadraticCurveTo(t,A,e,n),this}bezierCurveTo(t,A,e,n,i,s){return this.currentPath.bezierCurveTo(t,A,e,n,i,s),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function A(t,A){const e=A.length;let n=!1;for(let i=e-1,s=0;s<e;i=s++){let e=A[i],a=A[s],r=a.x-e.x,o=a.y-e.y;if(Math.abs(o)>Number.EPSILON){if(o<0&&(e=A[s],r=-r,a=A[i],o=-o),t.y<e.y||t.y>a.y)continue;if(t.y===e.y){if(t.x===e.x)return!0}else{const A=o*(t.x-e.x)-r*(t.y-e.y);if(0===A)return!0;if(A<0)continue;n=!n}}else{if(t.y!==e.y)continue;if(a.x<=t.x&&t.x<=e.x||e.x<=t.x&&t.x<=a.x)return!0}}return n}const e=Eg.isClockWise,n=this.subPaths;if(0===n.length)return[];let i,s,a;const r=[];if(1===n.length)return s=n[0],a=new zo,a.curves=s.curves,r.push(a),r;let o=!e(n[0].getPoints());o=t?!o:o;const g=[],c=[];let l,I,h=[],u=0;c[u]=void 0,h[u]=[];for(let A=0,a=n.length;A<a;A++)s=n[A],l=s.getPoints(),i=e(l),i=t?!i:i,i?(!o&&c[u]&&u++,c[u]={s:new zo,p:l},c[u].s.curves=s.curves,o&&u++,h[u]=[]):h[u].push({h:s,p:l[0]});if(!c[0])return function(t){const A=[];for(let e=0,n=t.length;e<n;e++){const n=t[e],i=new zo;i.curves=n.curves,A.push(i)}return A}(n);if(c.length>1){let t=!1,e=0;for(let t=0,A=c.length;t<A;t++)g[t]=[];for(let n=0,i=c.length;n<i;n++){const i=h[n];for(let s=0;s<i.length;s++){const a=i[s];let r=!0;for(let i=0;i<c.length;i++)A(a.p,c[i].p)&&(n!==i&&e++,r?(r=!1,g[i].push(a)):t=!0);r&&g[n].push(a)}}e>0&&!1===t&&(h=g)}for(let t=0,A=c.length;t<A;t++){a=c[t].s,r.push(a),I=h[t];for(let t=0,A=I.length;t<A;t++)a.holes.push(I[t].h)}return r}}class kI extends Ye{constructor(t,A=null){super(),this.object=t,this.domElement=A,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(t){void 0!==t?(null!==this.domElement&&this.disconnect(),this.domElement=t):console.warn("THREE.Controls: connect() now requires an element.")}disconnect(){}dispose(){}update(){}}function TI(t,A,e,n){const i=function(t){switch(t){case Mt:case bt:return{byteLength:1,components:1};case Rt:case _t:case Tt:return{byteLength:2,components:1};case Gt:case Ut:return{byteLength:2,components:4};case Nt:case Ft:case kt:return{byteLength:4,components:1};case Ht:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${t}.`)}(n);switch(e){case Yt:return t*A;case Ot:case Kt:return t*A/i.components*i.byteLength;case Vt:case Wt:return t*A*2/i.components*i.byteLength;case Pt:return t*A*3/i.components*i.byteLength;case Jt:case Zt:return t*A*4/i.components*i.byteLength;case Xt:case $t:return Math.floor((t+3)/4)*Math.floor((A+3)/4)*8;case tA:case AA:return Math.floor((t+3)/4)*Math.floor((A+3)/4)*16;case nA:case sA:return Math.max(t,16)*Math.max(A,8)/4;case eA:case iA:return Math.max(t,8)*Math.max(A,8)/2;case aA:case rA:return Math.floor((t+3)/4)*Math.floor((A+3)/4)*8;case oA:case gA:return Math.floor((t+3)/4)*Math.floor((A+3)/4)*16;case cA:return Math.floor((t+4)/5)*Math.floor((A+3)/4)*16;case lA:return Math.floor((t+4)/5)*Math.floor((A+4)/5)*16;case IA:return Math.floor((t+5)/6)*Math.floor((A+4)/5)*16;case hA:return Math.floor((t+5)/6)*Math.floor((A+5)/6)*16;case uA:return Math.floor((t+7)/8)*Math.floor((A+4)/5)*16;case BA:return Math.floor((t+7)/8)*Math.floor((A+5)/6)*16;case dA:return Math.floor((t+7)/8)*Math.floor((A+7)/8)*16;case CA:return Math.floor((t+9)/10)*Math.floor((A+4)/5)*16;case EA:return Math.floor((t+9)/10)*Math.floor((A+5)/6)*16;case QA:return Math.floor((t+9)/10)*Math.floor((A+7)/8)*16;case pA:return Math.floor((t+9)/10)*Math.floor((A+9)/10)*16;case fA:return Math.floor((t+11)/12)*Math.floor((A+9)/10)*16;case mA:return Math.floor((t+11)/12)*Math.floor((A+11)/12)*16;case yA:case wA:case xA:return Math.ceil(t/4)*Math.ceil(A/4)*16;case SA:case DA:return Math.ceil(t/4)*Math.ceil(A/4)*8;case vA:case MA:return Math.ceil(t/4)*Math.ceil(A/4)*16}throw new Error(`Unable to determine texture byte length for ${e} format.`)}class GI{static contain(t,A){return function(t,A){const e=t.image&&t.image.width?t.image.width/t.image.height:1;return e>A?(t.repeat.x=1,t.repeat.y=e/A,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2):(t.repeat.x=A/e,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0),t}(t,A)}static cover(t,A){return function(t,A){const e=t.image&&t.image.width?t.image.width/t.image.height:1;return e>A?(t.repeat.x=A/e,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0):(t.repeat.x=1,t.repeat.y=e/A,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2),t}(t,A)}static fill(t){return function(t){return t.repeat.x=1,t.repeat.y=1,t.offset.x=0,t.offset.y=0,t}(t)}static getByteLength(t,A,e,n){return TI(t,A,e,n)}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:n}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=n)},195:(t,A,e)=>{e.r(A),e.d(A,{navigationButtonsOverlay:()=>St,progressIndicatorOverlay:()=>xt,splatSourcesList:()=>wt});const n={context:void 0,registry:void 0,effects:void 0,done:!1,getContextId(){return i(this.context.count)},getNextContextId(){return i(this.context.count++)}};function i(t){const A=String(t),e=A.length-1;return n.context.id+(e?String.fromCharCode(96+e):"")+A}const s=(Symbol("solid-proxy"),Symbol("solid-track")),a=(Symbol("solid-dev-component"),{equals:(t,A)=>t===A});let r=k;const o=1,g=2,c={owned:null,cleanups:null,context:null,owner:null};var l=null;let I=null,h=null,u=null,B=null,d=null,C=null,E=0;function Q(t,A){const e=B,n=l,i=0===t.length,s=void 0===A?n:A,a=i?c:{owned:null,cleanups:null,context:s?s.context:null,owner:s},r=i?t:()=>t(()=>y(()=>U(a)));l=a,B=null;try{return N(r,!0)}finally{B=e,l=n}}function p(t,A){const e={value:t,observers:null,observerSlots:null,comparator:(A=A?Object.assign({},a,A):a).equals||void 0};return[v.bind(e),t=>("function"==typeof t&&(t=I&&I.running&&I.sources.has(e)?t(e.tValue):t(e.value)),M(e,t))]}function f(t,A,e){const n=R(t,A,!1,o);h&&I&&I.running?d.push(n):b(n)}function m(t,A,e){e=e?Object.assign({},a,e):a;const n=R(t,A,!0,0);return n.observers=null,n.observerSlots=null,n.comparator=e.equals||void 0,h&&I&&I.running?(n.tState=o,d.push(n)):b(n),v.bind(n)}function y(t){if(!u&&null===B)return t();const A=B;B=null;try{return u?u.untrack(t):t()}finally{B=A}}function w(t){return null===l||(null===l.cleanups?l.cleanups=[t]:l.cleanups.push(t)),t}const[x,S]=p(!1);let D;function v(){const t=I&&I.running;if(this.sources&&(t?this.tState:this.state))if((t?this.tState:this.state)===o)b(this);else{const t=d;d=null,N(()=>T(this),!1),d=t}if(B){const t=this.observers?this.observers.length:0;B.sources?(B.sources.push(this),B.sourceSlots.push(t)):(B.sources=[this],B.sourceSlots=[t]),this.observers?(this.observers.push(B),this.observerSlots.push(B.sources.length-1)):(this.observers=[B],this.observerSlots=[B.sources.length-1])}return t&&I.sources.has(this)?this.tValue:this.value}function M(t,A,e){let n=I&&I.running&&I.sources.has(t)?t.tValue:t.value;if(!t.comparator||!t.comparator(n,A)){if(I){const n=I.running;(n||!e&&I.sources.has(t))&&(I.sources.add(t),t.tValue=A),n||(t.value=A)}else t.value=A;t.observers&&t.observers.length&&N(()=>{for(let A=0;A<t.observers.length;A+=1){const e=t.observers[A],n=I&&I.running;n&&I.disposed.has(e)||((n?e.tState:e.state)||(e.pure?d.push(e):C.push(e),e.observers&&G(e)),n?e.tState=o:e.state=o)}if(d.length>1e6)throw d=[],new Error},!1)}return A}function b(t){if(!t.fn)return;U(t);const A=E;_(t,I&&I.running&&I.sources.has(t)?t.tValue:t.value,A),I&&!I.running&&I.sources.has(t)&&queueMicrotask(()=>{N(()=>{I&&(I.running=!0),B=l=t,_(t,t.tValue,A),B=l=null},!1)})}function _(t,A,e){let n;const i=l,s=B;B=l=t;try{n=t.fn(A)}catch(A){return t.pure&&(I&&I.running?(t.tState=o,t.tOwned&&t.tOwned.forEach(U),t.tOwned=void 0):(t.state=o,t.owned&&t.owned.forEach(U),t.owned=null)),t.updatedAt=e+1,H(A)}finally{B=s,l=i}(!t.updatedAt||t.updatedAt<=e)&&(null!=t.updatedAt&&"observers"in t?M(t,n,!0):I&&I.running&&t.pure?(I.sources.add(t),t.tValue=n):t.value=n,t.updatedAt=e)}function R(t,A,e,n=o,i){const s={fn:t,state:n,updatedAt:null,owned:null,sources:null,sourceSlots:null,cleanups:null,value:A,owner:l,context:l?l.context:null,pure:e};if(I&&I.running&&(s.state=0,s.tState=n),null===l||l!==c&&(I&&I.running&&l.pure?l.tOwned?l.tOwned.push(s):l.tOwned=[s]:l.owned?l.owned.push(s):l.owned=[s]),u&&s.fn){const[t,A]=p(void 0,{equals:!1}),e=u.factory(s.fn,A);w(()=>e.dispose());const n=()=>function(t){if(I&&I.running)return t(),I.done;const A=B,e=l;return Promise.resolve().then(()=>{let n;return B=A,l=e,(h||D)&&(n=I||(I={sources:new Set,effects:[],promises:new Set,disposed:new Set,queue:new Set,running:!0}),n.done||(n.done=new Promise(t=>n.resolve=t)),n.running=!0),N(t,!1),B=l=null,n?n.done:void 0})}(A).then(()=>i.dispose()),i=u.factory(s.fn,n);s.fn=A=>(t(),I&&I.running?i.track(A):e.track(A))}return s}function F(t){const A=I&&I.running;if(0===(A?t.tState:t.state))return;if((A?t.tState:t.state)===g)return T(t);if(t.suspense&&y(t.suspense.inFallback))return t.suspense.effects.push(t);const e=[t];for(;(t=t.owner)&&(!t.updatedAt||t.updatedAt<E);){if(A&&I.disposed.has(t))return;(A?t.tState:t.state)&&e.push(t)}for(let n=e.length-1;n>=0;n--){if(t=e[n],A){let A=t,i=e[n+1];for(;(A=A.owner)&&A!==i;)if(I.disposed.has(A))return}if((A?t.tState:t.state)===o)b(t);else if((A?t.tState:t.state)===g){const A=d;d=null,N(()=>T(t,e[0]),!1),d=A}}}function N(t,A){if(d)return t();let e=!1;A||(d=[]),C?e=!0:C=[],E++;try{const A=t();return function(t){if(d&&(h&&I&&I.running?function(t){for(let A=0;A<t.length;A++){const e=t[A],n=I.queue;n.has(e)||(n.add(e),h(()=>{n.delete(e),N(()=>{I.running=!0,F(e)},!1),I&&(I.running=!1)}))}}(d):k(d),d=null),t)return;let A;if(I)if(I.promises.size||I.queue.size){if(I.running)return I.running=!1,I.effects.push.apply(I.effects,C),C=null,void S(!0)}else{const t=I.sources,e=I.disposed;C.push.apply(C,I.effects),A=I.resolve;for(const t of C)"tState"in t&&(t.state=t.tState),delete t.tState;I=null,N(()=>{for(const t of e)U(t);for(const A of t){if(A.value=A.tValue,A.owned)for(let t=0,e=A.owned.length;t<e;t++)U(A.owned[t]);A.tOwned&&(A.owned=A.tOwned),delete A.tValue,delete A.tOwned,A.tState=0}S(!1)},!1)}const e=C;C=null,e.length&&N(()=>r(e),!1),A&&A()}(e),A}catch(t){e||(C=null),d=null,H(t)}}function k(t){for(let A=0;A<t.length;A++)F(t[A])}function T(t,A){const e=I&&I.running;e?t.tState=0:t.state=0;for(let n=0;n<t.sources.length;n+=1){const i=t.sources[n];if(i.sources){const t=e?i.tState:i.state;t===o?i!==A&&(!i.updatedAt||i.updatedAt<E)&&F(i):t===g&&T(i,A)}}}function G(t){const A=I&&I.running;for(let e=0;e<t.observers.length;e+=1){const n=t.observers[e];(A?n.tState:n.state)||(A?n.tState=g:n.state=g,n.pure?d.push(n):C.push(n),n.observers&&G(n))}}function U(t){let A;if(t.sources)for(;t.sources.length;){const A=t.sources.pop(),e=t.sourceSlots.pop(),n=A.observers;if(n&&n.length){const t=n.pop(),i=A.observerSlots.pop();e<n.length&&(t.sourceSlots[i]=e,n[e]=t,A.observerSlots[e]=i)}}if(t.tOwned){for(A=t.tOwned.length-1;A>=0;A--)U(t.tOwned[A]);delete t.tOwned}if(I&&I.running&&t.pure)L(t,!0);else if(t.owned){for(A=t.owned.length-1;A>=0;A--)U(t.owned[A]);t.owned=null}if(t.cleanups){for(A=t.cleanups.length-1;A>=0;A--)t.cleanups[A]();t.cleanups=null}I&&I.running?t.tState=0:t.state=0}function L(t,A){if(A||(t.tState=0,I.disposed.add(t)),t.owned)for(let A=0;A<t.owned.length;A++)L(t.owned[A])}function H(t,A=l){const e=function(t){return t instanceof Error?t:new Error("string"==typeof t?t:"Unknown error",{cause:t})}(t);throw e}const Y=Symbol("fallback");function P(t){for(let A=0;A<t.length;A++)t[A]()}function J(t,A){return y(()=>t(A||{}))}function q(t){const A="fallback"in t&&{fallback:()=>t.fallback};return m(function(t,A,e={}){let n=[],i=[],a=[],r=0,o=A.length>1?[]:null;return w(()=>P(a)),()=>{let g,c,l=t()||[],I=l.length;return l[s],y(()=>{let t,A,s,u,B,d,C,E,p;if(0===I)0!==r&&(P(a),a=[],n=[],i=[],r=0,o&&(o=[])),e.fallback&&(n=[Y],i[0]=Q(t=>(a[0]=t,e.fallback())),r=1);else if(0===r){for(i=new Array(I),c=0;c<I;c++)n[c]=l[c],i[c]=Q(h);r=I}else{for(s=new Array(I),u=new Array(I),o&&(B=new Array(I)),d=0,C=Math.min(r,I);d<C&&n[d]===l[d];d++);for(C=r-1,E=I-1;C>=d&&E>=d&&n[C]===l[E];C--,E--)s[E]=i[C],u[E]=a[C],o&&(B[E]=o[C]);for(t=new Map,A=new Array(E+1),c=E;c>=d;c--)p=l[c],g=t.get(p),A[c]=void 0===g?-1:g,t.set(p,c);for(g=d;g<=C;g++)p=n[g],c=t.get(p),void 0!==c&&-1!==c?(s[c]=i[g],u[c]=a[g],o&&(B[c]=o[g]),c=A[c],t.set(p,c)):a[g]();for(c=d;c<I;c++)c in s?(i[c]=s[c],a[c]=u[c],o&&(o[c]=B[c],o[c](c))):i[c]=Q(h);i=i.slice(0,r=I),n=l.slice(0)}return i});function h(t){if(a[c]=t,o){const[t,e]=p(c);return o[c]=e,A(l[c],t)}return A(l[c])}}}(()=>t.each,t.children,A||void 0))}function z(t){const A=t.keyed,e=m(()=>t.when,void 0,void 0),n=A?e:m(e,void 0,{equals:(t,A)=>!t==!A});return m(()=>{const i=n();if(i){const s=t.children;return"function"==typeof s&&s.length>0?y(()=>s(A?i:()=>{if(!y(n))throw`Stale read from <${"Show"}>.`;return e()})):s}return t.fallback},void 0,void 0)}Object.create(null),Object.create(null);const O="_$DX_DELEGATE";function K(t,A,e,n={}){let i;return Q(n=>{i=n,A===document?t():$(A,t(),A.firstChild?null:void 0,e)},n.owner),()=>{i(),A.textContent=""}}function V(t,A,e,n){let i;const s=()=>{const A=n?document.createElementNS("http://www.w3.org/1998/Math/MathML","template"):document.createElement("template");return A.innerHTML=t,e?A.content.firstChild.firstChild:n?A.firstChild:A.content.firstChild},a=A?()=>y(()=>document.importNode(i||(i=s()),!0)):()=>(i||(i=s())).cloneNode(!0);return a.cloneNode=a,a}function W(t,A=window.document){const e=A[O]||(A[O]=new Set);for(let n=0,i=t.length;n<i;n++){const i=t[n];e.has(i)||(e.add(i),A.addEventListener(i,At))}}function j(t,A,e){tt(t)||(null==e?t.removeAttribute(A):t.setAttribute(A,e))}function Z(t,A,e,n){if(n)Array.isArray(e)?(t[`$$${A}`]=e[0],t[`$$${A}Data`]=e[1]):t[`$$${A}`]=e;else if(Array.isArray(e)){const n=e[0];t.addEventListener(A,e[0]=A=>n.call(t,e[1],A))}else t.addEventListener(A,e,"function"!=typeof e&&e)}function X(t,A,e){if(!A)return e?j(t,"style"):A;const n=t.style;if("string"==typeof A)return n.cssText=A;let i,s;for(s in"string"==typeof e&&(n.cssText=e=void 0),e||(e={}),A||(A={}),e)null==A[s]&&n.removeProperty(s),delete e[s];for(s in A)i=A[s],i!==e[s]&&(n.setProperty(s,i),e[s]=i);return e}function $(t,A,e,n){if(void 0===e||n||(n=[]),"function"!=typeof A)return et(t,A,n,e);f(n=>et(t,A(),n,e),n)}function tt(t){return!!n.context&&!n.done&&(!t||t.isConnected)}function At(t){if(n.registry&&n.events&&n.events.find(([A,e])=>e===t))return;let A=t.target;const e=`$$${t.type}`,i=t.target,s=t.currentTarget,a=A=>Object.defineProperty(t,"target",{configurable:!0,value:A}),r=()=>{const n=A[e];if(n&&!A.disabled){const i=A[`${e}Data`];if(void 0!==i?n.call(A,i,t):n.call(A,t),t.cancelBubble)return}return A.host&&"string"!=typeof A.host&&!A.host._$host&&A.contains(t.target)&&a(A.host),!0},o=()=>{for(;r()&&(A=A._$host||A.parentNode||A.host););};if(Object.defineProperty(t,"currentTarget",{configurable:!0,get:()=>A||document}),n.registry&&!n.done&&(n.done=_$HY.done=!0),t.composedPath){const e=t.composedPath();a(e[0]);for(let t=0;t<e.length-2&&(A=e[t],r());t++){if(A._$host){A=A._$host,o();break}if(A.parentNode===s)break}}else o();a(i)}function et(t,A,e,n,i){const s=tt(t);if(s){!e&&(e=[...t.childNodes]);let A=[];for(let t=0;t<e.length;t++){const n=e[t];8===n.nodeType&&"!$"===n.data.slice(0,2)?n.remove():A.push(n)}e=A}for(;"function"==typeof e;)e=e();if(A===e)return e;const a=typeof A,r=void 0!==n;if(t=r&&e[0]&&e[0].parentNode||t,"string"===a||"number"===a){if(s)return e;if("number"===a&&(A=A.toString())===e)return e;if(r){let i=e[0];i&&3===i.nodeType?i.data!==A&&(i.data=A):i=document.createTextNode(A),e=st(t,e,n,i)}else e=""!==e&&"string"==typeof e?t.firstChild.data=A:t.textContent=A}else if(null==A||"boolean"===a){if(s)return e;e=st(t,e,n)}else{if("function"===a)return f(()=>{let i=A();for(;"function"==typeof i;)i=i();e=et(t,i,e,n)}),()=>e;if(Array.isArray(A)){const a=[],o=e&&Array.isArray(e);if(nt(a,A,e,i))return f(()=>e=et(t,a,e,n,!0)),()=>e;if(s){if(!a.length)return e;if(void 0===n)return e=[...t.childNodes];let A=a[0];if(A.parentNode!==t)return e;const i=[A];for(;(A=A.nextSibling)!==n;)i.push(A);return e=i}if(0===a.length){if(e=st(t,e,n),r)return e}else o?0===e.length?it(t,a,n):function(t,A,e){let n=e.length,i=A.length,s=n,a=0,r=0,o=A[i-1].nextSibling,g=null;for(;a<i||r<s;)if(A[a]!==e[r]){for(;A[i-1]===e[s-1];)i--,s--;if(i===a){const A=s<n?r?e[r-1].nextSibling:e[s-r]:o;for(;r<s;)t.insertBefore(e[r++],A)}else if(s===r)for(;a<i;)g&&g.has(A[a])||A[a].remove(),a++;else if(A[a]===e[s-1]&&e[r]===A[i-1]){const n=A[--i].nextSibling;t.insertBefore(e[r++],A[a++].nextSibling),t.insertBefore(e[--s],n),A[i]=e[s]}else{if(!g){g=new Map;let t=r;for(;t<s;)g.set(e[t],t++)}const n=g.get(A[a]);if(null!=n)if(r<n&&n<s){let o,c=a,l=1;for(;++c<i&&c<s&&null!=(o=g.get(A[c]))&&o===n+l;)l++;if(l>n-r){const i=A[a];for(;r<n;)t.insertBefore(e[r++],i)}else t.replaceChild(e[r++],A[a++])}else a++;else A[a++].remove()}}else a++,r++}(t,e,a):(e&&st(t),it(t,a));e=a}else if(A.nodeType){if(s&&A.parentNode)return e=r?[A]:A;if(Array.isArray(e)){if(r)return e=st(t,e,n,A);st(t,e,null,A)}else null!=e&&""!==e&&t.firstChild?t.replaceChild(A,t.firstChild):t.appendChild(A);e=A}}return e}function nt(t,A,e,n){let i=!1;for(let s=0,a=A.length;s<a;s++){let a,r=A[s],o=e&&e[t.length];if(null==r||!0===r||!1===r);else if("object"==(a=typeof r)&&r.nodeType)t.push(r);else if(Array.isArray(r))i=nt(t,r,o)||i;else if("function"===a)if(n){for(;"function"==typeof r;)r=r();i=nt(t,Array.isArray(r)?r:[r],Array.isArray(o)?o:[o])||i}else t.push(r),i=!0;else{const A=String(r);o&&3===o.nodeType&&o.data===A?t.push(o):t.push(document.createTextNode(A))}}return i}function it(t,A,e=null){for(let n=0,i=A.length;n<i;n++)t.insertBefore(A[n],e)}function st(t,A,e,n){if(void 0===e)return t.textContent="";const i=n||document.createTextNode("");if(A.length){let n=!1;for(let s=A.length-1;s>=0;s--){const a=A[s];if(i!==a){const A=a.parentNode===t;n||s?A&&a.remove():A?t.replaceChild(i,a):t.insertBefore(i,e)}else n=!0}}else t.insertBefore(i,e);return[i]}Symbol();var at=V("<div><table><thead><tr><th>Name</th><th>URL</th><th></th></tr></thead><tbody>"),rt=V('<tr><td><strong></strong></td><td><a target=_blank rel="noopener noreferrer"></a></td><td><button>X'),ot=function(t){return a=(s=(i=(n=(e=(A=at()).firstChild).firstChild).firstChild.firstChild).nextSibling).nextSibling,r=n.nextSibling,A.style.setProperty("padding","2px"),A.style.setProperty("border","1px solid #ccc"),A.style.setProperty("border-radius","8px"),e.style.setProperty("width","100%"),e.style.setProperty("border-collapse","collapse"),i.style.setProperty("padding","8px"),i.style.setProperty("text-align","left"),i.style.setProperty("border-bottom","1px solid #ddd"),s.style.setProperty("padding","8px"),s.style.setProperty("text-align","left"),s.style.setProperty("border-bottom","1px solid #ddd"),a.style.setProperty("padding","8px"),a.style.setProperty("text-align","left"),a.style.setProperty("border-bottom","1px solid #ddd"),$(r,J(q,{get each(){return Object.values(t.sources)},children:function(A){return i=(n=(e=rt()).firstChild).firstChild,s=n.nextSibling,a=s.firstChild,o=(r=s.nextSibling).firstChild,e.$$click=function(e){t.on&&(e.stopPropagation(),t.on("select",A.id))},e.style.setProperty("cursor","pointer"),n.style.setProperty("padding","8px"),n.style.setProperty("border-bottom","1px solid #eee"),$(i,function(){return A.name}),s.style.setProperty("padding","8px"),s.style.setProperty("border-bottom","1px solid #eee"),a.style.setProperty("color","lightblue"),$(a,function(){return A.url}),r.style.setProperty("padding","8px"),r.style.setProperty("border-bottom","1px solid #eee"),o.$$click=function(e){t.on&&(e.stopPropagation(),t.on("delete",A.id))},o.style.setProperty("padding","0px 6px"),o.style.setProperty("font-weight","bolder"),o.style.setProperty("background-color","#ff4444"),o.style.setProperty("color","white"),o.style.setProperty("border","none"),o.style.setProperty("border-radius","4px"),o.style.setProperty("cursor","pointer"),f(function(){return j(a,"href",A.url)}),e;var e,n,i,s,a,r,o}})),A;var A,e,n,i,s,a,r};W(["click"]);var gt=V("<div><div></div><span>"),ct=function(t){var A,e,n;return!1===t.visible?null:(A=gt(),n=(e=A.firstChild).nextSibling,A.style.setProperty("display","flex"),A.style.setProperty("align-items","center"),A.style.setProperty("gap","8px"),A.style.setProperty("padding","8px 12px"),A.style.setProperty("background-color","rgba(0, 0, 0, 0.8)"),A.style.setProperty("color","white"),A.style.setProperty("border-radius","6px"),A.style.setProperty("font-family","monospace"),A.style.setProperty("font-size","14px"),A.style.setProperty("font-weight","bold"),e.style.setProperty("width","16px"),e.style.setProperty("height","16px"),e.style.setProperty("border","2px solid rgba(255, 255, 255, 0.3)"),e.style.setProperty("border-top","2px solid white"),e.style.setProperty("border-radius","50%"),e.style.setProperty("flex-shrink","0"),n.style.setProperty("min-width","40px"),n.style.setProperty("text-align","right"),$(n,function(){return A=t.progress,100===(e=Math.round(Math.max(0,Math.min(100,A))))?"100%":"".concat(e.toString().padStart(2," ")," %");var A,e}),f(function(t){return null!=(t="rotate(".concat(performance.now()/1.5%360,"deg)"))?e.style.setProperty("transform",t):e.style.removeProperty("transform")}),A)},lt=V("<div><div>"),It=V("<div>"),ht=V("<button>Cancel"),ut=function(t){var A=function(A){A.target===A.currentTarget&&t.onBackdropClick&&t.onBackdropClick()};return J(z,{get when(){return!1!==t.visible},get children(){var e=lt(),n=e.firstChild;return e.$$click=A,e.style.setProperty("position","fixed"),e.style.setProperty("top","0"),e.style.setProperty("left","0"),e.style.setProperty("width","100vw"),e.style.setProperty("height","100vh"),e.style.setProperty("display","flex"),e.style.setProperty("align-items","center"),e.style.setProperty("justify-content","center"),e.style.setProperty("z-index","1000"),n.style.setProperty("pointer-events","auto"),$(n,function(){return t.children}),f(function(A){var n=!1!==t.backdrop?"rgba(0, 0, 0, 0.5)":"transparent",i=t.onBackdropClick?"auto":"none";return n!==A.e&&(null!=(A.e=n)?e.style.setProperty("background-color",n):e.style.removeProperty("background-color")),i!==A.t&&(null!=(A.t=i)?e.style.setProperty("pointer-events",i):e.style.removeProperty("pointer-events")),A},{e:void 0,t:void 0}),e}})},Bt=function(t){return J(ut,{get visible(){return t.visible},get onBackdropClick(){return t.onBackdropClick},backdrop:!0,get children(){var A,e,n=It();return n.style.setProperty("display","flex"),n.style.setProperty("flex-direction","column"),n.style.setProperty("align-items","center"),n.style.setProperty("gap","16px"),$(n,J(ct,{get progress(){return t.progress}}),null),$(n,(A=function(){return!!t.onCancel},e=m(()=>A()),function(){return e()&&(Z(A=ht(),"click",t.onCancel,!0),A.style.setProperty("padding","8px 16px"),A.style.setProperty("background-color","#666"),A.style.setProperty("color","white"),A.style.setProperty("border","none"),A.style.setProperty("border-radius","4px"),A.style.setProperty("cursor","pointer"),A.style.setProperty("font-size","12px"),A);var A}),null),n}})};W(["click"]);var dt=V("<div><button>◀</button><button>▶");function Ct(t){return Ct="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ct(t)}function Et(t,A){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);A&&(n=n.filter(function(A){return Object.getOwnPropertyDescriptor(t,A).enumerable})),e.push.apply(e,n)}return e}function Qt(t){for(var A=1;A<arguments.length;A++){var e=null!=arguments[A]?arguments[A]:{};A%2?Et(Object(e),!0).forEach(function(A){pt(t,A,e[A])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):Et(Object(e)).forEach(function(A){Object.defineProperty(t,A,Object.getOwnPropertyDescriptor(e,A))})}return t}function pt(t,A,e){return(A=function(t){var A=function(t){if("object"!=Ct(t)||!t)return t;var A=t[Symbol.toPrimitive];if(void 0!==A){var e=A.call(t,"string");if("object"!=Ct(e))return e;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ct(A)?A:A+""}(A))in t?Object.defineProperty(t,A,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[A]=e,t}var ft=function(t){var A={position:"absolute",top:"50%",transform:"translateY(-50%)",width:"40px",height:"40px","background-color":"rgba(0, 0, 0, 0.6)",border:"none","border-radius":"8px",color:"grey",cursor:"pointer","font-size":"16px","font-weight":"bold",transition:"all 0.2s ease","z-index":"999"},e=Qt(Qt({},A),{},{"background-color":"rgba(0, 0, 0, 0.3)",color:"rgba(255, 255, 255, 0.4)",cursor:"not-allowed"});if(!1===t.visible)return null;var n,i,s,a=function(t){t.style.backgroundColor="rgba(0, 0, 0, 0.8)",t.style.transform="translateY(-50%) scale(1.05)",t.style.color="white"},r=function(t){t.style.backgroundColor="rgba(0, 0, 0, 0.6)",t.style.transform="translateY(-50%) scale(1)",t.style.color="grey"};return n=dt(),i=n.firstChild,s=i.nextSibling,n.style.setProperty("position","fixed"),n.style.setProperty("pointer-events","none"),n.style.setProperty("z-index","998"),i.addEventListener("mouseleave",function(A){t.disabled.prev||r(A.currentTarget)}),i.addEventListener("mouseenter",function(A){t.disabled.prev||a(A.currentTarget)}),Z(i,"click",t.onPrevious,!0),s.addEventListener("mouseleave",function(A){t.disabled.next||r(A.currentTarget)}),s.addEventListener("mouseenter",function(A){t.disabled.next||a(A.currentTarget)}),Z(s,"click",t.onNext,!0),f(function(a){var r="".concat(t.containerRect.top,"px"),o="".concat(t.containerRect.left,"px"),g="".concat(t.containerRect.width,"px"),c="".concat(t.containerRect.height,"px"),l=Qt(Qt({},t.disabled.prev?e:A),{},{left:"20px","pointer-events":"auto"}),I=t.disabled.prev,h=Qt(Qt({},t.disabled.next?e:A),{},{right:"20px","pointer-events":"auto"}),u=t.disabled.next;return r!==a.e&&(null!=(a.e=r)?n.style.setProperty("top",r):n.style.removeProperty("top")),o!==a.t&&(null!=(a.t=o)?n.style.setProperty("left",o):n.style.removeProperty("left")),g!==a.a&&(null!=(a.a=g)?n.style.setProperty("width",g):n.style.removeProperty("width")),c!==a.o&&(null!=(a.o=c)?n.style.setProperty("height",c):n.style.removeProperty("height")),a.i=X(i,l,a.i),I!==a.n&&(i.disabled=a.n=I),a.s=X(s,h,a.s),u!==a.h&&(s.disabled=a.h=u),a},{e:void 0,t:void 0,a:void 0,o:void 0,i:void 0,n:void 0,s:void 0,h:void 0}),n};W(["click"]);var mt=e(294);function yt(t){var A,e=null,n={setup:function(i,s){A=s,K(function(){return t(A)},e=i),delete n.setup,n.update=function(n){if(null===e)throw new Error("containerElement is not set");n&&(A=n),e.innerHTML="",K(function(){return t(A)},e)}}};return n}var wt=yt(function(t){return J(ot,{get sources(){return mt.struct.SPLAT_SOURCES},get on(){return t.on}})}),xt=function(){var t,A=yt(function(t){return J(Bt,{get visible(){return t.active},get progress(){return t.percentage}})}),e={percentage:0,active:!1},n=document.createElement("div");return"complete"===document.readyState?document.body.appendChild(n):window.addEventListener("load",function(){return document.body.appendChild(n)},{once:!0}),null===(t=A.setup)||void 0===t||t.call(A,n,e),{active:function(t){var n;if(void 0===t||t===e.active)return e.active;e.active=t,null===(n=A.update)||void 0===n||n.call(A,e)},update:function(t){var n;e.active=!0,e.percentage=t,null===(n=A.update)||void 0===n||n.call(A,e)},dispose:function(){e.percentage=0,e.active=!1,n.remove()}}},St=function(t){var A,e=yt(function(A){return J(ft,{containerRect:t,get disabled(){return A.disabled},get visible(){return A.visible},get onPrevious(){return A.onPrevious},get onNext(){return A.onNext}})}),n={disabled:{prev:!1,next:!1},visible:!1,onPrevious:function(){},onNext:function(){}},i=document.createElement("div");document.body.appendChild(i),null===(A=e.setup)||void 0===A||A.call(e,i,n);var s={show:function(){var t,A=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];n.visible=A,null===(t=e.update)||void 0===t||t.call(e,n)},updateDisabled:function(t){var A;n.disabled=t,null===(A=e.update)||void 0===A||A.call(e,n)},setCallbacks:function(t,A){var i;n.onPrevious=t,n.onNext=A,null===(i=e.update)||void 0===i||i.call(e,n)},dispose:function(){n.visible=!1,i.remove()}};return s}},279:(t,A)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.inlineButton=function(t,A){var e=document.createElement("button");return e.textContent=t,e.style.cssText="position: inline-block; margin-left: 16px; width: 16px; height: 16px;",e.addEventListener("click",A),e}},294:(t,A)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.slideshowConfig=A.struct=void 0,A.struct={APP:{activeSplatId:"",useTransitions:!0},SPLATS:{},SPLAT_SOURCES:{},SCENE:{initialCameraPosition:[0,0,1],initialCameraTarget:[0,0,0]}},A.slideshowConfig={SPLATS:{}}},337:(t,A,e)=>{e.r(A),e.d(A,{FINGER_TIPS:()=>co,FpsMovement:()=>fo,HANDS:()=>Io,Hand:()=>lo,HandMovement:()=>uo,JOINT_IDS:()=>no,JOINT_INDEX:()=>so,JOINT_RADIUS:()=>ao,JOINT_SEGMENTS:()=>ro,JOINT_SEGMENT_STEPS:()=>oo,JOINT_TIPS:()=>go,JointEnum:()=>eo,NUM_JOINTS:()=>io,PackedSplats:()=>lr,PlyReader:()=>Ua,PointerControls:()=>mo,Readback:()=>Ia,Sint8ToFloat:()=>ZA,SparkControls:()=>po,SparkRenderer:()=>vr,SparkViewpoint:()=>Cr,SplatAccumulator:()=>pr,SplatEdit:()=>ya,SplatEditRgbaBlendMode:()=>Qa,SplatEditSdf:()=>fa,SplatEditSdfType:()=>Ca,SplatEdits:()=>wa,SplatFileType:()=>nr,SplatGenerator:()=>_a,SplatLoader:()=>er,SplatMesh:()=>Fa,SplatModifier:()=>Ma,SplatSkinning:()=>Lr,SplatTransformer:()=>ba,SpzReader:()=>Nr,SpzWriter:()=>Gr,Uint8ToFloat:()=>jA,VRButton:()=>Ao,XrHands:()=>ho,constructAxes:()=>qr,constructGrid:()=>Jr,constructSpherePoints:()=>zr,dyno:()=>ca,flipPixels:()=>re,floatToSint8:()=>WA,floatToUint8:()=>VA,fromHalf:()=>KA,generators:()=>jr,getSplatFileType:()=>ir,imageSplats:()=>Kr,isAndroid:()=>se,isMobile:()=>ie,isOculus:()=>ae,isPcSogs:()=>ar,modifiers:()=>$r,pixelsToPngUrl:()=>oe,setPackedSplat:()=>te,textSplats:()=>Or,toHalf:()=>OA,transcodeSpz:()=>Ur,unpackSplat:()=>ee,unpackSplats:()=>or,utils:()=>fe});var n=e(184),i=e(451);let s;const a="undefined"!=typeof TextDecoder?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};"undefined"!=typeof TextDecoder&&a.decode();let r=null;async function o(t){if(void 0!==s)return s;void 0!==t&&(Object.getPrototypeOf(t)===Object.prototype?({module_or_path:t}=t):console.warn("using deprecated parameters for the initialization function; pass a single object instead")),void 0===t&&(t=new URL(e(933),e.b));const A=function(){const t={wbg:{}};return t.wbg.__wbg_buffer_609cc3eee51ed158=function(t){return t.buffer},t.wbg.__wbg_length_3b4f022188ae8db6=function(t){return t.length},t.wbg.__wbg_length_6ca527665d89694d=function(t){return t.length},t.wbg.__wbg_length_8cfd2c6409af88ad=function(t){return t.length},t.wbg.__wbg_new_9fee97a409b32b68=function(t){return new Uint16Array(t)},t.wbg.__wbg_new_e3b321dcfef89fc7=function(t){return new Uint32Array(t)},t.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(t,A,e){return new Float32Array(t,A>>>0,e>>>0)},t.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(t,A,e){return new Uint32Array(t,A>>>0,e>>>0)},t.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(t){return new Float32Array(t>>>0)},t.wbg.__wbg_set_10bad9bee0e9c58b=function(t,A,e){t.set(A,e>>>0)},t.wbg.__wbg_set_d23661d19148b229=function(t,A,e){t.set(A,e>>>0)},t.wbg.__wbg_set_f4f1f0daa30696fc=function(t,A,e){t.set(A,e>>>0)},t.wbg.__wbg_subarray_3aaeec89bb2544f0=function(t,A,e){return t.subarray(A>>>0,e>>>0)},t.wbg.__wbg_subarray_769e1e0f81bb259b=function(t,A,e){return t.subarray(A>>>0,e>>>0)},t.wbg.__wbindgen_init_externref_table=function(){const t=s.__wbindgen_export_0,A=t.grow(4);t.set(0,void 0),t.set(A+0,void 0),t.set(A+1,null),t.set(A+2,!0),t.set(A+3,!1)},t.wbg.__wbindgen_memory=function(){return s.memory},t.wbg.__wbindgen_throw=function(t,A){throw new Error((e=t,n=A,e>>>=0,a.decode((null!==r&&0!==r.byteLength||(r=new Uint8Array(s.memory.buffer)),r).subarray(e,e+n))));var e,n},t}();("string"==typeof t||"function"==typeof Request&&t instanceof Request||"function"==typeof URL&&t instanceof URL)&&(t=fetch(t));const{instance:n,module:i}=await async function(t,A){if("function"==typeof Response&&t instanceof Response){if("function"==typeof WebAssembly.instantiateStreaming)try{return await WebAssembly.instantiateStreaming(t,A)}catch(A){if("application/wasm"==t.headers.get("Content-Type"))throw A;console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",A)}const e=await t.arrayBuffer();return await WebAssembly.instantiate(e,A)}{const e=await WebAssembly.instantiate(t,A);return e instanceof WebAssembly.Instance?{instance:e,module:t}:e}}(await t,A);return function(t,A){return s=t.exports,o.__wbindgen_wasm_module=A,r=null,s.__wbindgen_start(),s}(n,i)}const g=-9,c=(9-g)/254,l=2048,I=2048,h=1;function u(t){return"bool"===t||"bvec2"===t||"bvec3"===t||"bvec4"===t}function B(t){return"int"===t||"uint"===t||"float"===t}function d(t){return"int"===t||"ivec2"===t||"ivec3"===t||"ivec4"===t}function C(t){return"uint"===t||"uvec2"===t||"uvec3"===t||"uvec4"===t}function E(t){return"float"===t||"vec2"===t||"vec3"===t||"vec4"===t}function Q(t){return"mat2"===t||"mat2x2"===t||"mat2x3"===t||"mat2x4"===t||"mat3"===t||"mat3x2"===t||"mat3x3"===t||"mat3x4"===t||"mat4"===t||"mat4x2"===t||"mat4x3"===t||"mat4x4"===t}function p(t){return E(t)||Q(t)}function f(t){return"vec2"===t||"ivec2"===t||"uvec2"===t}function m(t){return"vec3"===t||"ivec3"===t||"uvec3"===t}function y(t){return"vec4"===t||"ivec4"===t||"uvec4"===t}function w(t){return"mat2"===t||"mat2x2"===t}function x(t){return"mat3"===t||"mat3x3"===t}function S(t){return"mat4"===t||"mat4x4"===t}function D(t){switch(t){case"vec2":case"vec3":case"vec4":return"float";case"ivec2":case"ivec3":case"ivec4":return"int";case"uvec2":case"uvec3":case"uvec4":return"uint";default:throw new Error(`Invalid vector type: ${t}`)}}function v(t){switch(t){case"vec2":case"ivec2":case"uvec2":return 2;case"vec3":case"ivec3":case"uvec3":return 3;case"vec4":case"ivec4":case"uvec4":return 4;default:throw new Error(`Invalid vector type: ${t}`)}}function M(t){if(B(t))return"uint";if(f(t))return"uvec2";if(m(t))return"uvec3";if(y(t))return"uvec4";throw new Error(`Invalid vector type: ${t}`)}function b(t){if("string"==typeof t)return t;if("object"==typeof t&&t.type)return t.type;throw new Error(`Invalid DynoType: ${String(t)}`)}function _(t){return Math.trunc(t).toString()}function R(t){return`${Math.max(0,Math.trunc(t)).toString()}u`}function F(t){return t===Number.POSITIVE_INFINITY?"INFINITY":t===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(t)?t.toFixed(1):t.toString()}function N(t){return t instanceof k?t.type:t.dynoOut().type}class k{constructor(t){this.__isDynoValue=!0,this.type=t}}class T extends k{constructor(t,A){super(t.outTypes[A]),this.dyno=t,this.key=A}}class G extends k{constructor(t,A){super(t),this.literal=A}getLiteral(){return this.literal}}function U(t,A){return new G(t,A)}class L extends G{constructor(t,A){super(t,""),this.value=A}getLiteral(){const{type:t,value:A}=this;switch(t){case"bool":return A?"true":"false";case"uint":return R(A);case"int":return _(A);case"float":return F(A);case"bvec2":{const t=A;return`bvec2(${t[0]}, ${t[1]})`}case"uvec2":{if(A instanceof n.I9Y)return`uvec2(${R(A.x)}, ${R(A.y)})`;const t=A;return`uvec2(${R(t[0])}, ${R(t[1])})`}case"ivec2":{if(A instanceof n.I9Y)return`ivec2(${_(A.x)}, ${_(A.y)})`;const t=A;return`ivec2(${_(t[0])}, ${_(t[1])})`}case"vec2":{if(A instanceof n.I9Y)return`vec2(${F(A.x)}, ${F(A.y)})`;const t=A;return`vec2(${F(t[0])}, ${F(t[1])})`}case"bvec3":{const t=A;return`bvec3(${t[0]}, ${t[1]}, ${t[2]})`}case"uvec3":{if(A instanceof n.Pq0)return`uvec3(${R(A.x)}, ${R(A.y)}, ${R(A.z)})`;const t=A;return`uvec3(${R(t[0])}, ${R(t[1])}, ${R(t[2])})`}case"ivec3":{if(A instanceof n.Pq0)return`ivec3(${_(A.x)}, ${_(A.y)}, ${_(A.z)})`;const t=A;return`ivec3(${_(t[0])}, ${_(t[1])}, ${_(t[2])})`}case"vec3":{if(A instanceof n.Pq0)return`vec3(${F(A.x)}, ${F(A.y)}, ${F(A.z)})`;const t=A;return`vec3(${F(t[0])}, ${F(t[1])}, ${F(t[2])})`}case"bvec4":{const t=A;return`bvec4(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]})`}case"uvec4":{if(A instanceof n.IUQ)return`uvec4(${R(A.x)}, ${R(A.y)}, ${R(A.z)}, ${R(A.w)})`;const t=A;return`uvec4(${R(t[0])}, ${R(t[1])}, ${R(t[2])}, ${R(t[3])})`}case"ivec4":{if(A instanceof n.IUQ)return`ivec4(${_(A.x)}, ${_(A.y)}, ${_(A.z)}, ${_(A.w)})`;const t=A;return`ivec4(${_(t[0])}, ${_(t[1])}, ${_(t[2])}, ${_(t[3])})`}case"vec4":{if(A instanceof n.IUQ)return`vec4(${F(A.x)}, ${F(A.y)}, ${F(A.z)}, ${F(A.w)})`;if(A instanceof n.PTz)return`vec4(${F(A.x)}, ${F(A.y)}, ${F(A.z)}, ${F(A.w)})`;const t=A;return`vec4(${F(t[0])}, ${F(t[1])}, ${F(t[2])}, ${F(t[3])})`}case"mat2":case"mat2x2":{const e=A,i=e instanceof n.k_V?e.elements:A,s=new Array(4).fill(0).map((t,A)=>F(i[A]));return`${t}(${s.join(", ")})`}case"mat2x3":{const e=A,n=new Array(6).fill(0).map((t,A)=>F(e[A]));return`${t}(${n.join(", ")})`}case"mat2x4":{const e=A,n=new Array(8).fill(0).map((t,A)=>F(e[A]));return`${t}(${n.join(", ")})`}case"mat3":case"mat3x3":{const e=A,i=e instanceof n.dwI?e.elements:A,s=new Array(9).fill(0).map((t,A)=>F(i[A]));return`${t}(${s.join(", ")})`}case"mat3x2":{const e=A,n=new Array(6).fill(0).map((t,A)=>F(e[A]));return`${t}(${n.join(", ")})`}case"mat3x4":{const e=A,n=new Array(12).fill(0).map((t,A)=>F(e[A]));return`${t}(${n.join(", ")})`}case"mat4":case"mat4x4":{const e=A,i=e instanceof n.kn4?e.elements:A,s=new Array(16).fill(0).map((t,A)=>F(i[A]));return`${t}(${s.join(", ")})`}case"mat4x2":{const e=A,n=new Array(8).fill(0).map((t,A)=>F(e[A]));return`${t}(${n.join(", ")})`}case"mat4x3":{const e=A,n=new Array(12).fill(0).map((t,A)=>F(e[A]));return`${t}(${n.join(", ")})`}default:throw new Error(`Type not implemented: ${String(t)}`)}}}function H(t,A){return new L(t,A)}function Y(t){const A=String(t);if(u(t))return`${A}(false)`;if(p(t))return`${A}(0.0)`;if(d(t))return`${A}(0)`;if(C(t))return`${A}(0u)`;throw new Error(`Type not implemented: ${A}`)}const P="    ";class J{constructor({indent:t}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=P,this.indent=t??P}nextSequence(){return this.sequence++}}class q{constructor({inTypes:t,outTypes:A,inputs:e,update:n,globals:i,statements:s,generate:a}){this.inTypes=t??{},this.outTypes=A??{},this.inputs=e??{},this.update=n,this.globals=i,this.statements=s,this.generate=a??(({inputs:t,outputs:A,compile:e})=>{var n,i;return{globals:null==(n=this.globals)?void 0:n.call(this,{inputs:t,outputs:A,compile:e}),statements:null==(i=this.statements)?void 0:i.call(this,{inputs:t,outputs:A,compile:e})}})}get outputs(){const t={};for(const A in this.outTypes)t[A]=new T(this,A);return t}apply(t){return Object.assign(this.inputs,t),this.outputs}compile({inputs:t,outputs:A,compile:e}){const n=[`// ${this.constructor.name}(${Object.values(t).join(", ")}) => (${Object.values(A).join(", ")})`],i=[];for(const t in A){const n=A[t];n&&!e.declares.has(n)&&(e.declares.add(n),i.push(t))}const{globals:s,statements:a,uniforms:r}=this.generate({inputs:t,outputs:A,compile:e});for(const t of s??[])e.globals.add(t);for(const t in r)e.uniforms[t]=r[t];this.update&&e.updaters.push(this.update);for(const t of i){const i=A[t];i&&(e.uniforms[i]||n.push(`${V(i,this.outTypes[t])};`))}return(null==a?void 0:a.length)&&(n.push("{"),n.push(...a.map(t=>e.indent+t)),n.push("}")),n}}class z extends q{constructor({inTypes:t,outTypes:A,inputs:e,update:n,globals:i,construct:s}){super({inTypes:t,outTypes:A,inputs:e,update:n,globals:i,generate:t=>this.generateBlock(t)}),this.construct=s}generateBlock({inputs:t,outputs:A,compile:e}){var n,i;const s={},a={};for(const A in t)null!=t[A]&&(s[A]=new G(this.inTypes[A],t[A]));for(const t in A)null!=A[t]&&(a[t]=new k(this.outTypes[t]));const r={roots:[]},o=this.construct(s,a,r);for(const i of(null==(n=this.globals)?void 0:n.call(this,{inputs:t,outputs:A,compile:e}))??[])e.globals.add(i);const g=[],c=new Map;function l(t,A,n){let i=c.get(t);if(!i){i={sequence:e.nextSequence(),outNames:new Map,newOuts:new Set},c.set(t,i);for(const A in t.inputs){let e=t.inputs[A];for(;e;){if(e instanceof k){e instanceof T&&l(e.dyno,e.key);break}e=e.dynoOut()}}g.push(t)}A&&(n||i.newOuts.add(A),i.outNames.set(A,n??`${A}_${i.sequence}`))}for(const t of r.roots)l(t);for(const t in a){let e=(null==o?void 0:o[t])??a[t];for(;e;){if(e instanceof k){e instanceof T&&l(e.dyno,e.key,A[t]);break}e=e.dynoOut()}a[t]=e}const I=[];for(const t of g){const A={},n={};for(const e in t.inputs){let n=t.inputs[e];for(;n;){if(n instanceof k){if(n instanceof G)A[e]=n.getLiteral();else if(n instanceof T){const t=null==(i=c.get(n.dyno))?void 0:i.outNames.get(n.key);if(!t)throw new Error(`Source not found for ${n.dyno.constructor.name}.${n.key}`);A[e]=t}break}n=n.dynoOut()}}const s=c.get(t)??{outNames:new Map};for(const[t,A]of s.outNames.entries())n[t]=A;const a=t.compile({inputs:A,outputs:n,compile:e});I.push(a)}const h=[];for(const t in A)a[t]instanceof G&&h.push(`${A[t]} = ${a[t].getLiteral()};`);return h.length>0&&I.push(h),{statements:I.flatMap((t,A)=>0===A?t:["",...t])}}}function O(t,A,e,{update:n,globals:i}={}){return new z({inTypes:t,outTypes:A,construct:e,update:n,globals:i})}function K({inTypes:t,outTypes:A,inputs:e,update:n,globals:i,statements:s,generate:a}){return new q({inTypes:t,outTypes:A,inputs:e,update:n,globals:i,statements:s,generate:a})}function V(t,A,e){const n="string"==typeof A?A:A.type;if(!n)throw new Error(`Invalid DynoType: ${String(A)}`);return`${n} ${t}${null!=e?`[${e}]`:""}`}function W(t){var A;let e=!1;const n=t.split("\n").map(t=>{const A=t.trimEnd();return e?A:A.length>0?(e=!0,A):null}).filter(t=>null!=t);for(;n.length>0&&0===n[n.length-1].length;)n.pop();if(0===n.length)return[];const i=null==(A=n[0].match(/^\s*/))?void 0:A[0];if(!i)return n;const s=new RegExp(`^${i}`);return n.map(t=>t.replace(s,""))}function j(t){return W(t).join("\n")}class Z extends q{constructor({a:t,outKey:A,outTypeFunc:e}){const n={a:N(t)},i=e(N(t));super({inTypes:n,outTypes:{[A]:i},inputs:{a:t}}),this.outKey=A}dynoOut(){return new T(this,this.outKey)}}class X extends q{constructor({a:t,b:A,outKey:e,outTypeFunc:n}){const i={a:N(t),b:N(A)},s=n(N(t),N(A));super({inTypes:i,outTypes:{[e]:s},inputs:{a:t,b:A}}),this.outKey=e}dynoOut(){return new T(this,this.outKey)}}class $ extends q{constructor({a:t,b:A,c:e,outKey:n,outTypeFunc:i}){const s={a:N(t),b:N(A),c:N(e)},a=i(N(t),N(A),N(e));super({inTypes:s,outTypes:{[n]:a},inputs:{a:t,b:A,c:e}}),this.outKey=n}dynoOut(){return new T(this,this.outKey)}}const tt={type:"Gsplat"},At={type:"PackedSplats"},et=(t,A)=>new It({packedSplats:t,index:A}),nt=(t,A,e,n)=>new ht({packedSplats:t,index:A,base:e,count:n}),it=t=>new ut({gsplat:t}),st=({gsplat:t,flags:A,index:e,center:n,scales:i,quaternion:s,rgba:a,rgb:r,opacity:o,x:g,y:c,z:l,r:I,g:h,b:u})=>new Bt({gsplat:t,flags:A,index:e,center:n,scales:i,quaternion:s,rgba:a,rgb:r,opacity:o,x:g,y:c,z:l,r:I,g:h,b:u}),at=t=>new Ct({gsplat:t}),rt=(t,{scale:A,rotate:e,translate:n,recolor:i})=>new Et({gsplat:t,scale:A,rotate:e,translate:n,recolor:i}),ot=j("\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n"),gt=j("\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n");class ct extends Z{constructor({packedSplats:t}){super({a:t,outKey:"numSplats",outTypeFunc:()=>"int"}),this.statements=({inputs:t,outputs:A})=>[`${A.numSplats} = ${t.a}.numSplats;`]}}const lt=j("\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n");class It extends q{constructor({packedSplats:t,index:A}){super({inTypes:{packedSplats:At,index:"int"},outTypes:{gsplat:tt},inputs:{packedSplats:t,index:A},globals:()=>[ot,gt,lt],statements:({inputs:t,outputs:A})=>{const{gsplat:e}=A;if(!e)return[];const{packedSplats:n,index:i}=t;let s;return s=n&&i?W(`\n            if (readPackedSplat(${n}.texture, ${n}.numSplats, ${i}, ${e})) {\n              bool zeroSize = all(equal(${e}.scales, vec3(0.0, 0.0, 0.0)));\n              ${e}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${e}.flags = 0u;\n            }\n          `):[`${e}.flags = 0u;`],s.push(`${e}.index = ${i??"0"};`),s}})}dynoOut(){return new T(this,"gsplat")}}class ht extends q{constructor({packedSplats:t,index:A,base:e,count:n}){super({inTypes:{packedSplats:At,index:"int",base:"int",count:"int"},outTypes:{gsplat:tt},inputs:{packedSplats:t,index:A,base:e,count:n},globals:()=>[ot,gt,lt],statements:({inputs:t,outputs:A})=>{const{gsplat:e}=A;if(!e)return[];const{packedSplats:n,index:i,base:s,count:a}=t;let r;return r=n&&i&&s&&a?W(`\n            ${e}.flags = 0u;\n            if ((${i} >= ${s}) && (${i} < (${s} + ${a}))) {\n              if (readPackedSplat(${n}.texture, ${n}.numSplats, ${i}, ${e})) {\n                bool zeroSize = all(equal(${e}.scales, vec3(0.0, 0.0, 0.0)));\n                ${e}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `):[`${e}.flags = 0u;`],r.push(`${e}.index = ${i??"0"};`),r}})}dynoOut(){return new T(this,"gsplat")}}class ut extends q{constructor({gsplat:t}){super({inTypes:{gsplat:tt},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:t},globals:()=>[ot],statements:({inputs:t,outputs:A})=>{const{gsplat:e}=t,{flags:n,active:i,index:s,center:a,scales:r,quaternion:o,rgba:g,rgb:c,opacity:l,x:I,y:h,z:u,r:B,g:d,b:C}=A;return[n?`${n} = ${e?`${e}.flags`:"0u"};`:null,i?`${i} = isGsplatActive(${e?`${e}.flags`:"0u"});`:null,s?`${s} = ${e?`${e}.index`:"0"};`:null,a?`${a} = ${e?`${e}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,r?`${r} = ${e?`${e}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,o?`${o} = ${e?`${e}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,g?`${g} = ${e?`${e}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,c?`${c} = ${e?`${e}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,l?`${l} = ${e?`${e}.rgba.a`:"0.0"};`:null,I?`${I} = ${e?`${e}.center.x`:"0.0"};`:null,h?`${h} = ${e?`${e}.center.y`:"0.0"};`:null,u?`${u} = ${e?`${e}.center.z`:"0.0"};`:null,B?`${B} = ${e?`${e}.rgba.r`:"0.0"};`:null,d?`${d} = ${e?`${e}.rgba.g`:"0.0"};`:null,C?`${C} = ${e?`${e}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class Bt extends q{constructor({gsplat:t,flags:A,index:e,center:n,scales:i,quaternion:s,rgba:a,rgb:r,opacity:o,x:g,y:c,z:l,r:I,g:h,b:u}){super({inTypes:{gsplat:tt,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:tt},inputs:{gsplat:t,flags:A,index:e,center:n,scales:i,quaternion:s,rgba:a,rgb:r,opacity:o,x:g,y:c,z:l,r:I,g:h,b:u},globals:()=>[ot],statements:({inputs:t,outputs:A})=>{const{gsplat:e}=A;if(!e)return[];const{gsplat:n,flags:i,index:s,center:a,scales:r,quaternion:o,rgba:g,rgb:c,opacity:l,x:I,y:h,z:u,r:B,g:d,b:C}=t;return[`${e}.flags = ${i??(n?`${n}.flags`:"0u")};`,`${e}.index = ${s??(n?`${n}.index`:"0")};`,`${e}.center = ${a??(n?`${n}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${e}.scales = ${r??(n?`${n}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${e}.quaternion = ${o??(n?`${n}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${e}.rgba = ${g??(n?`${n}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,c?`${e}.rgba.rgb = ${c};`:null,l?`${e}.rgba.a = ${l};`:null,I?`${e}.center.x = ${I};`:null,h?`${e}.center.y = ${h};`:null,u?`${e}.center.z = ${u};`:null,B?`${e}.rgba.r = ${B};`:null,d?`${e}.rgba.g = ${d};`:null,C?`${e}.rgba.b = ${C};`:null].filter(Boolean)}})}dynoOut(){return new T(this,"gsplat")}}const dt=j("\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n");class Ct extends Z{constructor({gsplat:t}){super({a:t,outKey:"normal",outTypeFunc:()=>"vec3"}),this.globals=()=>[ot,dt],this.statements=({inputs:t,outputs:A})=>[`${A.normal} = gsplatNormal(${t.a}.scales, ${t.a}.quaternion);`]}}class Et extends q{constructor({gsplat:t,scale:A,rotate:e,translate:n,recolor:i}){super({inTypes:{gsplat:tt,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:tt},inputs:{gsplat:t,scale:A,rotate:e,translate:n,recolor:i},globals:()=>[ot],statements:({inputs:t,outputs:A,compile:e})=>{const{gsplat:n}=A;if(!n||!t.gsplat)return[];const{scale:i,rotate:s,translate:a,recolor:r}=t,o=e.indent;return[`${n} = ${t.gsplat};`,`if (isGsplatActive(${n}.flags)) {`,i?`${o}${n}.center *= ${i};`:null,s?`${o}${n}.center = quatVec(${s}, ${n}.center);`:null,a?`${o}${n}.center += ${a};`:null,i?`${o}${n}.scales *= ${i};`:null,s?`${o}${n}.quaternion = quatQuat(${s}, ${n}.quaternion);`:null,r?`${o}${n}.rgba *= ${r};`:null,"}"].filter(Boolean)}})}dynoOut(){return new T(this,"gsplat")}}const Qt=t=>new pt({gsplat:t});class pt extends q{constructor({gsplat:t}){super({inTypes:{gsplat:tt},inputs:{gsplat:t},globals:()=>[ot],statements:({inputs:t,outputs:A})=>{const{output:e}=A;if(!e)return[];const{gsplat:n}=t;return n?W(`\n            if (isGsplatActive(${n}.flags)) {\n              ${e} = packSplat(${n}.center, ${n}.scales, ${n}.quaternion, ${n}.rgba);\n            } else {\n              ${e} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `):[`${e} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new T(this,"output")}}class ft extends q{constructor({rgba8:t}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:t},statements:({inputs:t,outputs:A})=>[`target = ${t.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new T(this,"rgba8")}}const mt=(t=0,A)=>new vt({key:A,value:t}),yt=(t,A)=>new Tt({key:A,value:t});class wt extends q{constructor({key:t,type:A,count:e,value:n,update:i,globals:s}){t=t??"value",super({outTypes:{[t]:A},update:()=>{if(i){const t=i(this.value);void 0!==t&&(this.value=t)}this.uniform.value=this.value},generate:({inputs:n,outputs:i})=>{const a=(null==s?void 0:s({inputs:n,outputs:i}))??[],r={},o=i[t];return o&&(a.push(`uniform ${V(o,A,e)};`),r[o]=this.uniform),{globals:a,uniforms:r}}}),this.type=A,this.count=e,this.value=n,this.uniform={value:n},this.outKey=t}dynoOut(){return new T(this,this.outKey)}}class xt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"bool",value:A,update:e})}}class St extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"uint",value:A,update:e})}}class Dt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"int",value:A,update:e})}}class vt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"float",value:A,update:e})}}class Mt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"bvec2",value:A,update:e})}}class bt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"uvec2",value:A,update:e})}}class _t extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"ivec2",value:A,update:e})}}class Rt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"vec2",value:A,update:e})}}class Ft extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"bvec3",value:A,update:e})}}class Nt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"uvec3",value:A,update:e})}}class kt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"ivec3",value:A,update:e})}}class Tt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"vec3",value:A,update:e})}}class Gt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"bvec4",value:A,update:e})}}class Ut extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"uvec4",value:A,update:e})}}class Lt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"ivec4",value:A,update:e})}}class Ht extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"vec4",value:A,update:e})}}class Yt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat2",value:A,update:e})}}class Pt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat2x2",value:A,update:e})}}class Jt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat2x3",value:A,update:e})}}class qt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat2x4",value:A,update:e})}}class zt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat3",value:A,update:e})}}class Ot extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat3x2",value:A,update:e})}}class Kt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat3x3",value:A,update:e})}}class Vt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat3x4",value:A,update:e})}}class Wt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat4",value:A,update:e})}}class jt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat4x2",value:A,update:e})}}class Zt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat4x3",value:A,update:e})}}class Xt extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"mat4x4",value:A,update:e})}}class $t extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"usampler2D",value:A,update:e})}}class tA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"isampler2D",value:A,update:e})}}class AA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"sampler2D",value:A,update:e})}}class eA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"usampler2DArray",value:A,update:e})}}class nA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"isampler2DArray",value:A,update:e})}}class iA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"sampler2DArray",value:A,update:e})}}class sA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"usampler3D",value:A,update:e})}}class aA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"isampler3D",value:A,update:e})}}class rA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"sampler3D",value:A,update:e})}}class oA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"usamplerCube",value:A,update:e})}}class gA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"isamplerCube",value:A,update:e})}}class cA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"samplerCube",value:A,update:e})}}class lA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"sampler2DShadow",value:A,update:e})}}class IA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"sampler2DArrayShadow",value:A,update:e})}}class hA extends wt{constructor({key:t,value:A,update:e}){super({key:t,type:"samplerCubeShadow",value:A,update:e})}}var uA=Uint8Array,BA=Uint16Array,dA=Int32Array,CA=new uA([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),EA=new uA([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),QA=new uA([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),pA=function(t,A){for(var e=new BA(31),n=0;n<31;++n)e[n]=A+=1<<t[n-1];var i=new dA(e[30]);for(n=1;n<30;++n)for(var s=e[n];s<e[n+1];++s)i[s]=s-e[n]<<5|n;return{b:e,r:i}},fA=pA(CA,2),mA=fA.b,yA=fA.r;mA[28]=258,yA[258]=28;for(var wA=pA(EA,0).b,xA=new BA(32768),SA=0;SA<32768;++SA){var DA=(43690&SA)>>1|(21845&SA)<<1;DA=(61680&(DA=(52428&DA)>>2|(13107&DA)<<2))>>4|(3855&DA)<<4,xA[SA]=((65280&DA)>>8|(255&DA)<<8)>>1}var vA=function(t,A,e){for(var n=t.length,i=0,s=new BA(A);i<n;++i)t[i]&&++s[t[i]-1];var a,r=new BA(A);for(i=1;i<A;++i)r[i]=r[i-1]+s[i-1]<<1;if(e){a=new BA(1<<A);var o=15-A;for(i=0;i<n;++i)if(t[i])for(var g=i<<4|t[i],c=A-t[i],l=r[t[i]-1]++<<c,I=l|(1<<c)-1;l<=I;++l)a[xA[l]>>o]=g}else for(a=new BA(n),i=0;i<n;++i)t[i]&&(a[i]=xA[r[t[i]-1]++]>>15-t[i]);return a},MA=new uA(288);for(SA=0;SA<144;++SA)MA[SA]=8;for(SA=144;SA<256;++SA)MA[SA]=9;for(SA=256;SA<280;++SA)MA[SA]=7;for(SA=280;SA<288;++SA)MA[SA]=8;var bA=new uA(32);for(SA=0;SA<32;++SA)bA[SA]=5;var _A=vA(MA,9,1),RA=vA(bA,5,1),FA=function(t){for(var A=t[0],e=1;e<t.length;++e)t[e]>A&&(A=t[e]);return A},NA=function(t,A,e){var n=A/8|0;return(t[n]|t[n+1]<<8)>>(7&A)&e},kA=function(t,A){var e=A/8|0;return(t[e]|t[e+1]<<8|t[e+2]<<16)>>(7&A)},TA=function(t){return(t+7)/8|0},GA=function(t,A,e){return(null==A||A<0)&&(A=0),(null==e||e>t.length)&&(e=t.length),new uA(t.subarray(A,e))},UA=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],LA=function(t,A,e){var n=new Error(A||UA[t]);if(n.code=t,Error.captureStackTrace&&Error.captureStackTrace(n,LA),!e)throw n;return n},HA=new uA(0),YA=function(){function t(t,A){"function"==typeof t&&(A=t,t={}),this.ondata=A;var e=t&&t.dictionary&&t.dictionary.subarray(-32768);this.s={i:0,b:e?e.length:0},this.o=new uA(32768),this.p=new uA(0),e&&this.o.set(e)}return t.prototype.e=function(t){if(this.ondata||LA(5),this.d&&LA(4),this.p.length){if(t.length){var A=new uA(this.p.length+t.length);A.set(this.p),A.set(t,this.p.length),this.p=A}}else this.p=t},t.prototype.c=function(t){this.s.i=+(this.d=t||!1);var A=this.s.b,e=function(t,A,e){var n=t.length;if(!n||A.f&&!A.l)return e||new uA(0);var i=!e,s=i||2!=A.i,a=A.i;i&&(e=new uA(3*n));var r=function(t){var A=e.length;if(t>A){var n=new uA(Math.max(2*A,t));n.set(e),e=n}},o=A.f||0,g=A.p||0,c=A.b||0,l=A.l,I=A.d,h=A.m,u=A.n,B=8*n;do{if(!l){o=NA(t,g,1);var d=NA(t,g+1,3);if(g+=3,!d){var C=t[(v=TA(g)+4)-4]|t[v-3]<<8,E=v+C;if(E>n){a&&LA(0);break}s&&r(c+C),e.set(t.subarray(v,E),c),A.b=c+=C,A.p=g=8*E,A.f=o;continue}if(1==d)l=_A,I=RA,h=9,u=5;else if(2==d){var Q=NA(t,g,31)+257,p=NA(t,g+10,15)+4,f=Q+NA(t,g+5,31)+1;g+=14;for(var m=new uA(f),y=new uA(19),w=0;w<p;++w)y[QA[w]]=NA(t,g+3*w,7);g+=3*p;var x=FA(y),S=(1<<x)-1,D=vA(y,x,1);for(w=0;w<f;){var v,M=D[NA(t,g,S)];if(g+=15&M,(v=M>>4)<16)m[w++]=v;else{var b=0,_=0;for(16==v?(_=3+NA(t,g,3),g+=2,b=m[w-1]):17==v?(_=3+NA(t,g,7),g+=3):18==v&&(_=11+NA(t,g,127),g+=7);_--;)m[w++]=b}}var R=m.subarray(0,Q),F=m.subarray(Q);h=FA(R),u=FA(F),l=vA(R,h,1),I=vA(F,u,1)}else LA(1);if(g>B){a&&LA(0);break}}s&&r(c+131072);for(var N=(1<<h)-1,k=(1<<u)-1,T=g;;T=g){var G=(b=l[kA(t,g)&N])>>4;if((g+=15&b)>B){a&&LA(0);break}if(b||LA(2),G<256)e[c++]=G;else{if(256==G){T=g,l=null;break}var U=G-254;if(G>264){var L=CA[w=G-257];U=NA(t,g,(1<<L)-1)+mA[w],g+=L}var H=I[kA(t,g)&k],Y=H>>4;if(H||LA(3),g+=15&H,F=wA[Y],Y>3&&(L=EA[Y],F+=kA(t,g)&(1<<L)-1,g+=L),g>B){a&&LA(0);break}s&&r(c+131072);var P=c+U;if(c<F){var J=0-F,q=Math.min(F,P);for(J+c<0&&LA(3);c<q;++c)e[c]=undefined[J+c]}for(;c<P;++c)e[c]=e[c-F]}}A.l=l,A.p=T,A.b=c,A.f=o,l&&(o=1,A.m=h,A.d=I,A.n=u)}while(!o);return c!=e.length&&i?GA(e,0,c):e.subarray(0,c)}(this.p,this.s,this.o);this.ondata(GA(e,A,this.s.b),this.d),this.o=GA(e,this.s.b-32768),this.s.b=this.o.length,this.p=GA(this.p,this.s.p/8|0),this.s.p&=7},t.prototype.push=function(t,A){this.e(t),this.c(A)},t}(),PA=function(){function t(t,A){this.v=1,this.r=0,YA.call(this,t,A)}return t.prototype.push=function(t,A){if(YA.prototype.e.call(this,t),this.r+=t.length,this.v){var e=this.p.subarray(this.v-1),n=e.length>3?function(t){31==t[0]&&139==t[1]&&8==t[2]||LA(6,"invalid gzip data");var A=t[3],e=10;4&A&&(e+=2+(t[10]|t[11]<<8));for(var n=(A>>3&1)+(A>>4&1);n>0;n-=!t[e++]);return e+(2&A)}(e):4;if(n>e.length){if(!A)return}else this.v>1&&this.onmember&&this.onmember(this.r-e.length);this.p=e.subarray(n),this.v=0}YA.prototype.c.call(this,A),!this.s.f||this.s.l||A||(this.v=TA(this.s.p)+9,this.s={i:0},this.o=new uA(0),this.push(new uA(0),A))},t}(),JA="undefined"!=typeof TextDecoder&&new TextDecoder;try{JA.decode(HA,{stream:!0})}catch(t){}const qA=new Float32Array(1),zA=new Uint32Array(qA.buffer);function OA(t){qA[0]=t;const A=zA[0],e=A>>23&255,n=8388607&A,i=(A>>31&1)<<15;if(255===e)return 0!==n?32767|i:31744|i;const s=e-127+15;return s>=31?31744|i:s<=0?s<-10?i:i|(8388608|n)>>1-s+13:i|s<<10|n>>13}function KA(t){const A=t>>15&1,e=t>>10&31,n=1023&t;let i;if(0===e)if(0===n)i=A<<31;else{let t=n,e=-14;for(;!(1024&t);)t<<=1,e--;t&=1023,i=A<<31|e+127<<23|t<<13}else i=31===e?0===n?A<<31|2139095040:A<<31|2143289344:A<<31|e-15+127<<23|n<<13;return zA[0]=i,qA[0]}function VA(t){return Math.max(0,Math.min(255,Math.round(255*t)))}function WA(t){return Math.max(-127,Math.min(127,Math.round(127*t)))}function jA(t){return t/255}function ZA(t){return t/127}function XA(t){const A=[],e=new Set;return function t(n){n&&"object"==typeof n&&!e.has(n)&&(e.add(n),n instanceof ArrayBuffer?A.push(n):ArrayBuffer.isView(n)?A.push(n.buffer):Array.isArray(n)?n.forEach(t):Object.values(n).forEach(t))}(t),A}class $A{constructor({allocate:t,dispose:A,valid:e}){this.items=[],this.allocate=t,this.dispose=A,this.valid=e}alloc(t){for(;;){const A=this.items.pop();if(!A)break;if(this.valid(A,t))return A;this.dispose&&this.dispose(A)}return this.allocate(t)}free(t){this.items.push(t)}disposeAll(){let t;for(t=this.items.pop();t;)this.dispose&&this.dispose(t),t=this.items.pop()}}function te(t,A,e,i,s,a,r,o,l,I,h,u,B,d,C,E){const Q=VA(d),p=VA(C),f=VA(E),m=VA(B),y=de(new n.PTz(l,I,h,u)),w=255&y,x=y>>>8&255,S=y>>>16&255,D=0===a?0:Math.min(255,Math.max(0,Math.round((Math.log(a)-g)/c)+1)),v=0===r?0:Math.min(255,Math.max(0,Math.round((Math.log(r)-g)/c)+1)),M=0===o?0:Math.min(255,Math.max(0,Math.round((Math.log(o)-g)/c)+1)),b=OA(e),_=OA(i),R=OA(s),F=4*A;t[F]=Q|p<<8|f<<16|m<<24,t[F+1]=b|_<<16,t[F+2]=R|w<<16|x<<24,t[F+3]=D|v<<8|M<<16|S<<24}const Ae={center:new n.Pq0,scales:new n.Pq0,quaternion:new n.PTz,color:new n.Q1f,opacity:0};function ee(t,A){const e=Ae,n=4*A,i=t[n],s=t[n+1],a=t[n+2],r=t[n+3];e.color.set((255&i)/255,(i>>>8&255)/255,(i>>>16&255)/255),e.opacity=(i>>>24&255)/255,e.center.set(KA(65535&s),KA(s>>>16&65535),KA(65535&a));const o=255&r;e.scales.x=0===o?0:Math.exp(g+(o-1)*c);const l=r>>>8&255;e.scales.y=0===l?0:Math.exp(g+(l-1)*c);const I=r>>>16&255;return e.scales.z=0===I?0:Math.exp(g+(I-1)*c),Ce(a>>>16&65535|r>>>8&16711680,e.quaternion),e}function ne(t){const A=l,e=Math.max(h,Math.min(I,Math.ceil(t/A))),n=Math.ceil(t/(A*e));return{width:A,height:e,depth:n,maxSplats:A*e*n}}function ie(){return navigator.maxTouchPoints>0||/Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(navigator.userAgent)}function se(){return/Android/.test(navigator.userAgent)}function ae(){return/Oculus/.test(navigator.userAgent)}function re(t,A,e){const n=new Uint8Array(4*A);for(let i=0;i<e/2;i++){const s=i*A*4,a=(e-1-i)*A*4;n.set(t.subarray(s,s+4*A)),t.set(t.subarray(a,a+4*A),s),t.set(n,a)}return t}function oe(t,A,e){const n=document.createElement("canvas");n.width=A,n.height=e;const i=n.getContext("2d");if(!i)throw new Error("Can't get 2d context");const s=i.createImageData(A,e);return s.data.set(t),i.putImageData(s,0,0),n.toDataURL("image/png")}function ge(t){const A=new n.zD7(t.autoStart);return A.startTime=t.startTime,A.oldTime=t.oldTime,A.elapsedTime=t.elapsedTime,A.running=t.running,A}const ce=j("\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n");function le(t){const A=new n.Pq0;for(const e of t)A.add(e);return A.divideScalar(t.length)}function Ie(t){if(0===t.length)return new n.PTz;const A=t[0].clone();for(let e=1;e<t.length;e++)t[e].dot(t[0])<0?(A.x-=t[e].x,A.y-=t[e].y,A.z-=t[e].z,A.w-=t[e].w):(A.x+=t[e].x,A.y+=t[e].y,A.z+=t[e].z,A.w+=t[e].w);return A.normalize()}function he(t,A){const e=new n.Pq0(0,0,0).applyMatrix4(t),i=new n.Pq0(0,0,0).applyMatrix4(A),s=new n.Pq0(0,0,-1).applyMatrix4(t).sub(e).normalize(),a=new n.Pq0(0,0,-1).applyMatrix4(A).sub(i).normalize();return{distance:e.distanceTo(i),coincidence:s.dot(a)}}function ue(t,A){const[e,i]=[new n.Pq0,new n.PTz],[s,a]=[new n.Pq0,new n.PTz];return t.decompose(e,i,new n.Pq0),A.decompose(s,a,new n.Pq0),{distance:e.distanceTo(s),coorient:Math.abs(i.dot(a))}}function Be({matrix1:t,matrix2:A,maxDistance:e,minCoorient:n}){const{distance:i,coorient:s}=ue(t,A);return i<=e&&(null==n||s>=n)}function de(t){const A=t.clone().normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const e=2*Math.acos(A.w),i=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),s=i<1e-6?new n.Pq0(1,0,0):new n.Pq0(A.x,A.y,A.z).divideScalar(i),a=Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z);let r=s.x/a,o=s.y/a;if(s.z<0){const t=r;r=(1-Math.abs(o))*(r>=0?1:-1),o=(1-Math.abs(t))*(o>=0?1:-1)}const g=.5*r+.5,c=.5*o+.5,l=Math.round(255*g),I=Math.round(255*c);return Math.round(e*(255/Math.PI))<<16|I<<8|l}function Ce(t,A){const e=t>>>16&255;let i=2*((255&t)/255-.5),s=2*((t>>>8&255)/255-.5);const a=1-(Math.abs(i)+Math.abs(s)),r=Math.max(-a,0);i+=i>=0?-r:r,s+=s>=0?-r:r;const o=new n.Pq0(i,s,a).normalize(),g=e/255*Math.PI*.5,c=Math.sin(g),l=Math.cos(g);return A.set(o.x*c,o.y*c,o.z*c,l),A}function Ee(t,A,e,n){return 255&Math.max(-127,Math.min(127,127*t))|(255&Math.max(-127,Math.min(127,127*A)))<<8|(255&Math.max(-127,Math.min(127,127*e)))<<16|(255&Math.max(-127,Math.min(127,127*n)))<<24}function Qe(t,A){const e=[];let n=0,i=null;const s=new PA((t,s)=>{if(e.push(t),n+=t.length,s||n>=A){const t=new Uint8Array(n);let s=0;for(const A of e)t.set(A,s),s+=A.length;i=t.slice(0,A)}});let a=0;for(;null==i&&a<t.length;){const A=t.slice(a,a+1024);s.push(A,!1),a+=1024}if(null==i&&(s.push(new Uint8Array,!0),null==i))throw new Error("Failed to decompress partial gzip");return i}class pe{constructor({fileBytes:t,chunkBytes:A=65536}){this.fileBytes=t,this.chunkBytes=A,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new PA((t,A)=>{this.chunks.push(t),this.totalBytes+=t.length})}read(t){for(;this.totalBytes<t&&this.offset<this.fileBytes.length;){const t=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,t),!1),this.offset=t}if(this.totalBytes<t&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<t)throw new Error(`Unexpected EOF: needed ${t}, got ${this.totalBytes}`);const A=new Uint8Array(this.totalBytes);let e=0;for(const t of this.chunks)A.set(t,e),e+=t.length;const n=A.subarray(0,t);return this.chunks=[A.subarray(t)],this.totalBytes-=t,n}}const fe=Object.freeze(Object.defineProperty({__proto__:null,DataCache:class{constructor({asyncFetch:t,maxItems:A=5}){this.asyncFetch=t,this.maxItems=A,this.items=[]}async getFetch(t){const A=this.items.findIndex(A=>A.key===t);if(A>=0){const t=this.items.splice(A,1)[0];return this.items.push(t),t.data}const e=await this.asyncFetch(t);for(this.items.push({key:t,data:e});this.items.length>this.maxItems;)this.items.shift();return e}},FreeList:$A,GunzipReader:pe,IDENT_VERTEX_SHADER:ce,Sint8ToFloat:ZA,Uint8ToFloat:jA,averagePositions:le,averageQuaternions:Ie,cloneClock:ge,coinciDist:he,computeMaxSplats:function(t){const A=l,e=Math.max(h,Math.min(I,Math.ceil(t/A)));return A*e*Math.ceil(t/(A*e))},coorientDist:ue,decodeQuatEulerXyz888:function(t,A){const e=(t>>>8&255)/255,n=(t>>>16&255)/255,i=(255&t)/255*(2*Math.PI)-Math.PI,s=e*(2*Math.PI)-Math.PI,a=n*(2*Math.PI)-Math.PI,r=Math.cos(.5*i),o=Math.sin(.5*i),g=Math.cos(.5*s),c=Math.sin(.5*s),l=Math.cos(.5*a),I=Math.sin(.5*a);return A.w=r*g*l+o*c*I,A.x=o*g*l-r*c*I,A.y=r*c*l+o*g*I,A.z=r*g*I-o*c*l,A.normalize(),A},decodeQuatOctXy88R8:Ce,decodeQuatXyz888:function(t,A){const e=t<<24>>24,n=t<<16>>24,i=t<<8>>24;A.set(e/127,n/127,i/127,0);const s=A.x*A.x+A.y*A.y+A.z*A.z;return A.w=Math.sqrt(Math.max(0,1-s)),A},decompressPartialGzip:Qe,encodeQuatEulerXyz888:function(t){const A=t.clone().normalize(),e=2*(A.w*A.x+A.y*A.z),n=1-2*(A.x*A.x+A.y*A.y),i=Math.atan2(e,n),s=2*(A.w*A.y-A.z*A.x),a=Math.abs(s)>=1?Math.sign(s)*(Math.PI/2):Math.asin(s),r=2*(A.w*A.z+A.x*A.y),o=1-2*(A.y*A.y+A.z*A.z),g=Math.atan2(r,o),c=(i+Math.PI)/(2*Math.PI),l=(a+Math.PI)/(2*Math.PI),I=(g+Math.PI)/(2*Math.PI),h=Math.round(255*c),u=Math.round(255*l);return Math.round(255*I)<<16|u<<8|h},encodeQuatOctXy88R8:de,encodeQuatXyz888:function(t){const A=t.w<0;return 255&WA(A?-t.x:t.x)|(255&WA(A?-t.y:t.y))<<8|(255&WA(A?-t.z:t.z))<<16},encodeSh1Rgb:function(t,A,e){const n=2*A;for(let A=0;A<9;++A){const i=127&Math.max(-63,Math.min(63,63*e[A])),s=7*A,a=s+7,r=Math.floor(s/32),o=s-32*r,g=i<<o&4294967295;if(t[n+r]|=g,a>32*r+32){const A=i>>>32-o&4294967295;t[n+r+1]|=A}}},encodeSh2Rgb:function(t,A,e){t[4*A+0]=Ee(e[0],e[1],e[2],e[3]),t[4*A+1]=Ee(e[4],e[5],e[6],e[7]),t[4*A+2]=Ee(e[8],e[9],e[10],e[11]),t[4*A+3]=Ee(e[12],e[13],e[14],0)},encodeSh3Rgb:function(t,A,e){const n=4*A;for(let A=0;A<21;++A){const i=63&Math.max(-31,Math.min(31,31*e[A])),s=6*A,a=s+6,r=Math.floor(s/32),o=s-32*r,g=i<<o&4294967295;if(t[n+r]|=g,a>32*r+32){const A=i>>>32-o&4294967295;t[n+r+1]|=A}}},epsilonSign:function(t,A=.001){return Math.abs(t)<A?0:Math.sign(t)},flipPixels:re,floatBitsToUint:function(t){return qA[0]=t,zA[0]},floatToSint8:WA,floatToUint8:VA,fromHalf:KA,getArrayBuffers:XA,getTextureSize:ne,isAndroid:se,isMobile:ie,isOculus:ae,mapFilterObject:function(t,A){const e=Object.entries(t).map(([t,e])=>[t,A(e,t)]).filter(([t,A])=>void 0!==A);return Object.fromEntries(e)},mapObject:function(t,A){const e=Object.entries(t).map(([t,e])=>[t,A(e,t)]);return Object.fromEntries(e)},newArray:function(t,A){return new Array(t).fill(null).map((t,e)=>A(e))},omitUndefined:function(t){return Object.fromEntries(Object.entries(t).filter(([t,A])=>void 0!==A))},pixelsToPngUrl:oe,setPackedSplat:te,setPackedSplatCenter:function(t,A,e,n,i){const s=OA(e),a=OA(n),r=OA(i),o=4*A;t[o+1]=s|a<<16,t[o+2]=r|4294901760&t[o+2]},setPackedSplatOpacity:function(t,A,e){const n=VA(e),i=4*A;t[i]=16777215&t[i]|n<<24},setPackedSplatQuat:function(t,A,e,i,s,a){const r=de(new n.PTz(e,i,s,a)),o=255&r,g=r>>>8&255,c=r>>>16&255,l=4*A;t[l+2]=65535&t[l+2]|o<<16|g<<24,t[l+3]=16777215&t[l+3]|c<<24},setPackedSplatRgb:function(t,A,e,n,i){const s=VA(e),a=VA(n),r=VA(i),o=4*A;t[o]=s|a<<8|r<<16|4278190080&t[o]},setPackedSplatRgba:function(t,A,e,n,i,s){const a=VA(e),r=VA(n),o=VA(i),g=VA(s);t[4*A]=a|r<<8|o<<16|g<<24},setPackedSplatScales:function(t,A,e,n,i){const s=0===e?0:Math.min(255,Math.max(0,Math.round((Math.log(e)-g)/c)+1)),a=0===n?0:Math.min(255,Math.max(0,Math.round((Math.log(n)-g)/c)+1)),r=0===i?0:Math.min(255,Math.max(0,Math.round((Math.log(i)-g)/c)+1)),o=4*A;t[o+3]=s|a<<8|r<<16|4278190080&t[o+3]},toHalf:OA,uintBitsToFloat:function(t){return zA[0]=t,qA[0]},unpackSplat:ee,withinCoinciDist:function({matrix1:t,matrix2:A,maxDistance:e,minCoincidence:n}){const{distance:i,coincidence:s}=he(t,A);return i<=e&&(null==n||s>=n)},withinCoorientDist:Be,withinDist:function({matrix1:t,matrix2:A,maxDistance:e}){const i=new n.Pq0(0,0,0).applyMatrix4(t),s=new n.Pq0(0,0,0).applyMatrix4(A);return i.distanceTo(s)<=e}},Symbol.toStringTag,{value:"Module"}));class me{constructor({graph:t,inputs:A,outputs:e,template:n}){this.graph=t,this.template=n,this.inputs=A??{},this.outputs=e??{};const i=new J({indent:this.template.indent});for(const t in this.outputs)this.outputs[t]&&i.declares.add(this.outputs[t]);const s=t.compile({inputs:this.inputs,outputs:this.outputs,compile:i});this.shader=n.generate({globals:i.globals,statements:s}),this.uniforms=i.uniforms,this.updaters=i.updaters}prepareMaterial(){return function(t){let A=we.get(t);return A||(A=new n.D$Q({glslVersion:n.Wdf,vertexShader:ce,fragmentShader:t.shader,uniforms:t.uniforms}),we.set(t,A),A)}(this)}update(){for(const t of this.updaters)t()}}class ye{constructor(t){const A=t.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m),e=t.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);if(!A||!e)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=t.substring(0,A.index),this.between=t.substring(A.index+A[0].length,e.index),this.after=t.substring(e.index+e[0].length),this.indent=e[1]}generate({globals:t,statements:A}){return this.before+Array.from(t).join("\n\n")+this.between+A.map(t=>this.indent+t).join("\n")+this.after}}const we=new Map;function xe(t,A,e="add"){const n=()=>{throw new Error(`Invalid ${e} types: ${t}, ${A}`)};if(t===A)return t;if("int"===t){if(d(A))return A;n()}if("int"===A){if(d(t))return t;n()}if("uint"===t){if(C(A))return A;n()}if("uint"===A){if(C(t))return t;n()}if("float"===t){if(p(A))return A;n()}if("float"===A){if(p(t))return t;n()}throw new Error(`Invalid ${e} types: ${t}, ${A}`)}function Se(t,A){return xe(t,A,"sub")}function De(t,A){const e=()=>{throw new Error(`Invalid mul types: ${t}, ${A}`)};if("int"===t){if(d(A))return A;e()}if("int"===A){if(d(t))return t;e()}if("uint"===t){if(C(A))return A;e()}if("uint"===A){if(C(t))return t;e()}if("float"===t){if(p(A))return A;e()}if("float"===A){if(p(t))return t;e()}if(d(t)||C(t)||d(A)||C(A)){if(t===A)return t;e()}if("vec2"===t){if("vec2"===A||w(A))return"vec2";if("mat3x2"===A)return"vec3";if("mat4x2"===A)return"vec4";e()}if("vec3"===t){if("mat2x3"===A)return"vec2";if("vec3"===A||x(A))return"vec3";if("mat4x3"===A)return"vec4";e()}if("vec4"===t){if("mat2x4"===A)return"vec2";if("mat3x4"===A)return"vec3";if("vec4"===A||S(A))return"vec4";e()}if("vec2"===A){if(w(t))return"vec2";if("mat2x3"===t)return"vec3";if("mat2x4"===t)return"vec4";e()}if("vec3"===A){if("mat3x2"===t)return"vec2";if(x(t))return"vec3";if("mat3x4"===t)return"vec4";e()}if("vec4"===A){if("mat4x2"===t)return"vec2";if("mat4x3"===t)return"vec3";if(S(t))return"vec4";e()}if(w(t)){if(w(A))return"mat2";if("mat3x2"===A)return"mat3x2";if("mat4x2"===A)return"mat4x2";e()}if("mat2x3"===t){if(w(A))return"mat2x3";if("mat3x2"===A)return"mat3";if("mat4x2"===A)return"mat4x3";e()}if("mat2x4"===t){if(w(A))return"mat2x4";if("mat3x2"===A)return"mat3x4";if("mat4x2"===A)return"mat4";e()}if("mat3x2"===t){if("mat2x3"===A)return"mat2";if(x(A))return"mat3x2";if("mat4x3"===A)return"mat4x2";e()}if(x(t)){if("mat2x3"===A)return"mat2x3";if(x(A))return"mat3";if("mat4x3"===A)return"mat4x3";e()}if("mat3x4"===t){if("mat2x3"===A)return"mat2x4";if(x(A))return"mat3x4";if("mat4x3"===A)return"mat4";e()}if("mat4x2"===t){if("mat2x4"===A)return"mat2";if("mat3x4"===A)return"mat3x2";if(S(A))return"mat4x2";e()}if("mat4x3"===t){if("mat2x4"===A)return"mat2x3";if("mat3x4"===A)return"mat3";if(S(A))return"mat4x3";e()}if(S(t)){if("mat2x4"===A)return"mat2x4";if("mat3x4"===A)return"mat3x4";if(S(A))return"mat4";e()}throw new Error(`Invalid mul types: ${t}, ${A}`)}function ve(t,A){return xe(t,A,"div")}function Me(t,A){if(t===A)return t;if("int"===t){if(d(A))return A}else if("int"===A){if(d(t))return t}else if("uint"===t){if(C(A))return A}else if("uint"===A&&C(t))return t;throw new Error(`Invalid imod types: ${t}, ${A}`)}function be(t,A){if(t===A||"float"===A)return t;throw new Error(`Invalid mod types: ${t}, ${A}`)}function _e(t){return t}function Re(t){return t}function Fe(t){return t}function Ne(t){return t}function ke(t){return t}function Te(t){return t}function Ge(t){return t}function Ue(t){return t}function Le(t){return t}function He(t){return t}function Ye(t){return t}function Pe(t){return t}function Je(t){return t}function qe(t){return t}function ze(t){return t}function Oe(t){return t}function Ke(t,A,e="min"){if(t===A)return t;if("float"===A){if(E(t))return t}else if("int"===A){if(d(t))return t}else if("uint"===A&&C(t))return t;throw new Error(`Invalid ${e} types: ${t}, ${A}`)}function Ve(t,A){return Ke(t,A,"max")}function We(t,A,e){if("float"===A){if(E(t))return t}else if("int"===A){if(d(t))return t}else if("uint"===A&&C(t))return t;throw new Error(`Invalid clamp types: ${t}, ${A}`)}function je(t,A,e){if(e===t)return t;if("float"===e)return t;if("bool"===e&&"float"===t)return t;if("bvec2"===e&&"vec2"===t)return t;if("bvec3"===e&&"vec3"===t)return t;if("bvec4"===e&&"vec4"===t)return t;throw new Error(`Invalid mix types: ${t}, ${A}, ${e}`)}function Ze(t,A){if(t===A||"float"===A)return A;throw new Error(`Invalid step types: ${t}, ${A}`)}function Xe(t,A,e){if(t===A&&(t===e||"float"===t))return e;throw new Error(`Invalid smoothstep types: ${t}, ${A}, ${e}`)}function $e(t,A="isNan"){if("float"===t)return"bool";if("vec2"===t)return"bvec2";if("vec3"===t)return"bvec3";if("vec4"===t)return"bvec4";throw new Error(`Invalid ${A} types: ${t}`)}function tn(t){return $e(t,"isInf")}const An=(t,A)=>new In({a:t,b:A}),en=(t,A)=>new hn({a:t,b:A}),nn=(t,A)=>new un({a:t,b:A}),sn=(t,A)=>new Bn({a:t,b:A}),an=(t,A)=>new dn({a:t,b:A}),rn=(t,A)=>new Cn({a:t,b:A}),on=t=>new Qn({a:t}),gn=t=>new Sn({a:t}),cn=(t,A)=>new Tn({a:t,b:A}),ln=(t,A,e)=>new Un({a:t,b:A,t:e});class In extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"sum",outTypeFunc:xe}),this.statements=({inputs:t,outputs:A})=>[`${A.sum} = ${t.a} + ${t.b};`]}}class hn extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"difference",outTypeFunc:Se}),this.statements=({inputs:t,outputs:A})=>[`${A.difference} = ${t.a} - ${t.b};`]}}class un extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"product",outTypeFunc:De}),this.statements=({inputs:t,outputs:A})=>[`${A.product} = ${t.a} * ${t.b};`]}}class Bn extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"quotient",outTypeFunc:ve}),this.statements=({inputs:t,outputs:A})=>[`${A.quotient} = ${t.a} / ${t.b};`]}}class dn extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"remainder",outTypeFunc:Me}),this.statements=({inputs:t,outputs:A})=>[`${A.remainder} = ${t.a} % ${t.b};`]}}class Cn extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"remainder",outTypeFunc:be}),this.statements=({inputs:t,outputs:A})=>[`${A.remainder} = mod(${t.a}, ${t.b});`]}}class En extends q{constructor({a:t}){const A={a:N(t)},e=A.a;super({inTypes:A,outTypes:{fract:e,integer:e},inputs:{a:t}}),this.statements=({inputs:t,outputs:A})=>[`${A.fract} = modf(${t.a}, ${A.integer});`]}}class Qn extends Z{constructor({a:t}){super({a:t,outKey:"neg",outTypeFunc:_e}),this.statements=({inputs:t,outputs:A})=>[`${A.neg} = -${t.a};`]}}class pn extends Z{constructor({a:t}){super({a:t,outKey:"abs",outTypeFunc:Re}),this.statements=({inputs:t,outputs:A})=>[`${A.abs} = abs(${t.a});`]}}class fn extends Z{constructor({a:t}){super({a:t,outKey:"sign",outTypeFunc:Fe}),this.statements=({inputs:t,outputs:A})=>[`${A.sign} = sign(${t.a});`]}}class mn extends Z{constructor({a:t}){super({a:t,outKey:"floor",outTypeFunc:Ne}),this.statements=({inputs:t,outputs:A})=>[`${A.floor} = floor(${t.a});`]}}class yn extends Z{constructor({a:t}){super({a:t,outKey:"ceil",outTypeFunc:ke}),this.statements=({inputs:t,outputs:A})=>[`${A.ceil} = ceil(${t.a});`]}}class wn extends Z{constructor({a:t}){super({a:t,outKey:"trunc",outTypeFunc:Te}),this.statements=({inputs:t,outputs:A})=>[`${A.trunc} = trunc(${t.a});`]}}class xn extends Z{constructor({a:t}){super({a:t,outKey:"round",outTypeFunc:Ge}),this.statements=({inputs:t,outputs:A})=>[`${A.round} = round(${t.a});`]}}class Sn extends Z{constructor({a:t}){super({a:t,outKey:"fract",outTypeFunc:Ue}),this.statements=({inputs:t,outputs:A})=>[`${A.fract} = fract(${t.a});`]}}class Dn extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"power",outTypeFunc:Le}),this.statements=({inputs:t,outputs:A})=>[`${A.power} = pow(${t.a}, ${t.b});`]}}class vn extends Z{constructor({a:t}){super({a:t,outKey:"exp",outTypeFunc:He}),this.statements=({inputs:t,outputs:A})=>[`${A.exp} = exp(${t.a});`]}}class Mn extends Z{constructor({a:t}){super({a:t,outKey:"exp2",outTypeFunc:Ye}),this.statements=({inputs:t,outputs:A})=>[`${A.exp2} = exp2(${t.a});`]}}class bn extends Z{constructor({a:t}){super({a:t,outKey:"log",outTypeFunc:Pe}),this.statements=({inputs:t,outputs:A})=>[`${A.log} = log(${t.a});`]}}class _n extends Z{constructor({a:t}){super({a:t,outKey:"log2",outTypeFunc:Je}),this.statements=({inputs:t,outputs:A})=>[`${A.log2} = log2(${t.a});`]}}class Rn extends Z{constructor({a:t}){super({a:t,outKey:"sqr",outTypeFunc:qe}),this.statements=({inputs:t,outputs:A})=>[`${A.sqr} = ${t.a} * ${t.a};`]}}class Fn extends Z{constructor({a:t}){super({a:t,outKey:"sqrt",outTypeFunc:ze}),this.statements=({inputs:t,outputs:A})=>[`${A.sqrt} = sqrt(${t.a});`]}}class Nn extends Z{constructor({a:t}){super({a:t,outKey:"inversesqrt",outTypeFunc:Oe}),this.statements=({inputs:t,outputs:A})=>[`${A.inversesqrt} = inversesqrt(${t.a});`]}}class kn extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"min",outTypeFunc:Ke}),this.statements=({inputs:t,outputs:A})=>[`${A.min} = min(${t.a}, ${t.b});`]}}class Tn extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"max",outTypeFunc:Ve}),this.statements=({inputs:t,outputs:A})=>[`${A.max} = max(${t.a}, ${t.b});`]}}class Gn extends ${constructor({a:t,min:A,max:e}){super({a:t,b:A,c:e,outKey:"clamp",outTypeFunc:We}),this.statements=({inputs:t,outputs:A})=>{const{a:e,b:n,c:i}=t;return[`${A.clamp} = clamp(${e}, ${n}, ${i});`]}}}class Un extends ${constructor({a:t,b:A,t:e}){super({a:t,b:A,c:e,outKey:"mix",outTypeFunc:je}),this.statements=({inputs:t,outputs:A})=>{const{a:e,b:n,c:i}=t;return[`${A.mix} = mix(${e}, ${n}, ${i});`]}}}class Ln extends X{constructor({edge:t,x:A}){super({a:t,b:A,outKey:"step",outTypeFunc:Ze}),this.statements=({inputs:t,outputs:A})=>{const{a:e,b:n}=t;return[`${A.step} = step(${e}, ${n});`]}}}class Hn extends ${constructor({edge0:t,edge1:A,x:e}){super({a:t,b:A,c:e,outKey:"smoothstep",outTypeFunc:Xe}),this.statements=({inputs:t,outputs:A})=>{const{a:e,b:n,c:i}=t;return[`${A.smoothstep} = smoothstep(${e}, ${n}, ${i});`]}}}class Yn extends Z{constructor({a:t}){super({a:t,outKey:"isNan",outTypeFunc:$e}),this.statements=({inputs:t,outputs:A})=>[`${A.isNan} = isNan(${t.a});`]}}class Pn extends Z{constructor({a:t}){super({a:t,outKey:"isInf",outTypeFunc:tn}),this.statements=({inputs:t,outputs:A})=>[`${A.isInf} = isInf(${t.a});`]}}const Jn=(t,A)=>new Xn({a:t,b:A}),qn=(t,A,e)=>new ni({cond:t,t:A,f:e});class zn extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:(t,A)=>t,outKey:"and"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.and?[`${A.and} = ${t.a} && ${t.b};`]:[`${A.and} = ${t.a} & ${t.b};`]}}class On extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:(t,A)=>t,outKey:"or"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.or?[`${A.or} = ${t.a} || ${t.b};`]:[`${A.or} = ${t.a} | ${t.b};`]}}class Kn extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:(t,A)=>t,outKey:"xor"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.xor?[`${A.xor} = ${t.a} ^^ ${t.b};`]:[`${A.xor} = ${t.a} ^ ${t.b};`]}}class Vn extends Z{constructor({a:t}){super({a:t,outTypeFunc:t=>t,outKey:"not"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.not?[`${A.not} = !${t.a};`]:[`${A.not} = not(${t.a});`]}}class Wn extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:(t,A)=>ii(t,"lessThan"),outKey:"lessThan"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.lessThan?[`${A.lessThan} = ${t.a} < ${t.b};`]:[`${A.lessThan} = lessThan(${t.a}, ${t.b});`]}}class jn extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:(t,A)=>ii(t,"lessThanEqual"),outKey:"lessThanEqual"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.lessThanEqual?[`${A.lessThanEqual} = ${t.a} <= ${t.b};`]:[`${A.lessThanEqual} = lessThanEqual(${t.a}, ${t.b});`]}}class Zn extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:(t,A)=>ii(t,"greaterThan"),outKey:"greaterThan"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.greaterThan?[`${A.greaterThan} = ${t.a} > ${t.b};`]:[`${A.greaterThan} = greaterThan(${t.a}, ${t.b});`]}}class Xn extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:(t,A)=>ii(t,"greaterThanEqual"),outKey:"greaterThanEqual"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.greaterThanEqual?[`${A.greaterThanEqual} = ${t.a} >= ${t.b};`]:[`${A.greaterThanEqual} = greaterThanEqual(${t.a}, ${t.b});`]}}class $n extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:si,outKey:"equal"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.equal?[`${A.equal} = ${t.a} == ${t.b};`]:[`${A.equal} = equal(${t.a}, ${t.b});`]}}class ti extends X{constructor({a:t,b:A}){super({a:t,b:A,outTypeFunc:ai,outKey:"notEqual"}),this.statements=({inputs:t,outputs:A})=>"bool"===this.outTypes.notEqual?[`${A.notEqual} = ${t.a} != ${t.b};`]:[`${A.notEqual} = notEqual(${t.a}, ${t.b});`]}}class Ai extends Z{constructor({a:t}){super({a:t,outTypeFunc:t=>"bool",outKey:"any"}),this.statements=({inputs:t,outputs:A})=>[`${A.any} = any(${t.a});`]}}class ei extends Z{constructor({a:t}){super({a:t,outTypeFunc:t=>"bool",outKey:"all"}),this.statements=({inputs:t,outputs:A})=>[`${A.all} = all(${t.a});`]}}class ni extends ${constructor({cond:t,t:A,f:e}){super({a:t,b:A,c:e,outKey:"select",outTypeFunc:(t,A,e)=>A}),this.statements=({inputs:t,outputs:A})=>{const{a:e,b:n,c:i}=t;return[`${A.select} = (${e}) ? (${n}) : (${i});`]}}}function ii(t,A){if(B(t))return"bool";if("ivec2"===t||"uvec2"===t||"vec2"===t)return"bvec2";if("ivec3"===t||"uvec3"===t||"vec3"===t)return"bvec3";if("ivec4"===t||"uvec4"===t||"vec4"===t)return"bvec4";throw new Error(`Invalid ${A} type: ${t}`)}function si(t,A="equal"){if(B(t))return"bool";if(u(t))return t;if("ivec2"===t||"uvec2"===t||"vec2"===t)return"bvec2";if("ivec3"===t||"uvec3"===t||"vec3"===t)return"bvec3";if("ivec4"===t||"uvec4"===t||"vec4"===t)return"bvec4";throw new Error(`Invalid ${A} type: ${t}`)}function ai(t){return si(t,"notEqual")}class ri extends Z{constructor({a:t}){const A=function(t){if(u(t))return"bool";if(d(t))return"int";if(C(t))return"uint";throw new Error(`Invalid compXor type: ${t}`)}(N(t));super({a:t,outTypeFunc:t=>A,outKey:"compXor"}),this.statements=({inputs:t,outputs:e})=>{if(B(this.outTypes.compXor))return[`${e.compXor} = ${t.a};`];const n=(f(A)?["x","y"]:m(A)?["x","y","z"]:["x","y","z","w"]).map(A=>`${t.a}.${A}`),i=u(A)?"^^":"^";return[`${e.compXor} = ${n.join(` ${i} `)};`]}}}const oi=t=>new Qi({value:t}),gi=t=>new Mi({value:t}),ci=t=>new bi({value:t}),li=t=>new _i({value:t}),Ii=t=>new ki({value:t}),hi=t=>new Ji({value:t}),ui=t=>new zi({value:t});class Bi extends Z{constructor({value:t,outType:A,outKey:e}){super({a:t,outTypeFunc:()=>A,outKey:e}),this.statements=({inputs:t,outputs:n})=>[`${n[e]} = ${b(A)}(${t.a});`]}}class di extends Bi{constructor({value:t}){super({value:t,outType:"bool",outKey:"bool"})}}class Ci extends Bi{constructor({value:t}){super({value:t,outType:"int",outKey:"int"})}}class Ei extends Bi{constructor({value:t}){super({value:t,outType:"uint",outKey:"uint"})}}class Qi extends Bi{constructor({value:t}){super({value:t,outType:"float",outKey:"float"})}}class pi extends Bi{constructor({value:t}){super({value:t,outType:"bvec2",outKey:"bvec2"})}}class fi extends Bi{constructor({value:t}){super({value:t,outType:"bvec3",outKey:"bvec3"})}}class mi extends Bi{constructor({value:t}){super({value:t,outType:"bvec4",outKey:"bvec4"})}}class yi extends Bi{constructor({value:t}){super({value:t,outType:"ivec2",outKey:"ivec2"})}}class wi extends Bi{constructor({value:t}){super({value:t,outType:"ivec3",outKey:"ivec3"})}}class xi extends Bi{constructor({value:t}){super({value:t,outType:"ivec4",outKey:"ivec4"})}}class Si extends Bi{constructor({value:t}){super({value:t,outType:"uvec2",outKey:"uvec2"})}}class Di extends Bi{constructor({value:t}){super({value:t,outType:"uvec3",outKey:"uvec3"})}}class vi extends Bi{constructor({value:t}){super({value:t,outType:"uvec4",outKey:"uvec4"})}}class Mi extends Bi{constructor({value:t}){super({value:t,outType:"vec2",outKey:"vec2"})}}class bi extends Bi{constructor({value:t}){super({value:t,outType:"vec3",outKey:"vec3"})}}class _i extends Bi{constructor({value:t}){super({value:t,outType:"vec4",outKey:"vec4"})}}class Ri extends Bi{constructor({value:t}){super({value:t,outType:"mat2",outKey:"mat2"})}}class Fi extends Bi{constructor({value:t}){super({value:t,outType:"mat3",outKey:"mat3"})}}class Ni extends Bi{constructor({value:t}){super({value:t,outType:"mat4",outKey:"mat4"})}}class ki extends Z{constructor({value:t}){super({a:t,outKey:"int",outTypeFunc:()=>"int"}),this.statements=({inputs:t,outputs:A})=>[`${A.int} = floatBitsToInt(${t.a});`]}}class Ti extends Z{constructor({value:t}){super({a:t,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:t,outputs:A})=>[`${A.uint} = floatBitsToUint(${t.a});`]}}class Gi extends Z{constructor({value:t}){super({a:t,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:t,outputs:A})=>[`${A.float} = intBitsToFloat(${t.a});`]}}class Ui extends Z{constructor({value:t}){super({a:t,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:t,outputs:A})=>[`${A.float} = uintBitsToFloat(${t.a});`]}}class Li extends Z{constructor({value:t}){super({a:t,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:t,outputs:A})=>[`${A.uint} = packSnorm2x16(${t.a});`]}}class Hi extends Z{constructor({value:t}){super({a:t,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:t,outputs:A})=>[`${A.vec2} = unpackSnorm2x16(${t.a});`]}}class Yi extends Z{constructor({value:t}){super({a:t,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:t,outputs:A})=>[`${A.uint} = packUnorm2x16(${t.a});`]}}class Pi extends Z{constructor({value:t}){super({a:t,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:t,outputs:A})=>[`${A.vec2} = unpackUnorm2x16(${t.a});`]}}class Ji extends Z{constructor({value:t}){super({a:t,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:t,outputs:A})=>[`${A.uint} = packHalf2x16(${t.a});`]}}class qi extends Z{constructor({value:t}){super({a:t,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:t,outputs:A})=>[`${A.vec2} = unpackHalf2x16(${t.a});`]}}class zi extends Z{constructor({value:t}){super({a:t,outKey:"rgba8",outTypeFunc:()=>"vec4"}),this.statements=({inputs:t,outputs:A})=>[`uvec4 uRgba = uvec4(${t.a} & 0xffu, (${t.a} >> 8u) & 0xffu, (${t.a} >> 16u) & 0xffu, (${t.a} >> 24u) & 0xffu);`,`${A.rgba8} = vec4(uRgba) / 255.0;`]}}const Oi=(t,A)=>new $i({a:t,b:A}),Ki=t=>new As({a:t}),Vi=t=>new us({vector:t}),Wi=({vector:t,vectorType:A,x:e,y:n,z:i,w:s,r:a,g:r,b:o,a:g})=>new Bs({vector:t,vectorType:A,x:e,y:n,z:i,w:s,r:a,g:r,b:o,a:g}),ji=(t,A)=>new ns({a:t,b:A});class Zi extends Z{constructor({a:t}){super({a:t,outTypeFunc:t=>"float",outKey:"length"}),this.statements=({inputs:t,outputs:A})=>[`${A.length} = length(${t.a});`]}}class Xi extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"distance",outTypeFunc:(t,A)=>"float"}),this.statements=({inputs:t,outputs:A})=>[`${A.distance} = distance(${t.a}, ${t.b});`]}}class $i extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"dot",outTypeFunc:(t,A)=>"float"}),this.statements=({inputs:t,outputs:A})=>[`${A.dot} = dot(${t.a}, ${t.b});`]}}class ts extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"cross",outTypeFunc:(t,A)=>"vec3"}),this.statements=({inputs:t,outputs:A})=>[`${A.cross} = cross(${t.a}, ${t.b});`]}}class As extends Z{constructor({a:t}){super({a:t,outTypeFunc:t=>t,outKey:"normalize"}),this.statements=({inputs:t,outputs:A})=>[`${A.normalize} = normalize(${t.a});`]}}class es extends Z{constructor({a:t}){super({a:t,outTypeFunc:t=>function(t){if("vec3"===t)return"vec2";if("vec4"===t)return"vec3";throw new Error("Invalid type")}(t),outKey:"projected"}),this.statements=({inputs:t,outputs:A})=>{if("vec3"===this.inTypes.a)return[`${A.projected} = ${t.a}.xy / ${t.a}.z;`];if("vec4"===this.inTypes.a)return[`${A.projected} = ${t.a}.xyz / ${t.a}.w;`];throw new Error("Invalid type")}}}class ns extends X{constructor({a:t,b:A}){const e=function(t){if("float"===t)return"vec2";if("vec2"===t)return"vec3";if("vec3"===t)return"vec4";throw new Error("Invalid type")}(N(t));super({a:t,b:A,outKey:"extend",outTypeFunc:()=>e}),this.statements=({inputs:t,outputs:A})=>[`${A.extend} = ${e}(${t.a}, ${t.b});`]}}class is extends ${constructor({a:t,b:A,c:e}){super({a:t,b:A,c:e,outKey:"forward",outTypeFunc:(t,A,e)=>t}),this.statements=({inputs:t,outputs:A})=>[`${A.forward} = faceforward(${t.a}, ${t.b}, ${t.c});`]}}class ss extends X{constructor({incident:t,normal:A}){super({a:t,b:A,outKey:"reflection",outTypeFunc:(t,A)=>t}),this.statements=({inputs:t,outputs:A})=>[`${A.reflection} = reflect(${t.a}, ${t.b});`]}}class as extends ${constructor({incident:t,normal:A,eta:e}){super({a:t,b:A,c:e,outKey:"refraction",outTypeFunc:(t,A,e)=>t}),this.statements=({inputs:t,outputs:A})=>[`${A.refraction} = refract(${t.a}, ${t.b}, ${t.c});`]}}class rs extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"product",outTypeFunc:(t,A)=>t}),this.statements=({inputs:e,outputs:n})=>[`${n.product} = matrixCompMult(${t}, ${A});`]}}function os(t,A){if("vec2"===t){if("vec2"===A)return"mat2";if("vec3"===A)return"mat3x2";if("vec4"===A)return"mat4x2"}if("vec3"===t){if("vec2"===A)return"mat2x3";if("vec3"===A)return"mat3";if("vec4"===A)return"mat4x3"}if("vec4"===t){if("vec2"===A)return"mat2x4";if("vec3"===A)return"mat3x4";if("vec4"===A)return"mat4"}throw new Error(`Invalid outer type: ${t}, ${A}`)}class gs extends X{constructor({a:t,b:A}){super({a:t,b:A,outKey:"outer",outTypeFunc:os}),this.statements=({inputs:t,outputs:A})=>[`${A.outer} = outerProduct(${t.a}, ${t.b});`]}}function cs(t){if("mat2"===t)return"mat2";if("mat3"===t)return"mat3";if("mat4"===t)return"mat4";if("mat2x2"===t)return"mat2x2";if("mat2x3"===t)return"mat3x2";if("mat2x4"===t)return"mat4x2";if("mat3x2"===t)return"mat2x3";if("mat3x3"===t)return"mat3x3";if("mat3x4"===t)return"mat4x3";if("mat4x2"===t)return"mat2x4";if("mat4x3"===t)return"mat3x4";if("mat4x4"===t)return"mat4x4";throw new Error(`Invalid transpose type: ${t}`)}class ls extends Z{constructor({a:t}){super({a:t,outKey:"transpose",outTypeFunc:cs}),this.statements=({inputs:t,outputs:A})=>[`${A.transpose} = transpose(${t.a});`]}}class Is extends Z{constructor({a:t}){super({a:t,outKey:"det",outTypeFunc:t=>"float"}),this.statements=({inputs:t,outputs:A})=>[`${A.det} = determinant(${t.a});`]}}class hs extends Z{constructor({a:t}){super({a:t,outKey:"inverse",outTypeFunc:t=>t}),this.statements=({inputs:A,outputs:e})=>[`${e.inverse} = inverse(${t});`]}}class us extends q{constructor({vector:t}){const A={vector:N(t)};super({inTypes:A,outTypes:function(t){switch(t){case"vec2":return{x:"float",y:"float",r:"float",g:"float"};case"vec3":return{x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"};case"vec4":return{x:"float",y:"float",z:"float",w:"float",r:"float",g:"float",b:"float",a:"float"};case"ivec2":return{x:"int",y:"int",r:"int",g:"int"};case"ivec3":return{x:"int",y:"int",z:"int",r:"int",g:"int",b:"int"};case"ivec4":return{x:"int",y:"int",z:"int",w:"int",r:"int",g:"int",b:"int",a:"int"};case"uvec2":return{x:"uint",y:"uint",r:"uint",g:"uint"};case"uvec3":return{x:"uint",y:"uint",z:"uint",r:"uint",g:"uint",b:"uint"};case"uvec4":return{x:"uint",y:"uint",z:"uint",w:"uint",r:"uint",g:"uint",b:"uint",a:"uint"};default:throw new Error(`Invalid vector type: ${t}`)}}(A.vector),inputs:{vector:t}}),this.statements=({inputs:t,outputs:A})=>{const{x:e,y:n,z:i,w:s,r:a,g:r,b:o,a:g}=A,{vector:c}=t;return[e?`${e} = ${c}.x;`:null,n?`${n} = ${c}.y;`:null,i?`${i} = ${c}.z;`:null,s?`${s} = ${c}.w;`:null,a?`${a} = ${c}.r;`:null,r?`${r} = ${c}.g;`:null,o?`${o} = ${c}.b;`:null,g?`${g} = ${c}.a;`:null].filter(Boolean)}}}class Bs extends q{constructor({vector:t,vectorType:A,x:e,y:n,z:i,w:s,r:a,g:r,b:o,a:g}){if(!t&&!A)throw new Error("Either vector or vectorType must be provided");const c=A??N(t),l=D(c),I=v(c),h={vector:c,x:l,y:l,r:l,g:l},u={vector:t,x:e,y:n,r:a,g:r};I>=3&&(Object.assign(h,{z:l,b:l}),Object.assign(u,{z:i,b:o})),I>=4&&(Object.assign(h,{w:l,a:l}),Object.assign(u,{w:s,a:g})),super({inTypes:h,outTypes:{vector:c},inputs:u}),this.statements=({inputs:t,outputs:A})=>{const{vector:e}=A,{vector:n,x:i,y:s,z:a,w:r,r:o,g,b:c,a:h}=t,u=[`${e}.x = ${i??o??(n?`${n}.x`:Y(l))};`,`${e}.y = ${s??g??(n?`${n}.y`:Y(l))};`];return I>=3&&u.push(`${e}.z = ${a??c??(n?`${n}.z`:Y(l))};`),I>=4&&u.push(`${e}.w = ${r??h??(n?`${n}.w`:Y(l))};`),u}}dynoOut(){return new T(this,"vector")}}class ds extends Z{constructor({vector:t,select:A}){super({a:t,outKey:"swizzle",outTypeFunc:t=>function(t,A){let e=null;if(E(t)?e=1===A.length?"float":2===A.length?"vec2":3===A.length?"vec3":4===A.length?"vec4":null:d(t)?e=1===A.length?"int":2===A.length?"ivec2":3===A.length?"ivec3":4===A.length?"ivec4":null:C(t)&&(e=1===A.length?"uint":2===A.length?"uvec2":3===A.length?"uvec3":4===A.length?"uvec4":null),null==e)throw new Error(`Invalid swizzle: ${A}`);return e}(t,A)}),this.statements=({inputs:t,outputs:e})=>[`${e.swizzle} = ${t.a}.${A};`]}}const Cs=t=>new vs({value:t}),Es=t=>new Ms({value:t}),Qs=t=>new bs({value:t}),ps=t=>new _s({value:t}),fs=t=>new Ns({value:t}),ms=t=>new ks({value:t}),ys=(t,A,e)=>new Ts({z:t,zNear:A,zFar:e}).outputs.depth;class ws extends q{constructor({from:t,to:A,index:e}){super({inTypes:{from:"int",to:"int",index:"int"},outTypes:{index:"int"},inputs:{from:t,to:A,index:e},statements:({inputs:t,outputs:A})=>[`${A.index} = ${t.index} - ${t.from} + ${t.to};`]})}dynoOut(){return new T(this,"index")}}class xs extends q{constructor({state:t}){const A=N(t);super({inTypes:{state:A},outTypes:{state:"uint"},inputs:{state:t},globals:()=>[j("\n          uint pcg_next(uint state) {\n            return state * 747796405u + 2891336453u;\n          }\n        ")],statements:({inputs:t,outputs:e})=>{const n="uint"===A?`${t.state}`:"int"===A?`uint(${t.state})`:`floatBitsToUint(${t.state})`;return[`${e.state} = pcg_next(${n});`]}})}dynoOut(){return new T(this,"state")}}class Ss extends q{constructor({state:t}){super({inTypes:{state:"uint"},outTypes:{hash:"uint"},inputs:{state:t},globals:()=>[j("\n          uint pcg_hash(uint state) {\n            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n            return (hash >> 22u) ^ hash;\n          }\n        ")],statements:({inputs:t,outputs:A})=>[`${A.hash} = pcg_hash(${t.state});`]})}dynoOut(){return new T(this,"hash")}}class Ds extends q{constructor({value:t}){const A=N(t),e=M(A);super({inTypes:{value:A},outTypes:{state:"uint"},inputs:{value:t},globals:()=>[j("\n          uint pcg_mix(uint value) {\n            return value;\n          }\n          uint pcg_mix(uvec2 value) {\n            return value.x + 0x9e3779b9u * value.y;\n          }\n          uint pcg_mix(uvec3 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\n          }\n          uint pcg_mix(uvec4 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\n          }\n        ")],statements:({inputs:t,outputs:n})=>{const i=C(A)?`${t.value}`:d(A)?`${e}(${t.value})`:`floatBitsToUint(${t.value})`;return[`${e} bits = ${i};`,`${n.state} = pcg_mix(bits);`]}})}dynoOut(){return new T(this,"state")}}class vs extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"uint"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");let A=new Ds({value:t}).outputs.state;return A=new xs({state:A}).outputs.state,new Ss({state:A}).outputs}})}dynoOut(){return new T(this,"hash")}}class Ms extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"uvec2"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");let A=new Ds({value:t}).outputs.state;A=new xs({state:A}).outputs.state;const e=new Ss({state:A}).outputs.hash;A=new xs({state:A}).outputs.state;const n=new Ss({state:A}).outputs.hash;return{hash:Wi({vectorType:"uvec2",x:e,y:n})}}})}dynoOut(){return new T(this,"hash")}}class bs extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"uvec3"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");let A=new Ds({value:t}).outputs.state;A=new xs({state:A}).outputs.state;const e=new Ss({state:A}).outputs.hash;A=new xs({state:A}).outputs.state;const n=new Ss({state:A}).outputs.hash;A=new xs({state:A}).outputs.state;const i=new Ss({state:A}).outputs.hash;return{hash:Wi({vectorType:"uvec3",x:e,y:n,z:i})}}})}dynoOut(){return new T(this,"hash")}}class _s extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"uvec4"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");let A=new Ds({value:t}).outputs.state;A=new xs({state:A}).outputs.state;const e=new Ss({state:A}).outputs.hash;A=new xs({state:A}).outputs.state;const n=new Ss({state:A}).outputs.hash;A=new xs({state:A}).outputs.state;const i=new Ss({state:A}).outputs.hash;A=new xs({state:A}).outputs.state;const s=new Ss({state:A}).outputs.hash;return{hash:Wi({vectorType:"uvec4",x:e,y:n,z:i,w:s})}}})}dynoOut(){return new T(this,"hash")}}class Rs extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"float"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");const A=Cs(t);return{hash:nn(oi(A),H("float",1/2**32))}}})}dynoOut(){return new T(this,"hash")}}class Fs extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"vec2"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");const A=Es(t);return{hash:nn(gi(A),H("float",1/2**32))}}})}dynoOut(){return new T(this,"hash")}}class Ns extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"vec3"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");const A=Qs(t);return{hash:nn(ci(A),H("float",1/2**32))}}})}dynoOut(){return new T(this,"hash")}}class ks extends z{constructor({value:t}){super({inTypes:{value:N(t)},outTypes:{hash:"vec4"},inputs:{value:t},construct:({value:t})=>{if(!t)throw new Error("value is required");const A=ps(t);return{hash:nn(li(A),H("float",1/2**32))}}})}dynoOut(){return new T(this,"hash")}}class Ts extends q{constructor({z:t,zNear:A,zFar:e}){super({inTypes:{z:"float",zNear:"float",zFar:"float"},outTypes:{depth:"float"},inputs:{z:t,zNear:A,zFar:e},statements:({inputs:t,outputs:A})=>[`float clamped = clamp(${t.z}, ${t.zNear}, ${t.zFar});`,`${A.depth} = (log2(clamped + 1.0) - log2(${t.zNear} + 1.0)) / (log2(${t.zFar} + 1.0) - log2(${t.zNear} + 1.0));`]})}dynoOut(){return new T(this,"depth")}}const Gs=(t,{scale:A,scales:e,rotate:n,translate:i})=>new Ls({position:t,scale:A,scales:e,rotate:n,translate:i}).outputs.position,Us=(t,{scale:A,scales:e,rotate:n})=>new Hs({dir:t,scale:A,scales:e,rotate:n}).outputs.dir;class Ls extends q{constructor({position:t,scale:A,scales:e,rotate:n,translate:i}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:t,scale:A,scales:e,rotate:n,translate:i},statements:({inputs:t,outputs:A})=>{const{position:e}=A;if(!e)return[];const{scale:n,scales:i,rotate:s,translate:a}=t;return[`${e} = ${t.position??"vec3(0.0, 0.0, 0.0)"};`,n?`${e} *= ${n};`:null,i?`${e} *= ${i};`:null,s?`${e} = quatVec(${s}, ${e});`:null,a?`${e} += ${a};`:null].filter(Boolean)}})}}class Hs extends q{constructor({dir:t,scale:A,scales:e,rotate:n}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:t,scale:A,scales:e,rotate:n},statements:({inputs:t,outputs:A})=>{const{dir:e}=A;if(!e)return[];const{scale:n,scales:i,rotate:s}=t;return[`${e} = ${t.dir??"vec3(0.0, 0.0, 0.0)"};`,n?`${e} *= ${n};`:null,i?`${e} *= ${i};`:null,s?`${e} = quatVec(${s}, ${e});`:null].filter(Boolean)}})}}class Ys extends q{constructor({quaternion:t,rotate:A}){super({inTypes:{quaternion:"vec4",rotate:"vec4"},outTypes:{quaternion:"vec4"},inputs:{quaternion:t,rotate:A},statements:({inputs:t,outputs:e})=>{const{quaternion:n}=e;return n?[`${n} = ${t.quaternion??"vec4(0.0, 0.0, 0.0, 1.0)"};`,A?`${n} = quatQuat(${t.rotate}, ${n});`:null].filter(Boolean):[]}})}}class Ps extends q{constructor({texture:t,lod:A}){const e=N(t);super({inTypes:{texture:e,lod:"int"},outTypes:{size:zs(e)},inputs:{texture:t,lod:A},statements:({inputs:t,outputs:A})=>[`${A.size} = textureSize(${t.texture}, ${t.lod??"0"});`]})}dynoOut(){return new T(this,"size")}}class Js extends q{constructor({texture:t,coord:A,bias:e}){const n=N(t);super({inTypes:{texture:n,coord:Os(n),bias:"float"},outTypes:{sample:Ks(n)},inputs:{texture:t,coord:A,bias:e},statements:({inputs:t,outputs:A})=>[`${A.sample} = texture(${t.texture}, ${t.coord}${t.bias?`, ${t.bias}`:""});`]})}dynoOut(){return new T(this,"sample")}}class qs extends q{constructor({texture:t,coord:A,lod:e}){const n=N(t);super({inTypes:{texture:n,coord:zs(n),lod:"int"},outTypes:{texel:Ks(n)},inputs:{texture:t,coord:A,lod:e},statements:({inputs:t,outputs:A})=>[`${A.texel} = texelFetch(${t.texture}, ${t.coord}, ${t.lod??"0"});`]})}dynoOut(){return new T(this,"texel")}}function zs(t){switch(t){case"sampler2D":case"usampler2D":case"isampler2D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DShadow":case"samplerCubeShadow":return"ivec2";case"sampler3D":case"usampler3D":case"isampler3D":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DArrayShadow":return"ivec3";default:throw new Error(`Invalid texture type: ${t}`)}}function Os(t){switch(t){case"sampler2D":case"usampler2D":case"isampler2D":return"vec2";case"sampler3D":case"usampler3D":case"isampler3D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DShadow":return"vec3";case"samplerCubeShadow":case"sampler2DArrayShadow":return"vec4";default:throw new Error(`Invalid texture type: ${t}`)}}function Ks(t){switch(t){case"sampler2D":case"sampler2DArray":case"sampler3D":case"samplerCube":case"sampler2DShadow":return"vec4";case"usampler2D":case"usampler2DArray":case"usampler3D":case"usamplerCube":return"uvec4";case"isampler2D":case"isampler2DArray":case"isampler3D":case"isamplerCube":return"ivec4";case"samplerCubeShadow":case"sampler2DArrayShadow":return"float";default:throw new Error(`Invalid texture type: ${t}`)}}const Vs=t=>new Zs({radians:t});class Ws extends Z{constructor({degrees:t}){super({a:t,outTypeFunc:t=>t,outKey:"radians"}),this.statements=({inputs:t,outputs:A})=>[`${A.radians} = radians(${t.a});`]}}class js extends Z{constructor({radians:t}){super({a:t,outTypeFunc:t=>t,outKey:"degrees"}),this.statements=({inputs:t,outputs:A})=>[`${A.degrees} = degrees(${t.a});`]}}class Zs extends Z{constructor({radians:t}){super({a:t,outTypeFunc:t=>t,outKey:"sin"}),this.statements=({inputs:t,outputs:A})=>[`${A.sin} = sin(${t.a});`]}}class Xs extends Z{constructor({radians:t}){super({a:t,outTypeFunc:t=>t,outKey:"cos"}),this.statements=({inputs:t,outputs:A})=>[`${A.cos} = cos(${t.a});`]}}class $s extends Z{constructor({radians:t}){super({a:t,outTypeFunc:t=>t,outKey:"tan"}),this.statements=({inputs:t,outputs:A})=>[`${A.tan} = tan(${t.a});`]}}class ta extends Z{constructor({sin:t}){super({a:t,outTypeFunc:t=>t,outKey:"asin"}),this.statements=({inputs:t,outputs:A})=>[`${A.asin} = asin(${t.a});`]}}class Aa extends Z{constructor({cos:t}){super({a:t,outTypeFunc:t=>t,outKey:"acos"}),this.statements=({inputs:t,outputs:A})=>[`${A.acos} = acos(${t.a});`]}}class ea extends Z{constructor({tan:t}){super({a:t,outTypeFunc:t=>t,outKey:"atan"}),this.statements=({inputs:t,outputs:A})=>[`${A.atan} = atan(${t.a});`]}}class na extends X{constructor({y:t,x:A}){super({a:t,b:A,outTypeFunc:(t,A)=>t,outKey:"atan2"}),this.statements=({inputs:t,outputs:A})=>[`${A.atan2} = atan2(${t.a}, ${t.b});`]}}class ia extends Z{constructor({x:t}){super({a:t,outTypeFunc:t=>t,outKey:"sinh"}),this.statements=({inputs:t,outputs:A})=>[`${A.sinh} = sinh(${t.a});`]}}class sa extends Z{constructor({x:t}){super({a:t,outTypeFunc:t=>t,outKey:"cosh"}),this.statements=({inputs:t,outputs:A})=>[`${A.cosh} = cosh(${t.a});`]}}class aa extends Z{constructor({x:t}){super({a:t,outTypeFunc:t=>t,outKey:"tanh"}),this.statements=({inputs:t,outputs:A})=>[`${A.tanh} = tanh(${t.a});`]}}class ra extends Z{constructor({x:t}){super({a:t,outTypeFunc:t=>t,outKey:"asinh"}),this.statements=({inputs:t,outputs:A})=>[`${A.asinh} = asinh(${t.a});`]}}class oa extends Z{constructor({x:t}){super({a:t,outTypeFunc:t=>t,outKey:"acosh"}),this.statements=({inputs:t,outputs:A})=>[`${A.acosh} = acosh(${t.a});`]}}class ga extends Z{constructor({x:t}){super({a:t,outTypeFunc:t=>t,outKey:"atanh"}),this.statements=({inputs:t,outputs:A})=>[`${A.atanh} = atanh(${t.a});`]}}const ca=Object.freeze(Object.defineProperty({__proto__:null,Abs:pn,Acos:Aa,Acosh:oa,Add:In,All:ei,And:zn,Any:Ai,Asin:ta,Asinh:ra,Atan:ea,Atan2:na,Atanh:ga,BVec2:pi,BVec3:fi,BVec4:mi,BinaryOp:X,Bool:di,Ceil:yn,Clamp:Gn,Combine:Bs,CombineGsplat:Bt,CompMult:rs,CompXor:ri,Compilation:J,Cos:Xs,Cosh:sa,Cross:ts,Degrees:js,Determinant:Is,Distance:Xi,Div:Bn,Dot:$i,Dyno:q,DynoBlock:z,DynoBool:xt,DynoBvec2:Mt,DynoBvec3:Ft,DynoBvec4:Gt,DynoConst:L,DynoFloat:vt,DynoInt:Dt,DynoIsampler2D:tA,DynoIsampler2DArray:nA,DynoIsampler3D:aA,DynoIsamplerCube:gA,DynoIvec2:_t,DynoIvec3:kt,DynoIvec4:Lt,DynoLiteral:G,DynoMat2:Yt,DynoMat2x2:Pt,DynoMat2x3:Jt,DynoMat2x4:qt,DynoMat3:zt,DynoMat3x2:Ot,DynoMat3x3:Kt,DynoMat3x4:Vt,DynoMat4:Wt,DynoMat4x2:jt,DynoMat4x3:Zt,DynoMat4x4:Xt,DynoOutput:T,DynoProgram:me,DynoProgramTemplate:ye,DynoRemapIndex:ws,DynoSampler2D:AA,DynoSampler2DArray:iA,DynoSampler2DArrayShadow:IA,DynoSampler2DShadow:lA,DynoSampler3D:rA,DynoSamplerCube:cA,DynoSamplerCubeShadow:hA,DynoUint:St,DynoUniform:wt,DynoUsampler2D:$t,DynoUsampler2DArray:eA,DynoUsampler3D:sA,DynoUsamplerCube:oA,DynoUvec2:bt,DynoUvec3:Nt,DynoUvec4:Ut,DynoValue:k,DynoVec2:Rt,DynoVec3:Tt,DynoVec4:Ht,Equal:$n,Exp:vn,Exp2:Mn,ExtendVec:ns,FaceForward:is,Float:Qi,FloatBitsToInt:ki,FloatBitsToUint:Ti,Floor:mn,Fract:Sn,GreaterThan:Zn,GreaterThanEqual:Xn,Gsplat:tt,GsplatNormal:Ct,Hash:vs,Hash2:Ms,Hash3:bs,Hash4:_s,HashFloat:Rs,HashVec2:Fs,HashVec3:Ns,HashVec4:ks,IMod:dn,IVec2:yi,IVec3:wi,IVec4:xi,Int:Ci,IntBitsToFloat:Gi,Inverse:hs,InverseSqrt:Nn,IsInf:Pn,IsNan:Yn,Length:Zi,LessThan:Wn,LessThanEqual:jn,Log:bn,Log2:_n,Mat2:Ri,Mat3:Fi,Mat4:Ni,Max:Tn,Min:kn,Mix:Un,Mod:Cn,Modf:En,Mul:un,Neg:Qn,Normalize:As,NormalizedDepth:Ts,Not:Vn,NotEqual:ti,NumPackedSplats:ct,Or:On,Outer:gs,OutputPackedSplat:pt,OutputRgba8:ft,PackHalf2x16:Ji,PackSnorm2x16:Li,PackUnorm2x16:Yi,PcgHash:Ss,PcgMix:Ds,PcgNext:xs,Pow:Dn,ProjectH:es,Radians:Ws,ReadPackedSplat:It,ReadPackedSplatRange:ht,ReflectVec:ss,RefractVec:as,Round:xn,Select:ni,Sign:fn,SimpleCast:Bi,Sin:Zs,Sinh:ia,Smoothstep:Hn,Split:us,SplitGsplat:ut,Sqr:Rn,Sqrt:Fn,Step:Ln,Sub:hn,Swizzle:ds,TPackedSplats:At,Tan:$s,Tanh:aa,TexelFetch:qs,Texture:Js,TextureSize:Ps,TransformDir:Hs,TransformGsplat:Et,TransformPosition:Ls,TransformQuaternion:Ys,Transpose:ls,TrinaryOp:$,Trunc:wn,UVec2:Si,UVec3:Di,UVec4:vi,Uint:Ei,UintBitsToFloat:Ui,UintToRgba8:zi,UnaryOp:Z,UnpackHalf2x16:qi,UnpackSnorm2x16:Hi,UnpackUnorm2x16:Pi,Vec2:Mi,Vec3:bi,Vec4:_i,Xor:Kn,abs:t=>new pn({a:t}),acos:t=>new Aa({cos:t}),acosh:t=>new oa({x:t}),add:An,all:t=>new ei({a:t}),and:(t,A)=>new zn({a:t,b:A}),any:t=>new Ai({a:t}),arrayIndex:()=>{throw new Error("Not implemented")},arrayLength:()=>{throw new Error("Not implemented")},asin:t=>new ta({sin:t}),asinh:t=>new ra({x:t}),atan:t=>new ea({tan:t}),atan2:(t,A)=>new na({y:t,x:A}),atanh:t=>new ga({x:t}),bool:t=>new di({value:t}),bvec2:t=>new pi({value:t}),bvec3:t=>new fi({value:t}),bvec4:t=>new mi({value:t}),ceil:t=>new yn({a:t}),clamp:(t,A,e)=>new Gn({a:t,min:A,max:e}),combine:Wi,combineGsplat:st,comment:()=>{throw new Error("Not implemented")},compMult:(t,A)=>new rs({a:t,b:A}),compXor:t=>new ri({a:t}),cos:t=>new Xs({radians:t}),cosh:t=>new sa({x:t}),cross:(t,A)=>new ts({a:t,b:A}),defineGsplat:ot,defineGsplatNormal:dt,definePackedSplats:gt,degrees:t=>new js({radians:t}),determinant:t=>new Is({a:t}),distance:(t,A)=>new Xi({a:t,b:A}),div:sn,dot:Oi,dyno:K,dynoBlock:O,dynoBool:(t=!1,A)=>new xt({key:A,value:t}),dynoBvec2:(t,A)=>new Mt({key:A,value:t}),dynoBvec3:(t,A)=>new Ft({key:A,value:t}),dynoBvec4:(t,A)=>new Gt({key:A,value:t}),dynoConst:H,dynoDeclare:V,dynoFloat:mt,dynoFor:()=>{throw new Error("Not implemented")},dynoIf:()=>{throw new Error("Not implemented")},dynoInt:(t=0,A)=>new Dt({key:A,value:t}),dynoIsampler2D:(t,A)=>new tA({key:A,value:t}),dynoIsampler2DArray:(t,A)=>new nA({key:t,value:A}),dynoIsampler3D:(t,A)=>new aA({key:A,value:t}),dynoIsamplerCube:(t,A)=>new gA({key:A,value:t}),dynoIvec2:(t,A)=>new _t({key:A,value:t}),dynoIvec3:(t,A)=>new kt({key:A,value:t}),dynoIvec4:(t,A)=>new Lt({key:A,value:t}),dynoLiteral:U,dynoMat2:(t,A)=>new Yt({key:A,value:t}),dynoMat2x2:(t,A)=>new Pt({key:A,value:t}),dynoMat2x3:(t,A)=>new Jt({key:A,value:t}),dynoMat2x4:(t,A)=>new qt({key:A,value:t}),dynoMat3:(t,A)=>new zt({key:A,value:t}),dynoMat3x2:(t,A)=>new Ot({key:A,value:t}),dynoMat3x3:(t,A)=>new Kt({key:A,value:t}),dynoMat3x4:(t,A)=>new Vt({key:A,value:t}),dynoMat4:(t,A)=>new Wt({key:A,value:t}),dynoMat4x2:(t,A)=>new jt({key:A,value:t}),dynoMat4x3:(t,A)=>new Zt({key:A,value:t}),dynoMat4x4:(t,A)=>new Xt({key:A,value:t}),dynoSampler2D:(t,A)=>new AA({key:A,value:t}),dynoSampler2DArray:(t,A)=>new iA({key:A,value:t}),dynoSampler2DArrayShadow:(t,A)=>new IA({key:A,value:t}),dynoSampler2DShadow:(t,A)=>new lA({key:A,value:t}),dynoSampler3D:(t,A)=>new rA({key:A,value:t}),dynoSamplerCube:(t,A)=>new cA({key:A,value:t}),dynoSamplerCubeShadow:(t,A)=>new hA({key:A,value:t}),dynoSwitch:()=>{throw new Error("Not implemented")},dynoUint:(t=0,A)=>new St({key:A,value:t}),dynoUsampler2D:(t,A)=>new $t({key:A,value:t}),dynoUsampler2DArray:(t,A)=>new eA({key:A,value:t}),dynoUsampler3D:(t,A)=>new sA({key:A,value:t}),dynoUsamplerCube:(t,A)=>new oA({key:A,value:t}),dynoUvec2:(t,A)=>new bt({key:A,value:t}),dynoUvec3:(t,A)=>new Nt({key:A,value:t}),dynoUvec4:(t,A)=>new Ut({key:A,value:t}),dynoVec2:(t,A)=>new Rt({key:A,value:t}),dynoVec3:yt,dynoVec4:(t,A)=>new Ht({key:A,value:t}),equal:(t,A)=>new $n({a:t,b:A}),exp:t=>new vn({a:t}),exp2:t=>new Mn({a:t}),extendVec:ji,faceforward:(t,A,e)=>new is({a:t,b:A,c:e}),float:oi,floatBitsToInt:Ii,floatBitsToUint:t=>new Ti({value:t}),floor:t=>new mn({a:t}),fract:gn,greaterThan:(t,A)=>new Zn({a:t,b:A}),greaterThanEqual:Jn,gsplatNormal:at,hash:Cs,hash2:Es,hash3:Qs,hash4:ps,hashFloat:t=>new Rs({value:t}),hashVec2:t=>new Fs({value:t}),hashVec3:fs,hashVec4:ms,imod:an,int:t=>new Ci({value:t}),intBitsToFloat:t=>new Gi({value:t}),inverse:t=>new hs({a:t}),inversesqrt:t=>new Nn({a:t}),isAllFloatType:p,isBoolType:u,isFloatType:E,isInf:t=>new Pn({a:t}),isIntType:d,isMat2:w,isMat3:x,isMat4:S,isMatFloatType:Q,isNan:t=>new Yn({a:t}),isScalarType:B,isUintType:C,isVector2Type:f,isVector3Type:m,isVector4Type:y,isVectorType:function(t){return f(t)||m(t)||y(t)},ivec2:t=>new yi({value:t}),ivec3:t=>new wi({value:t}),ivec4:t=>new xi({value:t}),length:t=>new Zi({a:t}),lessThan:(t,A)=>new Wn({a:t,b:A}),lessThanEqual:(t,A)=>new jn({a:t,b:A}),literalNegOne:function(t){const A=String(t);if(u(t))return`${A}(true)`;if(p(t))return`${A}(-1.0)`;if(d(t))return`${A}(-1)`;if(C(t))return`${A}(0xFFFFFFFFu)`;throw new Error(`Type not implemented: ${A}`)},literalOne:function(t){const A=String(t);if(u(t))return`${A}(true)`;if(p(t))return`${A}(1.0)`;if(d(t))return`${A}(1)`;if(C(t))return`${A}(1u)`;throw new Error(`Type not implemented: ${A}`)},literalZero:Y,log:t=>new bn({a:t}),log2:t=>new _n({a:t}),mat2:t=>new Ri({value:t}),mat3:t=>new Fi({value:t}),mat4:t=>new Ni({value:t}),max:cn,min:(t,A)=>new kn({a:t,b:A}),mix:ln,mod:rn,modf:t=>new En({a:t}).outputs,mul:nn,neg:on,normalize:Ki,normalizedDepth:ys,not:t=>new Vn({a:t}),notEqual:(t,A)=>new ti({a:t,b:A}),numPackedSplats:t=>new ct({packedSplats:t}),numberAsFloat:F,numberAsInt:_,numberAsUint:R,or:(t,A)=>new On({a:t,b:A}),outer:(t,A)=>new gs({a:t,b:A}),outputPackedSplat:Qt,outputRgba8:t=>new ft({rgba8:t}),packHalf2x16:hi,packSnorm2x16:t=>new Li({value:t}),packUnorm2x16:t=>new Yi({value:t}),pcgHash:t=>new Ss({state:t}),pcgMix:t=>new Ds({value:t}),pcgNext:t=>new xs({state:t}),pow:(t,A)=>new Dn({a:t,b:A}),projectH:t=>new es({a:t}),radians:t=>new Ws({degrees:t}),readPackedSplat:et,readPackedSplatRange:nt,reflectVec:(t,A)=>new ss({incident:t,normal:A}),refractVec:(t,A,e)=>new as({incident:t,normal:A,eta:e}),remapIndex:(t,A,e)=>new ws({index:t,from:A,to:e}),round:t=>new xn({a:t}),sameSizeIvec:function(t){if(B(t))return"int";if(f(t))return"ivec2";if(m(t))return"ivec3";if(y(t))return"ivec4";throw new Error(`Invalid vector type: ${t}`)},sameSizeUvec:M,sameSizeVec:function(t){if(B(t))return"float";if(f(t))return"vec2";if(m(t))return"vec3";if(y(t))return"vec4";throw new Error(`Invalid vector type: ${t}`)},select:qn,sign:t=>new fn({a:t}),sin:Vs,sinh:t=>new ia({x:t}),smoothstep:(t,A,e)=>new Hn({edge0:t,edge1:A,x:e}),split:Vi,splitGsplat:it,sqr:t=>new Rn({a:t}),sqrt:t=>new Fn({a:t}),step:(t,A)=>new Ln({edge:t,x:A}),sub:en,swizzle:(t,A)=>new ds({vector:t,select:A}),tan:t=>new $s({radians:t}),tanh:t=>new aa({x:t}),texelFetch:(t,A,e)=>new qs({texture:t,coord:A,lod:e}),texture:(t,A,e)=>new Js({texture:t,coord:A,bias:e}),textureSize:(t,A)=>new Ps({texture:t,lod:A}),transformDir:Us,transformGsplat:rt,transformPos:Gs,transformQuat:(t,{rotate:A})=>new Ys({quaternion:t,rotate:A}).outputs.quaternion,transpose:t=>new ls({a:t}),trunc:t=>new wn({a:t}),typeLiteral:b,uint:t=>new Ei({value:t}),uintBitsToFloat:t=>new Ui({value:t}),uintToRgba8:ui,uniform:(t,A,e)=>new wt({key:t,type:A,value:e}),unindent:j,unindentLines:W,unpackHalf2x16:t=>new qi({value:t}),unpackSnorm2x16:t=>new Hi({value:t}),unpackUnorm2x16:t=>new Pi({value:t}),uvec2:t=>new Si({value:t}),uvec3:t=>new Di({value:t}),uvec4:t=>new vi({value:t}),valType:N,vec2:gi,vec3:ci,vec4:li,vectorDim:v,vectorElementType:D,xor:(t,A)=>new Kn({a:t,b:A})},Symbol.toStringTag,{value:"Module"})),la=class t{constructor({renderer:t}={}){this.renderer=t,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(t,A){const e=Math.ceil(Math.max(1,t)/l)*l*4;if(A.byteLength>=e)return A;const n=new ArrayBuffer(e);return A instanceof ArrayBuffer?n:new(0,A.constructor)(n)}ensureCapacity(t){const{width:A,height:e,depth:i,maxSplats:s}=ne(t);(!this.target||s>this.capacity)&&(this.dispose(),this.capacity=s,this.target=new n.y9J(A,e,i,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:n.hxR,minFilter:n.hxR}),this.target.texture.format=n.GWd,this.target.texture.type=n.OUM,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(A){let e=t.readbackProgram.get(A);if(!e){const n=O({index:"int"},{rgba8:"vec4"},({index:t})=>(A.inputs.index=t,{rgba8:new ft({rgba8:A.outputs.rgba8})}));t.programTemplate||(t.programTemplate=new ye("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}")),e=new me({graph:n,inputs:{index:"index"},outputs:{rgba8:"target"},template:t.programTemplate}),Object.assign(e.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),t.readbackProgram.set(A,e)}const n=e.prepareMaterial();return t.mesh.material=n,{program:e,material:n}}saveRenderState(t){return{xrEnabled:t.xr.enabled,autoClear:t.autoClear}}resetRenderState(t,A){t.setRenderTarget(null),t.xr.enabled=A.xrEnabled,t.autoClear=A.autoClear}process({count:A,material:e}){const n=this.renderer;if(!n)throw new Error("No renderer");if(!this.target)throw new Error("No target");const i=l*I;e.uniforms.targetBase.value=0,e.uniforms.targetCount.value=A;let s=0;for(;s<A;){const a=Math.floor(s/i),r=a*i,o=Math.min(I,Math.ceil((A-r)/l));e.uniforms.targetLayer.value=a,this.target.scissor.set(0,0,l,o),n.setRenderTarget(this.target,a),n.xr.enabled=!1,n.autoClear=!1,n.render(t.scene,t.camera),s+=l*o}this.count=A}async read({readback:t}){const A=this.renderer;if(!A)throw new Error("No renderer");if(!this.target)throw new Error("No target");const e=Math.ceil(this.count/l)*l;if(t.byteLength<4*e)throw new Error(`Readback buffer too small: ${t.byteLength} < ${4*e}`);const n=new Uint8Array(t instanceof ArrayBuffer?t:t.buffer),i=l*I;let s=0;const a=[];for(;s<this.count;){const t=Math.floor(s/i),e=t*i,r=Math.min(I,Math.ceil((this.count-e)/l));A.setRenderTarget(this.target,t);const o=l*r*4,g=n.subarray(4*e,4*e+o),c=null==A?void 0:A.readRenderTargetPixelsAsync(this.target,0,0,l,r,g);a.push(c),s+=l*r}return Promise.all(a).then(()=>t)}render({reader:t,count:A,renderer:e}){if(this.renderer=e||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(A);const{program:n,material:i}=this.prepareProgramMaterial(t);n.update();const s=this.saveRenderState(this.renderer);this.process({count:A,material:i}),this.resetRenderState(this.renderer,s)}async readback({readback:t}){if(!this.renderer)throw new Error("No renderer");const A=this.saveRenderState(this.renderer),e=this.read({readback:t});return this.resetRenderState(this.renderer,A),e}async renderReadback({reader:t,count:A,renderer:e,readback:n}){if(this.renderer=e||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(A);const{program:i,material:s}=this.prepareProgramMaterial(t);i.update();const a=this.saveRenderState(this.renderer);this.process({count:A,material:s});const r=this.read({readback:n});return this.resetRenderState(this.renderer,a),r}getTexture(){var t;return null==(t=this.target)?void 0:t.texture}};la.programTemplate=null,la.readbackProgram=new Map,la.geometry=new n.bdM(2,2),la.mesh=new n.eaF(la.geometry,new n.D$Q({visible:!1})),la.scene=(new n.Z58).add(la.mesh),la.camera=new n.i7d;let Ia=la;const ha=class t{constructor(A={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new wt({key:"rgbaArray",type:Ba,globals:()=>[da],value:{texture:t.getEmpty(),count:0},update:A=>{var e;return A.texture=(null==(e=this.readback)?void 0:e.getTexture())??this.source??t.getEmpty(),A.count=this.count,A}}),A.array?(this.array=A.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/l)*l,this.count=Math.min(this.capacity,A.count??Number.POSITIVE_INFINITY)):(this.capacity=A.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(t){var A;if(!this.array||t>((null==(A=this.array)?void 0:A.length)??0)/4){this.capacity=ne(t).maxSplats;const A=new Uint8Array(4*this.capacity);this.array&&A.set(this.array),this.array=A}return this.array}getTexture(){var A;let e=null==(A=this.readback)?void 0:A.getTexture();return(this.source||this.array)&&(e=this.maybeUpdateSource()),e??t.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:t,height:A,depth:e}=this.source.image;this.capacity!==t*A*e&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:t,height:A,depth:e}=ne(this.capacity);this.source=new n.rFo(this.array,t,A,e),this.source.format=n.GWd,this.source.type=n.OUM,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:t,count:A,renderer:e}){this.readback||(this.readback=new Ia({renderer:e})),this.readback.render({reader:t,count:A,renderer:e}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:A,base:e,count:n,renderer:i}){const{dynoSplats:s,dynoBase:a,dynoCount:r,reader:o}=t.makeDynos();return s.packedSplats=A,a.value=e,r.value=n,this.render({reader:o,count:n,renderer:i}),this}async read(){if(!this.readback)throw new Error("No readback");return(!this.array||this.array.length<4*this.count)&&(this.array=new Uint8Array(4*this.capacity)),(await this.readback.readback({readback:this.array})).subarray(0,4*this.count)}static getEmpty(){if(!t.emptySource){const A=new Uint8Array(4);t.emptySource=new n.rFo(A,1,1,1),t.emptySource.format=n.GWd,t.emptySource.type=n.OUM,t.emptySource.internalFormat="RGBA8",t.emptySource.needsUpdate=!0}return t.emptySource}static makeDynos(){if(!t.dynos){const A=new Ir,e=new Dt({value:0}),n=new Dt({value:0}),i=O({index:"int"},{rgba8:"vec4"},({index:t})=>{if(!t)throw new Error("index is undefined");t=An(t,e);const i=nt(A,t,e,n);return{rgba8:it(i).outputs.rgba}});t.dynos={dynoSplats:A,dynoBase:e,dynoCount:n,reader:i}}return t.dynos}};ha.emptySource=null,ha.dynos=null;let ua=ha;const Ba={type:"RgbaArray"},da=j("\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n");var Ca=(t=>(t.ALL="all",t.PLANE="plane",t.SPHERE="sphere",t.BOX="box",t.ELLIPSOID="ellipsoid",t.CYLINDER="cylinder",t.CAPSULE="capsule",t.INFINITE_CONE="infinite_cone",t))(Ca||{});function Ea(t){switch(t){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${t}`)}}var Qa=(t=>(t.MULTIPLY="multiply",t.SET_RGB="set_rgb",t.ADD_RGBA="add_rgba",t))(Qa||{});function pa(t){switch(t){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${t}`)}}class fa extends n.B69{constructor(t={}){super();const{type:A,invert:e,opacity:i,color:s,displace:a,radius:r}=t;this.type=A??"sphere",this.invert=e??!1,this.opacity=i??1,this.color=s??new n.Q1f(1,1,1),this.displace=a??new n.Pq0(0,0,0),this.radius=r??0}}const ma=class t extends n.B69{constructor(A={}){const{name:e,rgbaBlendMode:n="multiply",sdfSmooth:i=0,softEdge:s=0,invert:a=!1,sdfs:r=null}=A;super(),this.rgbaBlendMode=n,this.sdfSmooth=i,this.softEdge=s,this.invert=a,this.sdfs=r,this.ordering=t.nextOrdering++,this.name=e??`Edit ${this.ordering}`}addSdf(t){null==this.sdfs&&(this.sdfs=[]),this.sdfs.includes(t)||this.sdfs.push(t)}removeSdf(t){null!=this.sdfs&&(this.sdfs=this.sdfs.filter(A=>A!==t))}};ma.nextOrdering=1;let ya=ma;class wa{constructor({maxSdfs:t,maxEdits:A}){this.maxSdfs=Math.max(16,t??0),this.numSdfs=0,this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new wt({key:"sdfArray",type:xa,globals:()=>[Sa],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:t=>(t.numSdfs=this.numSdfs,t.sdfTexture=this.sdfTexture,t)}),this.maxEdits=Math.max(16,A??0),this.numEdits=0,this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new Dt({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(t,A){const e=new n.GYF(t,8,A,n.c90,n.bkx);return e.internalFormat="RGBA32UI",e.needsUpdate=!0,e}newEdits(t,A){return new wt({key:"edits",type:"uvec4",count:A,globals:()=>[Da],value:t})}ensureCapacity({maxSdfs:t,maxEdits:A}){let e=!1;return t>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(2*this.maxSdfs,t),this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),A>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(2*this.maxEdits,A),this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),e=!0),e}updateEditData(t,A){const e=this.editData[t]!==A;return this.editData[t]=A,e}updateEditFloatData(t,A){va[0]=A;const e=this.editFloatData[t]!==va[0];return e&&(this.editFloatData[t]=va[0]),e}encodeEdit(t,{sdfFirst:A,sdfCount:e,invert:n,rgbaBlendMode:i,softEdge:s,sdfSmooth:a}){const r=4*t;let o=!1;return o=this.updateEditData(r+0,i|(n?256:0))||o,o=this.updateEditData(r+1,A|e<<16)||o,o=this.updateEditFloatData(r+2,s)||o,o=this.updateEditFloatData(r+3,a)||o,o}updateSdfData(t,A){const e=this.sdfData[t]!==A;return this.sdfData[t]=A,e}updateSdfFloatData(t,A){va[0]=A;const e=this.sdfFloatData[t]!==va[0];return e&&(this.sdfFloatData[t]=va[0]),e}encodeSdf(t,{sdfType:A,invert:e,center:n,quaternion:i,scale:s,sizes:a},r){const o=32*t,g=A|(e?256:0);let c=!1;c=this.updateSdfFloatData(o+0,(null==n?void 0:n.x)??0)||c,c=this.updateSdfFloatData(o+1,(null==n?void 0:n.y)??0)||c,c=this.updateSdfFloatData(o+2,(null==n?void 0:n.z)??0)||c,c=this.updateSdfData(o+3,g)||c,c=this.updateSdfFloatData(o+4,(null==i?void 0:i.x)??0)||c,c=this.updateSdfFloatData(o+5,(null==i?void 0:i.y)??0)||c,c=this.updateSdfFloatData(o+6,(null==i?void 0:i.z)??0)||c,c=this.updateSdfFloatData(o+7,(null==i?void 0:i.w)??0)||c,c=this.updateSdfFloatData(o+8,(null==s?void 0:s.x)??0)||c,c=this.updateSdfFloatData(o+9,(null==s?void 0:s.y)??0)||c,c=this.updateSdfFloatData(o+10,(null==s?void 0:s.z)??0)||c,c=this.updateSdfData(o+11,0)||c,c=this.updateSdfFloatData(o+12,(null==a?void 0:a.x)??0)||c,c=this.updateSdfFloatData(o+13,(null==a?void 0:a.y)??0)||c,c=this.updateSdfFloatData(o+14,(null==a?void 0:a.z)??0)||c,c=this.updateSdfFloatData(o+15,(null==a?void 0:a.w)??0)||c;const l=Math.min(4,r.length);for(let t=0;t<l;++t){const A=o+16+4*t;c=this.updateSdfFloatData(A+0,r[t].x)||c,c=this.updateSdfFloatData(A+1,r[t].y)||c,c=this.updateSdfFloatData(A+2,r[t].z)||c,c=this.updateSdfFloatData(A+3,r[t].w)||c}return c}update(t){const A=t.reduce((t,{sdfs:A})=>t+A.length,0),e=this.ensureCapacity({maxEdits:t.length,maxSdfs:A}),i=[new n.IUQ,new n.IUQ],s=new n.Pq0,a=new n.PTz,r=new n.Pq0,o=new n.IUQ;let g=0,c=e;t.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=t.length,this.numEdits=t.length,c=!0);for(const[A,{edit:e,sdfs:n}]of t.entries()){c=this.encodeEdit(A,{sdfFirst:g,sdfCount:n.length,invert:e.invert,rgbaBlendMode:pa(e.rgbaBlendMode),softEdge:e.softEdge,sdfSmooth:e.sdfSmooth})||c;let t=!1;for(const A of n)o.set(A.scale.x,A.scale.y,A.scale.z,A.radius),A.scale.setScalar(1),A.updateMatrixWorld(),A.matrixWorld.clone().invert().decompose(s,a,r),A.scale.set(o.x,o.y,o.z),A.updateMatrixWorld(),i[0].set(A.color.r,A.color.g,A.color.b,A.opacity),i[1].set(A.displace.x,A.displace.y,A.displace.z,1),t=this.encodeSdf(g,{sdfType:Ea(A.type),invert:A.invert,center:s,quaternion:a,scale:r,sizes:o},i)||t,g+=1;this.numSdfs=g,t&&(this.sdfTexture.needsUpdate=!0),c||(c=t)}return{updated:c,dynoUpdated:e}}modify(t){return function(t,A,e,n){return new q({inTypes:{gsplat:tt,sdfArray:xa,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:tt},globals:()=>[Sa,Da],inputs:{gsplat:t,sdfArray:A,numEdits:e,rgbaDisplaceEdits:n},statements:({inputs:t,outputs:A})=>{const{sdfArray:e,numEdits:n,rgbaDisplaceEdits:i}=t,{gsplat:s}=A;return W(`\n        ${s} = ${t.gsplat};\n        if (isGsplatActive(${s}.flags)) {\n          for (int editIndex = 0; editIndex < ${n}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${i}[editIndex], ${e}.sdfTexture, ${e}.numSdfs,\n              ${s}.center, ${s}.rgba\n            );\n          }\n        }\n      `)}}).outputs.gsplat}(t,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const xa={type:"SdfArray"},Sa=j("\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n"),Da=j("\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n"),va=new Float32Array(1);class Ma{constructor(t){this.modifier=t,this.cache=new Map}apply(t){let A=this.cache.get(t);return A||(A=O({index:"int"},{gsplat:tt},({index:A})=>{const{gsplat:e}=t.apply({index:A});return this.modifier.apply({gsplat:e})}),this.cache.set(t,A)),A}}class ba{constructor(){this.scale=new vt({value:Number.NEGATIVE_INFINITY}),this.rotate=new Ht({value:new n.PTz(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new Tt({value:new n.Pq0(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(t){return Gs(t,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(t){return Us(t,{rotate:this.rotate})}applyGsplat(t){return rt(t,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(t){const A=new n.Pq0,e=new n.PTz,i=new n.Pq0;t.decompose(i,e,A);const s=(A.x+A.y+A.z)/3;let a=!1;return s!==this.scale.value&&(this.scale.value=s,a=!0),i.equals(this.translate.value)||(this.translate.value.copy(i),a=!0),e.equals(this.rotate.value)||(this.rotate.value.copy(e),a=!0),a}update(t){return t.updateMatrixWorld(),this.updateFromMatrix(t.matrixWorld)}}class _a extends n.B69{constructor({numSplats:t,generator:A,construct:e,update:n}){if(super(),this.numSplats=t??0,this.generator=A,this.frameUpdate=n,this.version=0,e){const t=e(this);Object.assign(this,t)}}updateVersion(){this.version+=1}set needsUpdate(t){t&&this.updateVersion()}}const Ra=class t extends _a{constructor(t={}){const A={transform:new ba,viewToWorld:new ba,worldToView:new ba,viewToObject:new ba,recolor:new Ht({value:new n.IUQ(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),time:new vt({value:0}),deltaTime:new vt({value:0})};if(super({update:({time:t,deltaTime:A,viewToWorld:e,globalEdits:n})=>this.update({time:t,deltaTime:A,viewToWorld:e,globalEdits:n})}),this.isInitialized=!1,this.recolor=new n.Q1f(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=t.packedSplats??new lr,this.numSplats=this.packedSplats.numSplats,this.editable=t.editable??!0,this.onFrame=t.onFrame,this.context=A,this.objectModifier=t.objectModifier,this.worldModifier=t.worldModifier,this.updateGenerator(),t.url||t.fileBytes||t.constructSplats||t.packedSplats&&!t.packedSplats.isInitialized)this.initialized=this.asyncInitialize(t).then(async()=>{if(this.updateGenerator(),this.isInitialized=!0,t.onLoad){const A=t.onLoad(this);A instanceof Promise&&await A}return this});else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),t.onLoad){const A=t.onLoad(this);A instanceof Promise&&(this.initialized=A.then(()=>this))}}async asyncInitialize(t){const{url:A,fileBytes:e,fileType:n,fileName:i,maxSplats:s,constructSplats:a}=t;if(A||e||a){const t={url:A,fileBytes:e,fileType:n,fileName:i,maxSplats:s,construct:a};this.packedSplats.reinitialize(t)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await o(),t.isStaticInitialized=!0}pushSplat(t,A,e,n,i){this.packedSplats.pushSplat(t,A,e,n,i)}forEachSplat(t){this.packedSplats.forEachSplat(t)}dispose(){this.packedSplats.dispose()}constructGenerator(t){const{transform:A,viewToObject:e,recolor:n}=t,i=O({index:"int"},{gsplat:tt},({index:t})=>{if(!t)throw new Error("index is undefined");let i=et(this.packedSplats.dyno,t);if(this.maxSh>=1){const{sh1Texture:t,sh2Texture:A,sh3Texture:n}=this.ensureShTextures();if(t){const s=e.translate,{center:a}=it(i).outputs,r=Ki(en(a,s));let o=function(t,A,e){return K({inTypes:{gsplat:tt,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:t,sh1:A,viewDir:e},globals:()=>[ot,Na],statements:({inputs:t,outputs:A})=>W(`\n        if (isGsplatActive(${t.gsplat}.flags)) {\n          ${A.rgb} = evaluateSH1(${t.gsplat}, ${t.sh1}, ${t.viewDir});\n        } else {\n          ${A.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(i,t,r);this.maxSh>=2&&A&&(o=An(o,function(t,A,e){return K({inTypes:{gsplat:tt,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:t,sh2:A,viewDir:e},globals:()=>[ot,ka],statements:({inputs:t,outputs:A})=>W(`\n        if (isGsplatActive(${t.gsplat}.flags)) {\n          ${A.rgb} = evaluateSH2(${t.gsplat}, ${t.sh2}, ${t.viewDir});\n        } else {\n          ${A.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(i,A,r))),this.maxSh>=3&&n&&(o=An(o,function(t,A,e){return K({inTypes:{gsplat:tt,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:t,sh3:A,viewDir:e},globals:()=>[ot,Ta],statements:({inputs:t,outputs:A})=>W(`\n        if (isGsplatActive(${t.gsplat}.flags)) {\n          ${A.rgb} = evaluateSH3(${t.gsplat}, ${t.sh3}, ${t.viewDir});\n        } else {\n          ${A.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(i,n,r)));let{rgba:g}=it(i).outputs;g=An(g,ji(o,H("float",0))),i=st({gsplat:i,rgba:g})}}if(this.splatRgba){const A=function(t,A){return new q({inTypes:{rgba:Ba,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:t,index:A},globals:()=>[da],statements:({inputs:t,outputs:A})=>W(`\n        if ((index >= 0) && (index < ${t.rgba}.count)) {\n          ${A.rgba} = texelFetch(${t.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${A.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)}).outputs.rgba}(this.splatRgba.dyno,t);i=st({gsplat:i,rgba:A})}this.skinning&&(i=this.skinning.modify(i)),this.objectModifier&&(i=this.objectModifier.apply({gsplat:i}).gsplat),i=A.applyGsplat(i);const s=nn(n,it(i).outputs.rgba);return i=st({gsplat:i,rgba:s}),this.rgbaDisplaceEdits&&(i=this.rgbaDisplaceEdits.modify(i)),this.worldModifier&&(i=this.worldModifier.apply({gsplat:i}).gsplat),{gsplat:i}});this.generator=i}updateGenerator(){this.constructGenerator(this.context)}update({time:A,viewToWorld:e,deltaTime:i,globalEdits:s}){var a;this.numSplats=this.packedSplats.numSplats,this.context.time.value=A,this.context.deltaTime.value=i,t.dynoTime.value=A;const{transform:r,viewToObject:o,recolor:g}=this.context;let c=r.update(this);this.context.viewToWorld.updateFromMatrix(e)&&this.enableViewToWorld&&(c=!0);const l=e.clone().invert();this.context.worldToView.updateFromMatrix(l)&&this.enableWorldToView&&(c=!0);const I=(new n.kn4).compose(r.translate.value,r.rotate.value,(new n.Pq0).setScalar(r.scale.value)).invert().multiply(e);o.updateFromMatrix(I)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(c=!0);const h=new n.IUQ(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);h.equals(g.value)||(g.value.copy(h),c=!0);const u=this.editable?(this.edits??[]).concat(s):[];this.editable&&!this.edits&&this.traverseVisible(t=>{t instanceof ya&&u.push(t)}),u.sort((t,A)=>t.ordering-A.ordering);const B=u.map(t=>{if(null!=t.sdfs)return{edit:t,sdfs:t.sdfs};const A=[];return t.traverseVisible(t=>{t instanceof fa&&A.push(t)}),{edit:t,sdfs:A}});if(B.length>0&&!this.rgbaDisplaceEdits){const t=B.length,A=B.reduce((t,A)=>t+A.sdfs.length,0);this.rgbaDisplaceEdits=new wa({maxEdits:t,maxSdfs:A}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const t=this.rgbaDisplaceEdits.update(B);c||(c=t.updated),t.dynoUpdated&&this.updateGenerator()}c&&this.updateVersion(),null==(a=this.onFrame)||a.call(this,{mesh:this,time:A,deltaTime:i})}raycast(t,A){if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:e,far:i,ray:a}=t,r=this.matrixWorld.clone().invert(),o=(new n.dwI).setFromMatrix4(r),g=a.origin.clone().applyMatrix4(r),c=a.direction.clone().applyMatrix3(o),l=new n.Pq0;r.decompose(new n.Pq0,new n.PTz,l),l.x,l.y,l.z;const I=function(t,A,e,n,i,a,r,o,g,c){return s.raycast_splats(t,A,e,n,i,a,r,o,g,c,!0)}(g.x,g.y,g.z,c.x,c.y,c.z,e,i,this.packedSplats.numSplats,this.packedSplats.packedArray);for(const t of I){const e=a.direction.clone().multiplyScalar(t).add(a.origin);A.push({distance:t,point:e,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let t=this.packedSplats.extra.sh1Texture;if(!t){let A=this.packedSplats.extra.sh1;const{width:e,height:i,depth:s,maxSplats:a}=ne(A.length/2);if(A.length<2*a){const t=new Uint32Array(2*a);t.set(A),this.packedSplats.extra.sh1=t,A=t}const r=new n.rFo(A,e,i,s);r.format=n.TkQ,r.type=n.bkx,r.internalFormat="RG32UI",r.needsUpdate=!0,t=new eA({value:r,key:"sh1"}),this.packedSplats.extra.sh1Texture=t}if(!this.packedSplats.extra.sh2)return{sh1Texture:t};let A=this.packedSplats.extra.sh2Texture;if(!A){let t=this.packedSplats.extra.sh2;const{width:e,height:i,depth:s,maxSplats:a}=ne(t.length/4);if(t.length<4*a){const A=new Uint32Array(4*a);A.set(t),this.packedSplats.extra.sh2=A,t=A}const r=new n.rFo(t,e,i,s);r.format=n.c90,r.type=n.bkx,r.internalFormat="RGBA32UI",r.needsUpdate=!0,A=new eA({value:r,key:"sh2"}),this.packedSplats.extra.sh2Texture=A}if(!this.packedSplats.extra.sh3)return{sh1Texture:t,sh2Texture:A};let e=this.packedSplats.extra.sh3Texture;if(!e){let t=this.packedSplats.extra.sh3;const{width:A,height:i,depth:s,maxSplats:a}=ne(t.length/4);if(t.length<4*a){const A=new Uint32Array(4*a);A.set(t),this.packedSplats.extra.sh3=A,t=A}const r=new n.rFo(t,A,i,s);r.format=n.c90,r.type=n.bkx,r.internalFormat="RGBA32UI",r.needsUpdate=!0,e=new eA({value:r,key:"sh3"}),this.packedSplats.extra.sh3Texture=e}return{sh1Texture:t,sh2Texture:A,sh3Texture:e}}};Ra.staticInitialized=Ra.staticInitialize(),Ra.isStaticInitialized=!1,Ra.dynoTime=new vt({value:0});let Fa=Ra;const Na=j("\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n"),ka=j("\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n"),Ta=j("\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n"),Ga=class t{constructor({fileBytes:t}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=t instanceof ArrayBuffer?new Uint8Array(t):t}async parseHeader(){const t=new ReadableStream({start:t=>{t.enqueue(this.fileBytes.slice(0,65536)),t.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";for(;;){const{value:A,done:e}=await t.read();if(e)throw new Error("Failed to read header");this.header+=A;const n=this.header.indexOf("end_header\n");if(n>=0){this.header=this.header.slice(0,n+11);break}}const A=(new TextEncoder).encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,A),this.elements={};let e=null;this.comments=[],this.header.trim().split("\n").forEach((t,A)=>{const n=t.trim();if(0===A){if("ply"!==n)throw new Error("Invalid PLY header");return}if(0===n.length)return;const i=n.split(" ");switch(i[0]){case"format":if("binary_little_endian"===i[1])this.littleEndian=!0;else{if("binary_big_endian"!==i[1])throw new Error(`Unsupported PLY format: ${i[1]}`);this.littleEndian=!1}if("1.0"!==i[2])throw new Error(`Unsupported PLY version: ${i[2]}`);break;case"end_header":break;case"comment":this.comments.push(n.slice(8));break;case"element":{const t=i[1];e={name:t,count:Number.parseInt(i[2]),properties:{}},this.elements[t]=e;break}case"property":if(null==e)throw new Error("Property must be inside an element");"list"===i[1]?e.properties[i[4]]={isList:!0,type:i[3],countType:i[2]}:e.properties[i[2]]={isList:!1,type:i[1]}}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(t){let A=0;const e=this.data;if(null==e)throw new Error("No data to parse");for(const n in this.elements){const i=this.elements[n],{count:s,properties:a}=i,r={},o=[];for(const[t,n]of Object.entries(a))n.isList?(r[t]=[],o.push(()=>{const i=r[t];i.length=Ha[n.countType](e,A,this.littleEndian),A+=Pa[n.countType];for(let t=0;t<i.length;t++)i[t]=Ha[n.type](e,A,this.littleEndian),A+=Pa[n.type]})):(r[t]=0,o.push(()=>{r[t]=Ha[n.type](e,A,this.littleEndian),A+=Pa[n.type]}));const g=t(i)??(()=>{});for(let t=0;t<s;t++){for(const t of o)t();g(t,r)}}}parseSplats(A,e){if(null==this.elements.vertex)throw new Error("No vertex element found");let n=!1;const i=[];let s,a,r,o=0,g=[],c=[],l=[];function I(){const t=za[o];g=new Array(3).fill(null).flatMap((A,e)=>[0,1,2].map((A,n)=>`f_rest_${e+n*t/3}`)),c=new Array(5).fill(null).flatMap((A,e)=>[0,1,2].map((A,n)=>`f_rest_${3+e+n*t/3}`)),l=new Array(7).fill(null).flatMap((A,e)=>[0,1,2].map((A,n)=>`f_rest_${8+e+n*t/3}`)),s=o>=1?new Float32Array(9):void 0,a=o>=2?new Float32Array(15):void 0,r=o>=3?new Float32Array(21):void 0}function h(t,A){if(!s)throw new Error("Missing sh1");for(const[t,e]of g.entries())s[t]=8*A[e]/255-4;if(a)for(const[t,e]of c.entries())a[t]=8*A[e]/255-4;if(r)for(const[t,e]of l.entries())r[t]=8*A[e]/255-4;null==e||e(t,s,a,r)}this.parseData(u=>{if("chunk"===u.name)return function(t){const{min_x:A,min_y:e,min_z:s,max_x:a,max_y:r,max_z:o,min_scale_x:g,min_scale_y:c,min_scale_z:l,max_scale_x:I,max_scale_y:h,max_scale_z:u}=t.properties;if(!(A&&e&&s&&a&&r&&o&&g&&c&&l&&I&&h&&u))throw new Error("Missing PLY chunk properties");return n=!0,(t,A)=>{const{min_x:e,min_y:n,min_z:s,max_x:a,max_y:r,max_z:o,min_scale_x:g,min_scale_y:c,min_scale_z:l,max_scale_x:I,max_scale_y:h,max_scale_z:u,min_r:B,min_g:d,min_b:C,max_r:E,max_g:Q,max_b:p}=A;i.push({min_x:e,min_y:n,min_z:s,max_x:a,max_y:r,max_z:o,min_scale_x:g,min_scale_y:c,min_scale_z:l,max_scale_x:I,max_scale_y:h,max_scale_z:u,min_r:B,min_g:d,min_b:C,max_r:E,max_g:Q,max_b:p})}}(u);if(n)return function(t){if(e&&"sh"===t.name)return o=Oa(t.properties),I(),h;if("vertex"!==t.name)return null;const{packed_position:n,packed_rotation:s,packed_scale:a,packed_color:r}=t.properties;if(!(n&&s&&a&&r))throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const g=Math.sqrt(2);return(t,e)=>{const n=i[t>>>8];if(null==n)throw new Error("Missing PLY chunk");const{min_x:s,min_y:a,min_z:r,max_x:o,max_y:c,max_z:l,min_scale_x:I,min_scale_y:h,min_scale_z:u,max_scale_x:B,max_scale_y:d,max_scale_z:C,min_r:E,min_g:Q,min_b:p,max_r:f,max_g:m,max_b:y}=n,{packed_position:w,packed_rotation:x,packed_scale:S,packed_color:D}=e,v=(w>>>21&2047)/2047*(o-s)+s,M=(w>>>11&1023)/1023*(c-a)+a,b=(2047&w)/2047*(l-r)+r,_=((x>>>20&1023)/1023-.5)*g,R=((x>>>10&1023)/1023-.5)*g,F=((1023&x)/1023-.5)*g,N=Math.sqrt(Math.max(0,1-_*_-R*R-F*F)),k=x>>>30,T=0===k?_:1===k?N:R,G=k<=1?R:2===k?N:F,U=k<=2?F:N,L=0===k?N:_,H=Math.exp((S>>>21&2047)/2047*(B-I)+I),Y=Math.exp((S>>>11&1023)/1023*(d-h)+h),P=Math.exp((2047&S)/2047*(C-u)+u);A(t,v,M,b,H,Y,P,T,G,U,L,(255&D)/255,(D>>>24&255)/255*((f??1)-(E??0))+(E??0),(D>>>16&255)/255*((m??1)-(Q??0))+(Q??0),(D>>>8&255)/255*((y??1)-(p??0))+(p??0))}}(u);if("vertex"!==u.name)return null;const{x:B,y:d,z:C,scale_0:E,scale_1:Q,scale_2:p,rot_0:f,rot_1:m,rot_2:y,rot_3:w,opacity:x,f_dc_0:S,f_dc_1:D,f_dc_2:v,red:M,green:b,blue:_,alpha:R}=u.properties;if(!B||!d||!C)throw new Error("Missing PLY properties: x, y, z");const F=E&&Q&&p,N=f&&m&&y&&w,k=null!=R?Ja[R.type]:1,T=null!=M?Ja[M.type]:1,G=null!=b?Ja[b.type]:1,U=null!=_?Ja[_.type]:1;return o=Oa(u.properties),I(),(n,i)=>{const o=F?Math.exp(i.scale_0):t.defaultPointScale,I=F?Math.exp(i.scale_1):t.defaultPointScale,h=F?Math.exp(i.scale_2):t.defaultPointScale,u=N?i.rot_1:0,B=N?i.rot_2:0,d=N?i.rot_3:0,C=N?i.rot_0:1,E=null!=x?1/(1+Math.exp(-i.opacity)):null!=R?i.alpha/k:1,Q=null!=S?i.f_dc_0*La+.5:null!=M?i.red/T:1,p=null!=D?i.f_dc_1*La+.5:null!=b?i.green/G:1,f=null!=v?i.f_dc_2*La+.5:null!=_?i.blue/U:1;if(A(n,i.x,i.y,i.z,o,I,h,u,B,d,C,E,Q,p,f),e&&s){if(s)for(const[t,A]of g.entries())s[t]=i[A];if(a)for(const[t,A]of c.entries())a[t]=i[A];if(r)for(const[t,A]of l.entries())r[t]=i[A];e(n,s,a,r)}}})}injectRgba(t){let A=0;const e=this.data;if(null==e)throw new Error("No parsed data");if(t.length!==4*this.numSplats)throw new Error("Invalid RGBA array length");for(const n in this.elements){const i=this.elements[n],{count:s,properties:a}=i,r=[];let o=0;const g="vertex"===n;if(g)for(const t of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!a[t]||"float"!==a[t].type)throw new Error(`Can't injectRgba due to property: ${t}`);for(const[n,i]of Object.entries(a))if(i.isList)r.push(()=>{const t=Ha[i.countType](e,A,this.littleEndian);A+=Pa[i.countType],A+=t*Pa[i.type]});else{if(g)if("f_dc_0"===n||"f_dc_1"===n||"f_dc_2"===n){const s=Number.parseInt(n.slice(5));r.push(()=>{const n=(t[o+s]/255-.5)/La;Ya[i.type](e,A,this.littleEndian,n)})}else"opacity"===n&&r.push(()=>{const n=Math.max(-100,Math.min(100,-Math.log(1/(t[o+3]/255)-1)));Ya[i.type](e,A,this.littleEndian,n)});r.push(()=>{A+=Pa[i.type]})}for(let t=0;t<s;t++){for(const t of r)t();g&&(o+=4)}}}};Ga.defaultPointScale=.001;let Ua=Ga;const La=.28209479177387814,Ha={char:(t,A,e)=>t.getInt8(A),uchar:(t,A,e)=>t.getUint8(A),short:(t,A,e)=>t.getInt16(A,e),ushort:(t,A,e)=>t.getUint16(A,e),int:(t,A,e)=>t.getInt32(A,e),uint:(t,A,e)=>t.getUint32(A,e),float:(t,A,e)=>t.getFloat32(A,e),double:(t,A,e)=>t.getFloat64(A,e)},Ya={char:(t,A,e,n)=>{t.setInt8(A,n)},uchar:(t,A,e,n)=>{t.setUint8(A,n)},short:(t,A,e,n)=>{t.setInt16(A,n,e)},ushort:(t,A,e,n)=>{t.setUint16(A,n,e)},int:(t,A,e,n)=>{t.setInt32(A,n,e)},uint:(t,A,e,n)=>{t.setUint32(A,n,e)},float:(t,A,e,n)=>{t.setFloat32(A,n,e)},double:(t,A,e,n)=>{t.setFloat64(A,n,e)}},Pa={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},Ja={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},qa={0:0,9:1,24:2,45:3},za={0:0,1:9,2:24,3:45};function Oa(t){let A=0;for(;t[`f_rest_${A}`];)A+=1;const e=qa[A];if(null==e)throw new Error(`Unsupported number of SH coefficients: ${A}`);return e}const Ka='(function() {\n  "use strict";\n  let wasm;\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error("TextDecoder not available");\n  } };\n  if (typeof TextDecoder !== "undefined") {\n    cachedTextDecoder.decode();\n  }\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid) {\n    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid);\n    return ret;\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === "function" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === "function") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get("Content-Type") != "application/wasm") {\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_0;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== "undefined") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\n      }\n    }\n    if (typeof module_or_path === "undefined") {\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  };\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    "unexpected EOF",\n    "invalid block type",\n    "invalid length/literal",\n    "invalid distance",\n    "stream finished",\n    "no stream handler",\n    ,\n    "no callback",\n    "invalid UTF-8 data",\n    "extra field too long",\n    "date not in range 1980-2099",\n    "filename too long",\n    "stream finishing",\n    "invalid zip data"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add2 = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add2;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, "invalid gzip data");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == "function")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  }();\n  var Gunzip = /* @__PURE__ */ function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  }();\n  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();\n  var tds = 0;\n  try {\n    td.decode(et, { stream: true });\n    tds = 1;\n  } catch (e) {\n  }\n  /**\n   * @license\n   * Copyright 2010-2024 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = "172";\n  const FrontSide = 0;\n  const BackSide = 1;\n  const NormalBlending = 1;\n  const AddEquation = 100;\n  const SrcAlphaFactor = 204;\n  const OneMinusSrcAlphaFactor = 205;\n  const LessEqualDepth = 3;\n  const MultiplyOperation = 0;\n  const UVMapping = 300;\n  const RepeatWrapping = 1e3;\n  const ClampToEdgeWrapping = 1001;\n  const MirroredRepeatWrapping = 1002;\n  const NearestFilter = 1003;\n  const LinearFilter = 1006;\n  const LinearMipmapLinearFilter = 1008;\n  const UnsignedByteType = 1009;\n  const UnsignedIntType = 1014;\n  const FloatType = 1015;\n  const RGBAFormat = 1023;\n  const RGIntegerFormat = 1031;\n  const RGBAIntegerFormat = 1033;\n  const NoColorSpace = "";\n  const SRGBColorSpace = "srgb";\n  const LinearSRGBColorSpace = "srgb-linear";\n  const LinearTransfer = "linear";\n  const SRGBTransfer = "srgb";\n  const KeepStencilOp = 7680;\n  const AlwaysStencilFunc = 519;\n  const StaticDrawUsage = 35044;\n  const GLSL3 = "300 es";\n  const WebGLCoordinateSystem = 2e3;\n  const WebGPUCoordinateSystem = 2001;\n  class EventDispatcher {\n    addEventListener(type, listener) {\n      if (this._listeners === void 0) this._listeners = {};\n      const listeners = this._listeners;\n      if (listeners[type] === void 0) {\n        listeners[type] = [];\n      }\n      if (listeners[type].indexOf(listener) === -1) {\n        listeners[type].push(listener);\n      }\n    }\n    hasEventListener(type, listener) {\n      if (this._listeners === void 0) return false;\n      const listeners = this._listeners;\n      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    removeEventListener(type, listener) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[type];\n      if (listenerArray !== void 0) {\n        const index = listenerArray.indexOf(listener);\n        if (index !== -1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n    }\n    dispatchEvent(event) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[event.type];\n      if (listenerArray !== void 0) {\n        event.target = this;\n        const array = listenerArray.slice(0);\n        for (let i2 = 0, l = array.length; i2 < l; i2++) {\n          array[i2].call(this, event);\n        }\n        event.target = null;\n      }\n    }\n  }\n  const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];\n  function generateUUID() {\n    const d0 = Math.random() * 4294967295 | 0;\n    const d1 = Math.random() * 4294967295 | 0;\n    const d2 = Math.random() * 4294967295 | 0;\n    const d3 = Math.random() * 4294967295 | 0;\n    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n    return uuid.toLowerCase();\n  }\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  function denormalize(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return value / 4294967295;\n      case Uint16Array:\n        return value / 65535;\n      case Uint8Array:\n        return value / 255;\n      case Int32Array:\n        return Math.max(value / 2147483647, -1);\n      case Int16Array:\n        return Math.max(value / 32767, -1);\n      case Int8Array:\n        return Math.max(value / 127, -1);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  function normalize$1(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return Math.round(value * 4294967295);\n      case Uint16Array:\n        return Math.round(value * 65535);\n      case Uint8Array:\n        return Math.round(value * 255);\n      case Int32Array:\n        return Math.round(value * 2147483647);\n      case Int16Array:\n        return Math.round(value * 32767);\n      case Int8Array:\n        return Math.round(value * 127);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  class Vector2 {\n    constructor(x2 = 0, y = 0) {\n      Vector2.prototype.isVector2 = true;\n      this.x = x2;\n      this.y = y;\n    }\n    get width() {\n      return this.x;\n    }\n    set width(value) {\n      this.x = value;\n    }\n    get height() {\n      return this.y;\n    }\n    set height(value) {\n      this.y = value;\n    }\n    set(x2, y) {\n      this.x = x2;\n      this.y = y;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6];\n      this.y = e[1] * x2 + e[4] * y + e[7];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y;\n    }\n    cross(v) {\n      return this.x * v.y - this.y * v.x;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    angle() {\n      const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n      return angle;\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y;\n      return dx * dx + dy * dy;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      return this;\n    }\n    rotateAround(center, angle) {\n      const c = Math.cos(angle), s = Math.sin(angle);\n      const x2 = this.x - center.x;\n      const y = this.y - center.y;\n      this.x = x2 * c - y * s + center.x;\n      this.y = x2 * s + y * c + center.y;\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n    }\n  }\n  class Matrix3 {\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  function arrayNeedsUint32(array) {\n    for (let i2 = array.length - 1; i2 >= 0; --i2) {\n      if (array[i2] >= 65535) return true;\n    }\n    return false;\n  }\n  function createElementNS(name) {\n    return document.createElementNS("http://www.w3.org/1999/xhtml", name);\n  }\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *\t- whitePoint: reference white [ x y ]\n       *\t- transfer: transfer function (pre-defined)\n       *\t- toXYZ: Matrix3 RGB to XYZ transform\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\n       *\t- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  let _canvas;\n  class ImageUtils {\n    static getDataURL(image) {\n      if (/^data:/i.test(image.src)) {\n        return image.src;\n      }\n      if (typeof HTMLCanvasElement === "undefined") {\n        return image.src;\n      }\n      let canvas;\n      if (image instanceof HTMLCanvasElement) {\n        canvas = image;\n      } else {\n        if (_canvas === void 0) _canvas = createElementNS("canvas");\n        _canvas.width = image.width;\n        _canvas.height = image.height;\n        const context = _canvas.getContext("2d");\n        if (image instanceof ImageData) {\n          context.putImageData(image, 0, 0);\n        } else {\n          context.drawImage(image, 0, 0, image.width, image.height);\n        }\n        canvas = _canvas;\n      }\n      if (canvas.width > 2048 || canvas.height > 2048) {\n        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);\n        return canvas.toDataURL("image/jpeg", 0.6);\n      } else {\n        return canvas.toDataURL("image/png");\n      }\n    }\n    static sRGBToLinear(image) {\n      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n        const canvas = createElementNS("canvas");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext("2d");\n        context.drawImage(image, 0, 0, image.width, image.height);\n        const imageData = context.getImageData(0, 0, image.width, image.height);\n        const data = imageData.data;\n        for (let i2 = 0; i2 < data.length; i2++) {\n          data[i2] = SRGBToLinear(data[i2] / 255) * 255;\n        }\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n      } else if (image.data) {\n        const data = image.data.slice(0);\n        for (let i2 = 0; i2 < data.length; i2++) {\n          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n            data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);\n          } else {\n            data[i2] = SRGBToLinear(data[i2]);\n          }\n        }\n        return {\n          data,\n          width: image.width,\n          height: image.height\n        };\n      } else {\n        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");\n        return image;\n      }\n    }\n  }\n  let _sourceId = 0;\n  class Source {\n    constructor(data = null) {\n      this.isSource = true;\n      Object.defineProperty(this, "id", { value: _sourceId++ });\n      this.uuid = generateUUID();\n      this.data = data;\n      this.dataReady = true;\n      this.version = 0;\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.images[this.uuid] !== void 0) {\n        return meta.images[this.uuid];\n      }\n      const output = {\n        uuid: this.uuid,\n        url: ""\n      };\n      const data = this.data;\n      if (data !== null) {\n        let url;\n        if (Array.isArray(data)) {\n          url = [];\n          for (let i2 = 0, l = data.length; i2 < l; i2++) {\n            if (data[i2].isDataTexture) {\n              url.push(serializeImage(data[i2].image));\n            } else {\n              url.push(serializeImage(data[i2]));\n            }\n          }\n        } else {\n          url = serializeImage(data);\n        }\n        output.url = url;\n      }\n      if (!isRootObject) {\n        meta.images[this.uuid] = output;\n      }\n      return output;\n    }\n  }\n  function serializeImage(image) {\n    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n      return ImageUtils.getDataURL(image);\n    } else {\n      if (image.data) {\n        return {\n          data: Array.from(image.data),\n          width: image.width,\n          height: image.height,\n          type: image.data.constructor.name\n        };\n      } else {\n        console.warn("THREE.Texture: Unable to serialize Texture.");\n        return {};\n      }\n    }\n  }\n  let _textureId = 0;\n  class Texture extends EventDispatcher {\n    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n      super();\n      this.isTexture = true;\n      Object.defineProperty(this, "id", { value: _textureId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.source = new Source(image);\n      this.mipmaps = [];\n      this.mapping = mapping;\n      this.channel = 0;\n      this.wrapS = wrapS;\n      this.wrapT = wrapT;\n      this.magFilter = magFilter;\n      this.minFilter = minFilter;\n      this.anisotropy = anisotropy;\n      this.format = format;\n      this.internalFormat = null;\n      this.type = type;\n      this.offset = new Vector2(0, 0);\n      this.repeat = new Vector2(1, 1);\n      this.center = new Vector2(0, 0);\n      this.rotation = 0;\n      this.matrixAutoUpdate = true;\n      this.matrix = new Matrix3();\n      this.generateMipmaps = true;\n      this.premultiplyAlpha = false;\n      this.flipY = true;\n      this.unpackAlignment = 4;\n      this.colorSpace = colorSpace;\n      this.userData = {};\n      this.version = 0;\n      this.onUpdate = null;\n      this.renderTarget = null;\n      this.isRenderTargetTexture = false;\n      this.pmremVersion = 0;\n    }\n    get image() {\n      return this.source.data;\n    }\n    set image(value = null) {\n      this.source.data = value;\n    }\n    updateMatrix() {\n      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.source = source.source;\n      this.mipmaps = source.mipmaps.slice(0);\n      this.mapping = source.mapping;\n      this.channel = source.channel;\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n      this.anisotropy = source.anisotropy;\n      this.format = source.format;\n      this.internalFormat = source.internalFormat;\n      this.type = source.type;\n      this.offset.copy(source.offset);\n      this.repeat.copy(source.repeat);\n      this.center.copy(source.center);\n      this.rotation = source.rotation;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrix.copy(source.matrix);\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.colorSpace = source.colorSpace;\n      this.renderTarget = source.renderTarget;\n      this.isRenderTargetTexture = source.isRenderTargetTexture;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      this.needsUpdate = true;\n      return this;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n        return meta.textures[this.uuid];\n      }\n      const output = {\n        metadata: {\n          version: 4.6,\n          type: "Texture",\n          generator: "Texture.toJSON"\n        },\n        uuid: this.uuid,\n        name: this.name,\n        image: this.source.toJSON(meta).uuid,\n        mapping: this.mapping,\n        channel: this.channel,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        format: this.format,\n        internalFormat: this.internalFormat,\n        type: this.type,\n        colorSpace: this.colorSpace,\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY,\n        generateMipmaps: this.generateMipmaps,\n        premultiplyAlpha: this.premultiplyAlpha,\n        unpackAlignment: this.unpackAlignment\n      };\n      if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n      if (!isRootObject) {\n        meta.textures[this.uuid] = output;\n      }\n      return output;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    transformUv(uv) {\n      if (this.mapping !== UVMapping) return uv;\n      uv.applyMatrix3(this.matrix);\n      if (uv.x < 0 || uv.x > 1) {\n        switch (this.wrapS) {\n          case RepeatWrapping:\n            uv.x = uv.x - Math.floor(uv.x);\n            break;\n          case ClampToEdgeWrapping:\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n              uv.x = Math.ceil(uv.x) - uv.x;\n            } else {\n              uv.x = uv.x - Math.floor(uv.x);\n            }\n            break;\n        }\n      }\n      if (uv.y < 0 || uv.y > 1) {\n        switch (this.wrapT) {\n          case RepeatWrapping:\n            uv.y = uv.y - Math.floor(uv.y);\n            break;\n          case ClampToEdgeWrapping:\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n              uv.y = Math.ceil(uv.y) - uv.y;\n            } else {\n              uv.y = uv.y - Math.floor(uv.y);\n            }\n            break;\n        }\n      }\n      if (this.flipY) {\n        uv.y = 1 - uv.y;\n      }\n      return uv;\n    }\n    set needsUpdate(value) {\n      if (value === true) {\n        this.version++;\n        this.source.needsUpdate = true;\n      }\n    }\n    set needsPMREMUpdate(value) {\n      if (value === true) {\n        this.pmremVersion++;\n      }\n    }\n  }\n  Texture.DEFAULT_IMAGE = null;\n  Texture.DEFAULT_MAPPING = UVMapping;\n  Texture.DEFAULT_ANISOTROPY = 1;\n  class Vector4 {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      Vector4.prototype.isVector4 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n    get width() {\n      return this.z;\n    }\n    set width(value) {\n      this.z = value;\n    }\n    get height() {\n      return this.w;\n    }\n    set height(value) {\n      this.w = value;\n    }\n    set(x2, y, z, w) {\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setW(w) {\n      this.w = w;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        case 3:\n          this.w = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        case 3:\n          return this.w;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = v.w !== void 0 ? v.w : 1;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      this.w *= v.w;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z, w = this.w;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;\n      this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      this.w /= v.w;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    setAxisAngleFromQuaternion(q) {\n      this.w = 2 * Math.acos(q.w);\n      const s = Math.sqrt(1 - q.w * q.w);\n      if (s < 1e-4) {\n        this.x = 1;\n        this.y = 0;\n        this.z = 0;\n      } else {\n        this.x = q.x / s;\n        this.y = q.y / s;\n        this.z = q.z / s;\n      }\n      return this;\n    }\n    setAxisAngleFromRotationMatrix(m) {\n      let angle, x2, y, z;\n      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n          this.set(1, 0, 0, 0);\n          return this;\n        }\n        angle = Math.PI;\n        const xx = (m11 + 1) / 2;\n        const yy = (m22 + 1) / 2;\n        const zz = (m33 + 1) / 2;\n        const xy = (m12 + m21) / 4;\n        const xz = (m13 + m31) / 4;\n        const yz = (m23 + m32) / 4;\n        if (xx > yy && xx > zz) {\n          if (xx < epsilon) {\n            x2 = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n          } else {\n            x2 = Math.sqrt(xx);\n            y = xy / x2;\n            z = xz / x2;\n          }\n        } else if (yy > zz) {\n          if (yy < epsilon) {\n            x2 = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n          } else {\n            y = Math.sqrt(yy);\n            x2 = xy / y;\n            z = yz / y;\n          }\n        } else {\n          if (zz < epsilon) {\n            x2 = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n          } else {\n            z = Math.sqrt(zz);\n            x2 = xz / z;\n            y = yz / z;\n          }\n        }\n        this.set(x2, y, z, angle);\n        return this;\n      }\n      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n      if (Math.abs(s) < 1e-3) s = 1;\n      this.x = (m32 - m23) / s;\n      this.y = (m13 - m31) / s;\n      this.z = (m21 - m12) / s;\n      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      this.w = e[15];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      this.w = Math.min(this.w, v.w);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      this.w = Math.max(this.w, v.w);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      this.w = clamp(this.w, min.w, max2.w);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      this.w = clamp(this.w, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      this.w = Math.floor(this.w);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      this.w = Math.ceil(this.w);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      this.w = Math.round(this.w);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      this.w = Math.trunc(this.w);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      this.w = -this.w;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      this.w += (v.w - this.w) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      this.w = v1.w + (v2.w - v1.w) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      this.w = attribute.getW(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      this.w = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n      yield this.w;\n    }\n  }\n  class RenderTarget extends EventDispatcher {\n    constructor(width = 1, height = 1, options = {}) {\n      super();\n      this.isRenderTarget = true;\n      this.width = width;\n      this.height = height;\n      this.depth = 1;\n      this.scissor = new Vector4(0, 0, width, height);\n      this.scissorTest = false;\n      this.viewport = new Vector4(0, 0, width, height);\n      const image = { width, height, depth: 1 };\n      options = Object.assign({\n        generateMipmaps: false,\n        internalFormat: null,\n        minFilter: LinearFilter,\n        depthBuffer: true,\n        stencilBuffer: false,\n        resolveDepthBuffer: true,\n        resolveStencilBuffer: true,\n        depthTexture: null,\n        samples: 0,\n        count: 1\n      }, options);\n      const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n      texture.flipY = false;\n      texture.generateMipmaps = options.generateMipmaps;\n      texture.internalFormat = options.internalFormat;\n      this.textures = [];\n      const count = options.count;\n      for (let i2 = 0; i2 < count; i2++) {\n        this.textures[i2] = texture.clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      this.depthBuffer = options.depthBuffer;\n      this.stencilBuffer = options.stencilBuffer;\n      this.resolveDepthBuffer = options.resolveDepthBuffer;\n      this.resolveStencilBuffer = options.resolveStencilBuffer;\n      this._depthTexture = null;\n      this.depthTexture = options.depthTexture;\n      this.samples = options.samples;\n    }\n    get texture() {\n      return this.textures[0];\n    }\n    set texture(value) {\n      this.textures[0] = value;\n    }\n    set depthTexture(current) {\n      if (this._depthTexture !== null) this._depthTexture.renderTarget = null;\n      if (current !== null) current.renderTarget = this;\n      this._depthTexture = current;\n    }\n    get depthTexture() {\n      return this._depthTexture;\n    }\n    setSize(width, height, depth = 1) {\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {\n          this.textures[i2].image.width = width;\n          this.textures[i2].image.height = height;\n          this.textures[i2].image.depth = depth;\n        }\n        this.dispose();\n      }\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.scissor.copy(source.scissor);\n      this.scissorTest = source.scissorTest;\n      this.viewport.copy(source.viewport);\n      this.textures.length = 0;\n      for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {\n        this.textures[i2] = source.textures[i2].clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      const image = Object.assign({}, source.texture.image);\n      this.texture.source = new Source(image);\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      this.resolveDepthBuffer = source.resolveDepthBuffer;\n      this.resolveStencilBuffer = source.resolveStencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.samples = source.samples;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  class WebGLRenderTarget extends RenderTarget {\n    constructor(width = 1, height = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLRenderTarget = true;\n    }\n  }\n  class DataArrayTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, depth = 1) {\n      super(null);\n      this.isDataArrayTexture = true;\n      this.image = { data, width, height, depth };\n      this.magFilter = NearestFilter;\n      this.minFilter = NearestFilter;\n      this.wrapR = ClampToEdgeWrapping;\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n      this.layerUpdates = /* @__PURE__ */ new Set();\n    }\n    addLayerUpdate(layerIndex) {\n      this.layerUpdates.add(layerIndex);\n    }\n    clearLayerUpdates() {\n      this.layerUpdates.clear();\n    }\n  }\n  class WebGLArrayRenderTarget extends WebGLRenderTarget {\n    constructor(width = 1, height = 1, depth = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLArrayRenderTarget = true;\n      this.depth = depth;\n      this.texture = new DataArrayTexture(null, width, height, depth);\n      this.texture.isRenderTargetTexture = true;\n    }\n  }\n  class Quaternion {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let s = 1 - t;\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n        if (sqrSin > Number.EPSILON) {\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n        const tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n        if (s === 1 - t) {\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case "XYZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "YXZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "ZXY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "ZYX":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "YZX":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "XZY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < Number.EPSILON) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    invert() {\n      return this.conjugate();\n    }\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n      if (cosHalfTheta >= 1) {\n        this._w = w;\n        this._x = x2;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        const s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x2 + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n        return this;\n      }\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x2 * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n      this._onChangeCallback();\n      return this;\n    }\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // TODO lengthSquared?\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Box3 {\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute("position");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _box$3 = /* @__PURE__ */ new Box3();\n  const _v1$6 = /* @__PURE__ */ new Vector3();\n  const _v2$3 = /* @__PURE__ */ new Vector3();\n  class Sphere {\n    constructor(center = new Vector3(), radius = -1) {\n      this.isSphere = true;\n      this.center = center;\n      this.radius = radius;\n    }\n    set(center, radius) {\n      this.center.copy(center);\n      this.radius = radius;\n      return this;\n    }\n    setFromPoints(points, optionalCenter) {\n      const center = this.center;\n      if (optionalCenter !== void 0) {\n        center.copy(optionalCenter);\n      } else {\n        _box$3.setFromPoints(points).getCenter(center);\n      }\n      let maxRadiusSq = 0;\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));\n      }\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    }\n    copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n    isEmpty() {\n      return this.radius < 0;\n    }\n    makeEmpty() {\n      this.center.set(0, 0, 0);\n      this.radius = -1;\n      return this;\n    }\n    containsPoint(point) {\n      return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n    distanceToPoint(point) {\n      return point.distanceTo(this.center) - this.radius;\n    }\n    intersectsSphere(sphere) {\n      const radiusSum = this.radius + sphere.radius;\n      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n    intersectsBox(box) {\n      return box.intersectsSphere(this);\n    }\n    intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n    clampPoint(point, target) {\n      const deltaLengthSq = this.center.distanceToSquared(point);\n      target.copy(point);\n      if (deltaLengthSq > this.radius * this.radius) {\n        target.sub(this.center).normalize();\n        target.multiplyScalar(this.radius).add(this.center);\n      }\n      return target;\n    }\n    getBoundingBox(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n        return target;\n      }\n      target.set(this.center, this.center);\n      target.expandByScalar(this.radius);\n      return target;\n    }\n    applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n      return this;\n    }\n    translate(offset) {\n      this.center.add(offset);\n      return this;\n    }\n    expandByPoint(point) {\n      if (this.isEmpty()) {\n        this.center.copy(point);\n        this.radius = 0;\n        return this;\n      }\n      _v1$6.subVectors(point, this.center);\n      const lengthSq = _v1$6.lengthSq();\n      if (lengthSq > this.radius * this.radius) {\n        const length = Math.sqrt(lengthSq);\n        const delta = (length - this.radius) * 0.5;\n        this.center.addScaledVector(_v1$6, delta / length);\n        this.radius += delta;\n      }\n      return this;\n    }\n    union(sphere) {\n      if (sphere.isEmpty()) {\n        return this;\n      }\n      if (this.isEmpty()) {\n        this.copy(sphere);\n        return this;\n      }\n      if (this.center.equals(sphere.center) === true) {\n        this.radius = Math.max(this.radius, sphere.radius);\n      } else {\n        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n      }\n      return this;\n    }\n    equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  const _vector$a = /* @__PURE__ */ new Vector3();\n  const _segCenter = /* @__PURE__ */ new Vector3();\n  const _segDir = /* @__PURE__ */ new Vector3();\n  const _diff = /* @__PURE__ */ new Vector3();\n  const _edge1 = /* @__PURE__ */ new Vector3();\n  const _edge2 = /* @__PURE__ */ new Vector3();\n  const _normal$1 = /* @__PURE__ */ new Vector3();\n  class Ray {\n    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n      this.origin = origin;\n      this.direction = direction;\n    }\n    set(origin, direction) {\n      this.origin.copy(origin);\n      this.direction.copy(direction);\n      return this;\n    }\n    copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n    at(t, target) {\n      return target.copy(this.origin).addScaledVector(this.direction, t);\n    }\n    lookAt(v) {\n      this.direction.copy(v).sub(this.origin).normalize();\n      return this;\n    }\n    recast(t) {\n      this.origin.copy(this.at(t, _vector$a));\n      return this;\n    }\n    closestPointToPoint(point, target) {\n      target.subVectors(point, this.origin);\n      const directionDistance = target.dot(this.direction);\n      if (directionDistance < 0) {\n        return target.copy(this.origin);\n      }\n      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    }\n    distanceToPoint(point) {\n      return Math.sqrt(this.distanceSqToPoint(point));\n    }\n    distanceSqToPoint(point) {\n      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n      return _vector$a.distanceToSquared(point);\n    }\n    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n      _segDir.copy(v1).sub(v0).normalize();\n      _diff.copy(this.origin).sub(_segCenter);\n      const segExtent = v0.distanceTo(v1) * 0.5;\n      const a01 = -this.direction.dot(_segDir);\n      const b0 = _diff.dot(this.direction);\n      const b1 = -_diff.dot(_segDir);\n      const c = _diff.lengthSq();\n      const det = Math.abs(1 - a01 * a01);\n      let s0, s1, sqrDist, extDet;\n      if (det > 0) {\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              const invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n      }\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n      }\n      return sqrDist;\n    }\n    intersectSphere(sphere, target) {\n      _vector$a.subVectors(sphere.center, this.origin);\n      const tca = _vector$a.dot(this.direction);\n      const d2 = _vector$a.dot(_vector$a) - tca * tca;\n      const radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      const thc = Math.sqrt(radius2 - d2);\n      const t0 = tca - thc;\n      const t1 = tca + thc;\n      if (t1 < 0) return null;\n      if (t0 < 0) return this.at(t1, target);\n      return this.at(t0, target);\n    }\n    intersectsSphere(sphere) {\n      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    distanceToPlane(plane) {\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator === 0) {\n        if (plane.distanceToPoint(this.origin) === 0) {\n          return 0;\n        }\n        return null;\n      }\n      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n      return t >= 0 ? t : null;\n    }\n    intersectPlane(plane, target) {\n      const t = this.distanceToPlane(plane);\n      if (t === null) {\n        return null;\n      }\n      return this.at(t, target);\n    }\n    intersectsPlane(plane) {\n      const distToPoint = plane.distanceToPoint(this.origin);\n      if (distToPoint === 0) {\n        return true;\n      }\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator * distToPoint < 0) {\n        return true;\n      }\n      return false;\n    }\n    intersectBox(box, target) {\n      let tmin, tmax, tymin, tymax, tzmin, tzmax;\n      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n      const origin = this.origin;\n      if (invdirx >= 0) {\n        tmin = (box.min.x - origin.x) * invdirx;\n        tmax = (box.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (box.max.x - origin.x) * invdirx;\n        tmax = (box.min.x - origin.x) * invdirx;\n      }\n      if (invdiry >= 0) {\n        tymin = (box.min.y - origin.y) * invdiry;\n        tymax = (box.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (box.max.y - origin.y) * invdiry;\n        tymax = (box.min.y - origin.y) * invdiry;\n      }\n      if (tmin > tymax || tymin > tmax) return null;\n      if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n      if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n      if (invdirz >= 0) {\n        tzmin = (box.min.z - origin.z) * invdirz;\n        tzmax = (box.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (box.max.z - origin.z) * invdirz;\n        tzmax = (box.min.z - origin.z) * invdirz;\n      }\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, target);\n    }\n    intersectsBox(box) {\n      return this.intersectBox(box, _vector$a) !== null;\n    }\n    intersectTriangle(a, b, c, backfaceCulling, target) {\n      _edge1.subVectors(b, a);\n      _edge2.subVectors(c, a);\n      _normal$1.crossVectors(_edge1, _edge2);\n      let DdN = this.direction.dot(_normal$1);\n      let sign;\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n      _diff.subVectors(this.origin, a);\n      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n      if (DdQxE2 < 0) {\n        return null;\n      }\n      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n      if (DdE1xQ < 0) {\n        return null;\n      }\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      }\n      const QdN = -sign * _diff.dot(_normal$1);\n      if (QdN < 0) {\n        return null;\n      }\n      return this.at(QdN / DdN, target);\n    }\n    applyMatrix4(matrix4) {\n      this.origin.applyMatrix4(matrix4);\n      this.direction.transformDirection(matrix4);\n      return this;\n    }\n    equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Matrix4 {\n    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      Matrix4.prototype.isMatrix4 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n      }\n    }\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      const te = this.elements;\n      te[0] = n11;\n      te[4] = n12;\n      te[8] = n13;\n      te[12] = n14;\n      te[1] = n21;\n      te[5] = n22;\n      te[9] = n23;\n      te[13] = n24;\n      te[2] = n31;\n      te[6] = n32;\n      te[10] = n33;\n      te[14] = n34;\n      te[3] = n41;\n      te[7] = n42;\n      te[11] = n43;\n      te[15] = n44;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    clone() {\n      return new Matrix4().fromArray(this.elements);\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      te[9] = me[9];\n      te[10] = me[10];\n      te[11] = me[11];\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      te[15] = me[15];\n      return this;\n    }\n    copyPosition(m) {\n      const te = this.elements, me = m.elements;\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      return this;\n    }\n    setFromMatrix3(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[3],\n        me[6],\n        0,\n        me[1],\n        me[4],\n        me[7],\n        0,\n        me[2],\n        me[5],\n        me[8],\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrixColumn(this, 0);\n      yAxis.setFromMatrixColumn(this, 1);\n      zAxis.setFromMatrixColumn(this, 2);\n      return this;\n    }\n    makeBasis(xAxis, yAxis, zAxis) {\n      this.set(\n        xAxis.x,\n        yAxis.x,\n        zAxis.x,\n        0,\n        xAxis.y,\n        yAxis.y,\n        zAxis.y,\n        0,\n        xAxis.z,\n        yAxis.z,\n        zAxis.z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractRotation(m) {\n      const te = this.elements;\n      const me = m.elements;\n      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[3] = 0;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[7] = 0;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromEuler(euler) {\n      const te = this.elements;\n      const x2 = euler.x, y = euler.y, z = euler.z;\n      const a = Math.cos(x2), b = Math.sin(x2);\n      const c = Math.cos(y), d = Math.sin(y);\n      const e = Math.cos(z), f = Math.sin(z);\n      if (euler.order === "XYZ") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = -c * f;\n        te[8] = d;\n        te[1] = af + be * d;\n        te[5] = ae - bf * d;\n        te[9] = -b * c;\n        te[2] = bf - ae * d;\n        te[6] = be + af * d;\n        te[10] = a * c;\n      } else if (euler.order === "YXZ") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce + df * b;\n        te[4] = de * b - cf;\n        te[8] = a * d;\n        te[1] = a * f;\n        te[5] = a * e;\n        te[9] = -b;\n        te[2] = cf * b - de;\n        te[6] = df + ce * b;\n        te[10] = a * c;\n      } else if (euler.order === "ZXY") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce - df * b;\n        te[4] = -a * f;\n        te[8] = de + cf * b;\n        te[1] = cf + de * b;\n        te[5] = a * e;\n        te[9] = df - ce * b;\n        te[2] = -a * d;\n        te[6] = b;\n        te[10] = a * c;\n      } else if (euler.order === "ZYX") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = be * d - af;\n        te[8] = ae * d + bf;\n        te[1] = c * f;\n        te[5] = bf * d + ae;\n        te[9] = af * d - be;\n        te[2] = -d;\n        te[6] = b * c;\n        te[10] = a * c;\n      } else if (euler.order === "YZX") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = bd - ac * f;\n        te[8] = bc * f + ad;\n        te[1] = f;\n        te[5] = a * e;\n        te[9] = -b * e;\n        te[2] = -d * e;\n        te[6] = ad * f + bc;\n        te[10] = ac - bd * f;\n      } else if (euler.order === "XZY") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = -f;\n        te[8] = d * e;\n        te[1] = ac * f + bd;\n        te[5] = a * e;\n        te[9] = ad * f - bc;\n        te[2] = bc * f - ad;\n        te[6] = b * e;\n        te[10] = bd * f + ac;\n      }\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromQuaternion(q) {\n      return this.compose(_zero, q, _one);\n    }\n    lookAt(eye, target, up) {\n      const te = this.elements;\n      _z.subVectors(eye, target);\n      if (_z.lengthSq() === 0) {\n        _z.z = 1;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n      if (_x.lengthSq() === 0) {\n        if (Math.abs(up.z) === 1) {\n          _z.x += 1e-4;\n        } else {\n          _z.z += 1e-4;\n        }\n        _z.normalize();\n        _x.crossVectors(up, _z);\n      }\n      _x.normalize();\n      _y.crossVectors(_z, _x);\n      te[0] = _x.x;\n      te[4] = _y.x;\n      te[8] = _z.x;\n      te[1] = _x.y;\n      te[5] = _y.y;\n      te[9] = _z.y;\n      te[2] = _x.z;\n      te[6] = _y.z;\n      te[10] = _z.z;\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[4] *= s;\n      te[8] *= s;\n      te[12] *= s;\n      te[1] *= s;\n      te[5] *= s;\n      te[9] *= s;\n      te[13] *= s;\n      te[2] *= s;\n      te[6] *= s;\n      te[10] *= s;\n      te[14] *= s;\n      te[3] *= s;\n      te[7] *= s;\n      te[11] *= s;\n      te[15] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n    transpose() {\n      const te = this.elements;\n      let tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n    setPosition(x2, y, z) {\n      const te = this.elements;\n      if (x2.isVector3) {\n        te[12] = x2.x;\n        te[13] = x2.y;\n        te[14] = x2.z;\n      } else {\n        te[12] = x2;\n        te[13] = y;\n        te[14] = z;\n      }\n      return this;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return this;\n    }\n    scale(v) {\n      const te = this.elements;\n      const x2 = v.x, y = v.y, z = v.z;\n      te[0] *= x2;\n      te[4] *= y;\n      te[8] *= z;\n      te[1] *= x2;\n      te[5] *= y;\n      te[9] *= z;\n      te[2] *= x2;\n      te[6] *= y;\n      te[10] *= z;\n      te[3] *= x2;\n      te[7] *= y;\n      te[11] *= z;\n      return this;\n    }\n    getMaxScaleOnAxis() {\n      const te = this.elements;\n      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    makeTranslation(x2, y, z) {\n      if (x2.isVector3) {\n        this.set(\n          1,\n          0,\n          0,\n          x2.x,\n          0,\n          1,\n          0,\n          x2.y,\n          0,\n          0,\n          1,\n          x2.z,\n          0,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          0,\n          x2,\n          0,\n          1,\n          0,\n          y,\n          0,\n          0,\n          1,\n          z,\n          0,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotationX(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationY(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        0,\n        s,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -s,\n        0,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationZ(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationAxis(axis, angle) {\n      const c = Math.cos(angle);\n      const s = Math.sin(angle);\n      const t = 1 - c;\n      const x2 = axis.x, y = axis.y, z = axis.z;\n      const tx = t * x2, ty = t * y;\n      this.set(\n        tx * x2 + c,\n        tx * y - s * z,\n        tx * z + s * y,\n        0,\n        tx * y + s * z,\n        ty * y + c,\n        ty * z - s * x2,\n        0,\n        tx * z - s * y,\n        ty * z + s * x2,\n        t * z * z + c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y, z) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        0,\n        z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeShear(xy, xz, yx, yz, zx, zy) {\n      this.set(\n        1,\n        yx,\n        zx,\n        0,\n        xy,\n        1,\n        zy,\n        0,\n        xz,\n        yz,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    compose(position, quaternion, scale) {\n      const te = this.elements;\n      const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n      const x22 = x2 + x2, y2 = y + y, z2 = z + z;\n      const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;\n      const yy = y * y2, yz = y * z2, zz = z * z2;\n      const wx = w * x22, wy = w * y2, wz = w * z2;\n      const sx = scale.x, sy = scale.y, sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n    decompose(position, quaternion, scale) {\n      const te = this.elements;\n      let sx = _v1$5.set(te[0], te[1], te[2]).length();\n      const sy = _v1$5.set(te[4], te[5], te[6]).length();\n      const sz = _v1$5.set(te[8], te[9], te[10]).length();\n      const det = this.determinant();\n      if (det < 0) sx = -sx;\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14];\n      _m1$2.copy(this);\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      _m1$2.elements[0] *= invSX;\n      _m1$2.elements[1] *= invSX;\n      _m1$2.elements[2] *= invSX;\n      _m1$2.elements[4] *= invSY;\n      _m1$2.elements[5] *= invSY;\n      _m1$2.elements[6] *= invSY;\n      _m1$2.elements[8] *= invSZ;\n      _m1$2.elements[9] *= invSZ;\n      _m1$2.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(_m1$2);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    }\n    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const x2 = 2 * near / (right - left);\n      const y = 2 * near / (top - bottom);\n      const a = (right + left) / (right - left);\n      const b = (top + bottom) / (top - bottom);\n      let c, d;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        c = -(far + near) / (far - near);\n        d = -2 * far * near / (far - near);\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        c = -far / (far - near);\n        d = -far * near / (far - near);\n      } else {\n        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);\n      }\n      te[0] = x2;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const w = 1 / (right - left);\n      const h = 1 / (top - bottom);\n      const p = 1 / (far - near);\n      const x2 = (right + left) * w;\n      const y = (top + bottom) * h;\n      let z, zInv;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        z = (far + near) * p;\n        zInv = -2 * p;\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        z = near * p;\n        zInv = -1 * p;\n      } else {\n        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);\n      }\n      te[0] = 2 * w;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = -x2;\n      te[1] = 0;\n      te[5] = 2 * h;\n      te[9] = 0;\n      te[13] = -y;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = zInv;\n      te[14] = -z;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 16; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 16; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      array[offset + 9] = te[9];\n      array[offset + 10] = te[10];\n      array[offset + 11] = te[11];\n      array[offset + 12] = te[12];\n      array[offset + 13] = te[13];\n      array[offset + 14] = te[14];\n      array[offset + 15] = te[15];\n      return array;\n    }\n  }\n  const _v1$5 = /* @__PURE__ */ new Vector3();\n  const _m1$2 = /* @__PURE__ */ new Matrix4();\n  const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\n  const _one = /* @__PURE__ */ new Vector3(1, 1, 1);\n  const _x = /* @__PURE__ */ new Vector3();\n  const _y = /* @__PURE__ */ new Vector3();\n  const _z = /* @__PURE__ */ new Vector3();\n  const _matrix$2 = /* @__PURE__ */ new Matrix4();\n  const _quaternion$3 = /* @__PURE__ */ new Quaternion();\n  class Euler {\n    constructor(x2 = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n      this.isEuler = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get order() {\n      return this._order;\n    }\n    set order(value) {\n      this._order = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, order = this._order) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    }\n    copy(euler) {\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m, order = this._order, update = true) {\n      const te = m.elements;\n      const m11 = te[0], m12 = te[4], m13 = te[8];\n      const m21 = te[1], m22 = te[5], m23 = te[9];\n      const m31 = te[2], m32 = te[6], m33 = te[10];\n      switch (order) {\n        case "XYZ":\n          this._y = Math.asin(clamp(m13, -1, 1));\n          if (Math.abs(m13) < 0.9999999) {\n            this._x = Math.atan2(-m23, m33);\n            this._z = Math.atan2(-m12, m11);\n          } else {\n            this._x = Math.atan2(m32, m22);\n            this._z = 0;\n          }\n          break;\n        case "YXZ":\n          this._x = Math.asin(-clamp(m23, -1, 1));\n          if (Math.abs(m23) < 0.9999999) {\n            this._y = Math.atan2(m13, m33);\n            this._z = Math.atan2(m21, m22);\n          } else {\n            this._y = Math.atan2(-m31, m11);\n            this._z = 0;\n          }\n          break;\n        case "ZXY":\n          this._x = Math.asin(clamp(m32, -1, 1));\n          if (Math.abs(m32) < 0.9999999) {\n            this._y = Math.atan2(-m31, m33);\n            this._z = Math.atan2(-m12, m22);\n          } else {\n            this._y = 0;\n            this._z = Math.atan2(m21, m11);\n          }\n          break;\n        case "ZYX":\n          this._y = Math.asin(-clamp(m31, -1, 1));\n          if (Math.abs(m31) < 0.9999999) {\n            this._x = Math.atan2(m32, m33);\n            this._z = Math.atan2(m21, m11);\n          } else {\n            this._x = 0;\n            this._z = Math.atan2(-m12, m22);\n          }\n          break;\n        case "YZX":\n          this._z = Math.asin(clamp(m21, -1, 1));\n          if (Math.abs(m21) < 0.9999999) {\n            this._x = Math.atan2(-m23, m22);\n            this._y = Math.atan2(-m31, m11);\n          } else {\n            this._x = 0;\n            this._y = Math.atan2(m13, m33);\n          }\n          break;\n        case "XZY":\n          this._z = Math.asin(-clamp(m12, -1, 1));\n          if (Math.abs(m12) < 0.9999999) {\n            this._x = Math.atan2(m32, m22);\n            this._y = Math.atan2(m13, m11);\n          } else {\n            this._x = Math.atan2(-m23, m33);\n            this._y = 0;\n          }\n          break;\n        default:\n          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);\n      }\n      this._order = order;\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromQuaternion(q, order, update) {\n      _matrix$2.makeRotationFromQuaternion(q);\n      return this.setFromRotationMatrix(_matrix$2, order, update);\n    }\n    setFromVector3(v, order = this._order) {\n      return this.set(v.x, v.y, v.z, order);\n    }\n    reorder(newOrder) {\n      _quaternion$3.setFromEuler(this);\n      return this.setFromQuaternion(_quaternion$3, newOrder);\n    }\n    equals(euler) {\n      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n    }\n    fromArray(array) {\n      this._x = array[0];\n      this._y = array[1];\n      this._z = array[2];\n      if (array[3] !== void 0) this._order = array[3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._order;\n      return array;\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._order;\n    }\n  }\n  Euler.DEFAULT_ORDER = "XYZ";\n  class Layers {\n    constructor() {\n      this.mask = 1 | 0;\n    }\n    set(channel) {\n      this.mask = (1 << channel | 0) >>> 0;\n    }\n    enable(channel) {\n      this.mask |= 1 << channel | 0;\n    }\n    enableAll() {\n      this.mask = 4294967295 | 0;\n    }\n    toggle(channel) {\n      this.mask ^= 1 << channel | 0;\n    }\n    disable(channel) {\n      this.mask &= ~(1 << channel | 0);\n    }\n    disableAll() {\n      this.mask = 0;\n    }\n    test(layers) {\n      return (this.mask & layers.mask) !== 0;\n    }\n    isEnabled(channel) {\n      return (this.mask & (1 << channel | 0)) !== 0;\n    }\n  }\n  let _object3DId = 0;\n  const _v1$4 = /* @__PURE__ */ new Vector3();\n  const _q1 = /* @__PURE__ */ new Quaternion();\n  const _m1$1 = /* @__PURE__ */ new Matrix4();\n  const _target = /* @__PURE__ */ new Vector3();\n  const _position$3 = /* @__PURE__ */ new Vector3();\n  const _scale$2 = /* @__PURE__ */ new Vector3();\n  const _quaternion$2 = /* @__PURE__ */ new Quaternion();\n  const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);\n  const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\n  const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\n  const _addedEvent = { type: "added" };\n  const _removedEvent = { type: "removed" };\n  const _childaddedEvent = { type: "childadded", child: null };\n  const _childremovedEvent = { type: "childremoved", child: null };\n  class Object3D extends EventDispatcher {\n    constructor() {\n      super();\n      this.isObject3D = true;\n      Object.defineProperty(this, "id", { value: _object3DId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Object3D";\n      this.parent = null;\n      this.children = [];\n      this.up = Object3D.DEFAULT_UP.clone();\n      const position = new Vector3();\n      const rotation = new Euler();\n      const quaternion = new Quaternion();\n      const scale = new Vector3(1, 1, 1);\n      function onRotationChange() {\n        quaternion.setFromEuler(rotation, false);\n      }\n      function onQuaternionChange() {\n        rotation.setFromQuaternion(quaternion, void 0, false);\n      }\n      rotation._onChange(onRotationChange);\n      quaternion._onChange(onQuaternionChange);\n      Object.defineProperties(this, {\n        position: {\n          configurable: true,\n          enumerable: true,\n          value: position\n        },\n        rotation: {\n          configurable: true,\n          enumerable: true,\n          value: rotation\n        },\n        quaternion: {\n          configurable: true,\n          enumerable: true,\n          value: quaternion\n        },\n        scale: {\n          configurable: true,\n          enumerable: true,\n          value: scale\n        },\n        modelViewMatrix: {\n          value: new Matrix4()\n        },\n        normalMatrix: {\n          value: new Matrix3()\n        }\n      });\n      this.matrix = new Matrix4();\n      this.matrixWorld = new Matrix4();\n      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n      this.matrixWorldNeedsUpdate = false;\n      this.layers = new Layers();\n      this.visible = true;\n      this.castShadow = false;\n      this.receiveShadow = false;\n      this.frustumCulled = true;\n      this.renderOrder = 0;\n      this.animations = [];\n      this.userData = {};\n    }\n    onBeforeShadow() {\n    }\n    onAfterShadow() {\n    }\n    onBeforeRender() {\n    }\n    onAfterRender() {\n    }\n    applyMatrix4(matrix) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.matrix.premultiply(matrix);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    applyQuaternion(q) {\n      this.quaternion.premultiply(q);\n      return this;\n    }\n    setRotationFromAxisAngle(axis, angle) {\n      this.quaternion.setFromAxisAngle(axis, angle);\n    }\n    setRotationFromEuler(euler) {\n      this.quaternion.setFromEuler(euler, true);\n    }\n    setRotationFromMatrix(m) {\n      this.quaternion.setFromRotationMatrix(m);\n    }\n    setRotationFromQuaternion(q) {\n      this.quaternion.copy(q);\n    }\n    rotateOnAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.multiply(_q1);\n      return this;\n    }\n    rotateOnWorldAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.premultiply(_q1);\n      return this;\n    }\n    rotateX(angle) {\n      return this.rotateOnAxis(_xAxis, angle);\n    }\n    rotateY(angle) {\n      return this.rotateOnAxis(_yAxis, angle);\n    }\n    rotateZ(angle) {\n      return this.rotateOnAxis(_zAxis, angle);\n    }\n    translateOnAxis(axis, distance) {\n      _v1$4.copy(axis).applyQuaternion(this.quaternion);\n      this.position.add(_v1$4.multiplyScalar(distance));\n      return this;\n    }\n    translateX(distance) {\n      return this.translateOnAxis(_xAxis, distance);\n    }\n    translateY(distance) {\n      return this.translateOnAxis(_yAxis, distance);\n    }\n    translateZ(distance) {\n      return this.translateOnAxis(_zAxis, distance);\n    }\n    localToWorld(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(this.matrixWorld);\n    }\n    worldToLocal(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n    }\n    lookAt(x2, y, z) {\n      if (x2.isVector3) {\n        _target.copy(x2);\n      } else {\n        _target.set(x2, y, z);\n      }\n      const parent = this.parent;\n      this.updateWorldMatrix(true, false);\n      _position$3.setFromMatrixPosition(this.matrixWorld);\n      if (this.isCamera || this.isLight) {\n        _m1$1.lookAt(_position$3, _target, this.up);\n      } else {\n        _m1$1.lookAt(_target, _position$3, this.up);\n      }\n      this.quaternion.setFromRotationMatrix(_m1$1);\n      if (parent) {\n        _m1$1.extractRotation(parent.matrixWorld);\n        _q1.setFromRotationMatrix(_m1$1);\n        this.quaternion.premultiply(_q1.invert());\n      }\n    }\n    add(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.add(arguments[i2]);\n        }\n        return this;\n      }\n      if (object === this) {\n        console.error("THREE.Object3D.add: object can\'t be added as a child of itself.", object);\n        return this;\n      }\n      if (object && object.isObject3D) {\n        object.removeFromParent();\n        object.parent = this;\n        this.children.push(object);\n        object.dispatchEvent(_addedEvent);\n        _childaddedEvent.child = object;\n        this.dispatchEvent(_childaddedEvent);\n        _childaddedEvent.child = null;\n      } else {\n        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);\n      }\n      return this;\n    }\n    remove(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.remove(arguments[i2]);\n        }\n        return this;\n      }\n      const index = this.children.indexOf(object);\n      if (index !== -1) {\n        object.parent = null;\n        this.children.splice(index, 1);\n        object.dispatchEvent(_removedEvent);\n        _childremovedEvent.child = object;\n        this.dispatchEvent(_childremovedEvent);\n        _childremovedEvent.child = null;\n      }\n      return this;\n    }\n    removeFromParent() {\n      const parent = this.parent;\n      if (parent !== null) {\n        parent.remove(this);\n      }\n      return this;\n    }\n    clear() {\n      return this.remove(...this.children);\n    }\n    attach(object) {\n      this.updateWorldMatrix(true, false);\n      _m1$1.copy(this.matrixWorld).invert();\n      if (object.parent !== null) {\n        object.parent.updateWorldMatrix(true, false);\n        _m1$1.multiply(object.parent.matrixWorld);\n      }\n      object.applyMatrix4(_m1$1);\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.updateWorldMatrix(false, true);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n      return this;\n    }\n    getObjectById(id) {\n      return this.getObjectByProperty("id", id);\n    }\n    getObjectByName(name) {\n      return this.getObjectByProperty("name", name);\n    }\n    getObjectByProperty(name, value) {\n      if (this[name] === value) return this;\n      for (let i2 = 0, l = this.children.length; i2 < l; i2++) {\n        const child = this.children[i2];\n        const object = child.getObjectByProperty(name, value);\n        if (object !== void 0) {\n          return object;\n        }\n      }\n      return void 0;\n    }\n    getObjectsByProperty(name, value, result = []) {\n      if (this[name] === value) result.push(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].getObjectsByProperty(name, value, result);\n      }\n      return result;\n    }\n    getWorldPosition(target) {\n      this.updateWorldMatrix(true, false);\n      return target.setFromMatrixPosition(this.matrixWorld);\n    }\n    getWorldQuaternion(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, target, _scale$2);\n      return target;\n    }\n    getWorldScale(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n      return target;\n    }\n    getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      const e = this.matrixWorld.elements;\n      return target.set(e[8], e[9], e[10]).normalize();\n    }\n    raycast() {\n    }\n    traverse(callback) {\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverse(callback);\n      }\n    }\n    traverseVisible(callback) {\n      if (this.visible === false) return;\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverseVisible(callback);\n      }\n    }\n    traverseAncestors(callback) {\n      const parent = this.parent;\n      if (parent !== null) {\n        callback(parent);\n        parent.traverseAncestors(callback);\n      }\n    }\n    updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale);\n      this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldNeedsUpdate || force) {\n        if (this.matrixWorldAutoUpdate === true) {\n          if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n          } else {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n          }\n        }\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n      }\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        const child = children[i2];\n        child.updateMatrixWorld(force);\n      }\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      const parent = this.parent;\n      if (updateParents === true && parent !== null) {\n        parent.updateWorldMatrix(true, false);\n      }\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      if (updateChildren === true) {\n        const children = this.children;\n        for (let i2 = 0, l = children.length; i2 < l; i2++) {\n          const child = children[i2];\n          child.updateWorldMatrix(false, true);\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      const output = {};\n      if (isRootObject) {\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {},\n          shapes: {},\n          skeletons: {},\n          animations: {},\n          nodes: {}\n        };\n        output.metadata = {\n          version: 4.6,\n          type: "Object",\n          generator: "Object3D.toJSON"\n        };\n      }\n      const object = {};\n      object.uuid = this.uuid;\n      object.type = this.type;\n      if (this.name !== "") object.name = this.name;\n      if (this.castShadow === true) object.castShadow = true;\n      if (this.receiveShadow === true) object.receiveShadow = true;\n      if (this.visible === false) object.visible = false;\n      if (this.frustumCulled === false) object.frustumCulled = false;\n      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n      if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n      object.layers = this.layers.mask;\n      object.matrix = this.matrix.toArray();\n      object.up = this.up.toArray();\n      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n      if (this.isInstancedMesh) {\n        object.type = "InstancedMesh";\n        object.count = this.count;\n        object.instanceMatrix = this.instanceMatrix.toJSON();\n        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n      }\n      if (this.isBatchedMesh) {\n        object.type = "BatchedMesh";\n        object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n        object.sortObjects = this.sortObjects;\n        object.drawRanges = this._drawRanges;\n        object.reservedRanges = this._reservedRanges;\n        object.visibility = this._visibility;\n        object.active = this._active;\n        object.bounds = this._bounds.map((bound) => ({\n          boxInitialized: bound.boxInitialized,\n          boxMin: bound.box.min.toArray(),\n          boxMax: bound.box.max.toArray(),\n          sphereInitialized: bound.sphereInitialized,\n          sphereRadius: bound.sphere.radius,\n          sphereCenter: bound.sphere.center.toArray()\n        }));\n        object.maxInstanceCount = this._maxInstanceCount;\n        object.maxVertexCount = this._maxVertexCount;\n        object.maxIndexCount = this._maxIndexCount;\n        object.geometryInitialized = this._geometryInitialized;\n        object.geometryCount = this._geometryCount;\n        object.matricesTexture = this._matricesTexture.toJSON(meta);\n        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);\n        if (this.boundingSphere !== null) {\n          object.boundingSphere = {\n            center: object.boundingSphere.center.toArray(),\n            radius: object.boundingSphere.radius\n          };\n        }\n        if (this.boundingBox !== null) {\n          object.boundingBox = {\n            min: object.boundingBox.min.toArray(),\n            max: object.boundingBox.max.toArray()\n          };\n        }\n      }\n      function serialize(library, element) {\n        if (library[element.uuid] === void 0) {\n          library[element.uuid] = element.toJSON(meta);\n        }\n        return element.uuid;\n      }\n      if (this.isScene) {\n        if (this.background) {\n          if (this.background.isColor) {\n            object.background = this.background.toJSON();\n          } else if (this.background.isTexture) {\n            object.background = this.background.toJSON(meta).uuid;\n          }\n        }\n        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n          object.environment = this.environment.toJSON(meta).uuid;\n        }\n      } else if (this.isMesh || this.isLine || this.isPoints) {\n        object.geometry = serialize(meta.geometries, this.geometry);\n        const parameters = this.geometry.parameters;\n        if (parameters !== void 0 && parameters.shapes !== void 0) {\n          const shapes = parameters.shapes;\n          if (Array.isArray(shapes)) {\n            for (let i2 = 0, l = shapes.length; i2 < l; i2++) {\n              const shape = shapes[i2];\n              serialize(meta.shapes, shape);\n            }\n          } else {\n            serialize(meta.shapes, shapes);\n          }\n        }\n      }\n      if (this.isSkinnedMesh) {\n        object.bindMode = this.bindMode;\n        object.bindMatrix = this.bindMatrix.toArray();\n        if (this.skeleton !== void 0) {\n          serialize(meta.skeletons, this.skeleton);\n          object.skeleton = this.skeleton.uuid;\n        }\n      }\n      if (this.material !== void 0) {\n        if (Array.isArray(this.material)) {\n          const uuids = [];\n          for (let i2 = 0, l = this.material.length; i2 < l; i2++) {\n            uuids.push(serialize(meta.materials, this.material[i2]));\n          }\n          object.material = uuids;\n        } else {\n          object.material = serialize(meta.materials, this.material);\n        }\n      }\n      if (this.children.length > 0) {\n        object.children = [];\n        for (let i2 = 0; i2 < this.children.length; i2++) {\n          object.children.push(this.children[i2].toJSON(meta).object);\n        }\n      }\n      if (this.animations.length > 0) {\n        object.animations = [];\n        for (let i2 = 0; i2 < this.animations.length; i2++) {\n          const animation = this.animations[i2];\n          object.animations.push(serialize(meta.animations, animation));\n        }\n      }\n      if (isRootObject) {\n        const geometries = extractFromCache(meta.geometries);\n        const materials = extractFromCache(meta.materials);\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        const shapes = extractFromCache(meta.shapes);\n        const skeletons = extractFromCache(meta.skeletons);\n        const animations = extractFromCache(meta.animations);\n        const nodes = extractFromCache(meta.nodes);\n        if (geometries.length > 0) output.geometries = geometries;\n        if (materials.length > 0) output.materials = materials;\n        if (textures.length > 0) output.textures = textures;\n        if (images.length > 0) output.images = images;\n        if (shapes.length > 0) output.shapes = shapes;\n        if (skeletons.length > 0) output.skeletons = skeletons;\n        if (animations.length > 0) output.animations = animations;\n        if (nodes.length > 0) output.nodes = nodes;\n      }\n      output.object = object;\n      return output;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data = cache[key];\n          delete data.metadata;\n          values.push(data);\n        }\n        return values;\n      }\n    }\n    clone(recursive) {\n      return new this.constructor().copy(this, recursive);\n    }\n    copy(source, recursive = true) {\n      this.name = source.name;\n      this.up.copy(source.up);\n      this.position.copy(source.position);\n      this.rotation.order = source.rotation.order;\n      this.quaternion.copy(source.quaternion);\n      this.scale.copy(source.scale);\n      this.matrix.copy(source.matrix);\n      this.matrixWorld.copy(source.matrixWorld);\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n      this.animations = source.animations.slice();\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      if (recursive === true) {\n        for (let i2 = 0; i2 < source.children.length; i2++) {\n          const child = source.children[i2];\n          this.add(child.clone());\n        }\n      }\n      return this;\n    }\n  }\n  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);\n  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\n  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n  const _v0$1 = /* @__PURE__ */ new Vector3();\n  const _v1$3 = /* @__PURE__ */ new Vector3();\n  const _v2$2 = /* @__PURE__ */ new Vector3();\n  const _v3$2 = /* @__PURE__ */ new Vector3();\n  const _vab = /* @__PURE__ */ new Vector3();\n  const _vac = /* @__PURE__ */ new Vector3();\n  const _vbc = /* @__PURE__ */ new Vector3();\n  const _vap = /* @__PURE__ */ new Vector3();\n  const _vbp = /* @__PURE__ */ new Vector3();\n  const _vcp = /* @__PURE__ */ new Vector3();\n  const _v40 = /* @__PURE__ */ new Vector4();\n  const _v41 = /* @__PURE__ */ new Vector4();\n  const _v42 = /* @__PURE__ */ new Vector4();\n  class Triangle {\n    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n    static getNormal(a, b, c, target) {\n      target.subVectors(c, b);\n      _v0$1.subVectors(a, b);\n      target.cross(_v0$1);\n      const targetLengthSq = target.lengthSq();\n      if (targetLengthSq > 0) {\n        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n      }\n      return target.set(0, 0, 0);\n    }\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    static getBarycoord(point, a, b, c, target) {\n      _v0$1.subVectors(c, a);\n      _v1$3.subVectors(b, a);\n      _v2$2.subVectors(point, a);\n      const dot00 = _v0$1.dot(_v0$1);\n      const dot01 = _v0$1.dot(_v1$3);\n      const dot02 = _v0$1.dot(_v2$2);\n      const dot11 = _v1$3.dot(_v1$3);\n      const dot12 = _v1$3.dot(_v2$2);\n      const denom = dot00 * dot11 - dot01 * dot01;\n      if (denom === 0) {\n        target.set(0, 0, 0);\n        return null;\n      }\n      const invDenom = 1 / denom;\n      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n      return target.set(1 - u - v, v, u);\n    }\n    static containsPoint(point, a, b, c) {\n      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n        return false;\n      }\n      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n    }\n    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n        target.x = 0;\n        target.y = 0;\n        if ("z" in target) target.z = 0;\n        if ("w" in target) target.w = 0;\n        return null;\n      }\n      target.setScalar(0);\n      target.addScaledVector(v1, _v3$2.x);\n      target.addScaledVector(v2, _v3$2.y);\n      target.addScaledVector(v3, _v3$2.z);\n      return target;\n    }\n    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n      _v40.setScalar(0);\n      _v41.setScalar(0);\n      _v42.setScalar(0);\n      _v40.fromBufferAttribute(attr, i1);\n      _v41.fromBufferAttribute(attr, i2);\n      _v42.fromBufferAttribute(attr, i3);\n      target.setScalar(0);\n      target.addScaledVector(_v40, barycoord.x);\n      target.addScaledVector(_v41, barycoord.y);\n      target.addScaledVector(_v42, barycoord.z);\n      return target;\n    }\n    static isFrontFacing(a, b, c, direction) {\n      _v0$1.subVectors(c, b);\n      _v1$3.subVectors(a, b);\n      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n    }\n    set(a, b, c) {\n      this.a.copy(a);\n      this.b.copy(b);\n      this.c.copy(c);\n      return this;\n    }\n    setFromPointsAndIndices(points, i0, i1, i2) {\n      this.a.copy(points[i0]);\n      this.b.copy(points[i1]);\n      this.c.copy(points[i2]);\n      return this;\n    }\n    setFromAttributeAndIndices(attribute, i0, i1, i2) {\n      this.a.fromBufferAttribute(attribute, i0);\n      this.b.fromBufferAttribute(attribute, i1);\n      this.c.fromBufferAttribute(attribute, i2);\n      return this;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(triangle) {\n      this.a.copy(triangle.a);\n      this.b.copy(triangle.b);\n      this.c.copy(triangle.c);\n      return this;\n    }\n    getArea() {\n      _v0$1.subVectors(this.c, this.b);\n      _v1$3.subVectors(this.a, this.b);\n      return _v0$1.cross(_v1$3).length() * 0.5;\n    }\n    getMidpoint(target) {\n      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    }\n    getNormal(target) {\n      return Triangle.getNormal(this.a, this.b, this.c, target);\n    }\n    getPlane(target) {\n      return target.setFromCoplanarPoints(this.a, this.b, this.c);\n    }\n    getBarycoord(point, target) {\n      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n    }\n    getInterpolation(point, v1, v2, v3, target) {\n      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n    }\n    containsPoint(point) {\n      return Triangle.containsPoint(point, this.a, this.b, this.c);\n    }\n    isFrontFacing(direction) {\n      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n    }\n    intersectsBox(box) {\n      return box.intersectsTriangle(this);\n    }\n    closestPointToPoint(p, target) {\n      const a = this.a, b = this.b, c = this.c;\n      let v, w;\n      _vab.subVectors(b, a);\n      _vac.subVectors(c, a);\n      _vap.subVectors(p, a);\n      const d1 = _vab.dot(_vap);\n      const d2 = _vac.dot(_vap);\n      if (d1 <= 0 && d2 <= 0) {\n        return target.copy(a);\n      }\n      _vbp.subVectors(p, b);\n      const d3 = _vab.dot(_vbp);\n      const d4 = _vac.dot(_vbp);\n      if (d3 >= 0 && d4 <= d3) {\n        return target.copy(b);\n      }\n      const vc = d1 * d4 - d3 * d2;\n      if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n        v = d1 / (d1 - d3);\n        return target.copy(a).addScaledVector(_vab, v);\n      }\n      _vcp.subVectors(p, c);\n      const d5 = _vab.dot(_vcp);\n      const d6 = _vac.dot(_vcp);\n      if (d6 >= 0 && d5 <= d6) {\n        return target.copy(c);\n      }\n      const vb = d5 * d2 - d1 * d6;\n      if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n        w = d2 / (d2 - d6);\n        return target.copy(a).addScaledVector(_vac, w);\n      }\n      const va = d3 * d6 - d5 * d4;\n      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n        _vbc.subVectors(c, b);\n        w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n        return target.copy(b).addScaledVector(_vbc, w);\n      }\n      const denom = 1 / (va + vb + vc);\n      v = vb * denom;\n      w = vc * denom;\n      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n    }\n    equals(triangle) {\n      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    }\n  }\n  const _colorKeywords = {\n    "aliceblue": 15792383,\n    "antiquewhite": 16444375,\n    "aqua": 65535,\n    "aquamarine": 8388564,\n    "azure": 15794175,\n    "beige": 16119260,\n    "bisque": 16770244,\n    "black": 0,\n    "blanchedalmond": 16772045,\n    "blue": 255,\n    "blueviolet": 9055202,\n    "brown": 10824234,\n    "burlywood": 14596231,\n    "cadetblue": 6266528,\n    "chartreuse": 8388352,\n    "chocolate": 13789470,\n    "coral": 16744272,\n    "cornflowerblue": 6591981,\n    "cornsilk": 16775388,\n    "crimson": 14423100,\n    "cyan": 65535,\n    "darkblue": 139,\n    "darkcyan": 35723,\n    "darkgoldenrod": 12092939,\n    "darkgray": 11119017,\n    "darkgreen": 25600,\n    "darkgrey": 11119017,\n    "darkkhaki": 12433259,\n    "darkmagenta": 9109643,\n    "darkolivegreen": 5597999,\n    "darkorange": 16747520,\n    "darkorchid": 10040012,\n    "darkred": 9109504,\n    "darksalmon": 15308410,\n    "darkseagreen": 9419919,\n    "darkslateblue": 4734347,\n    "darkslategray": 3100495,\n    "darkslategrey": 3100495,\n    "darkturquoise": 52945,\n    "darkviolet": 9699539,\n    "deeppink": 16716947,\n    "deepskyblue": 49151,\n    "dimgray": 6908265,\n    "dimgrey": 6908265,\n    "dodgerblue": 2003199,\n    "firebrick": 11674146,\n    "floralwhite": 16775920,\n    "forestgreen": 2263842,\n    "fuchsia": 16711935,\n    "gainsboro": 14474460,\n    "ghostwhite": 16316671,\n    "gold": 16766720,\n    "goldenrod": 14329120,\n    "gray": 8421504,\n    "green": 32768,\n    "greenyellow": 11403055,\n    "grey": 8421504,\n    "honeydew": 15794160,\n    "hotpink": 16738740,\n    "indianred": 13458524,\n    "indigo": 4915330,\n    "ivory": 16777200,\n    "khaki": 15787660,\n    "lavender": 15132410,\n    "lavenderblush": 16773365,\n    "lawngreen": 8190976,\n    "lemonchiffon": 16775885,\n    "lightblue": 11393254,\n    "lightcoral": 15761536,\n    "lightcyan": 14745599,\n    "lightgoldenrodyellow": 16448210,\n    "lightgray": 13882323,\n    "lightgreen": 9498256,\n    "lightgrey": 13882323,\n    "lightpink": 16758465,\n    "lightsalmon": 16752762,\n    "lightseagreen": 2142890,\n    "lightskyblue": 8900346,\n    "lightslategray": 7833753,\n    "lightslategrey": 7833753,\n    "lightsteelblue": 11584734,\n    "lightyellow": 16777184,\n    "lime": 65280,\n    "limegreen": 3329330,\n    "linen": 16445670,\n    "magenta": 16711935,\n    "maroon": 8388608,\n    "mediumaquamarine": 6737322,\n    "mediumblue": 205,\n    "mediumorchid": 12211667,\n    "mediumpurple": 9662683,\n    "mediumseagreen": 3978097,\n    "mediumslateblue": 8087790,\n    "mediumspringgreen": 64154,\n    "mediumturquoise": 4772300,\n    "mediumvioletred": 13047173,\n    "midnightblue": 1644912,\n    "mintcream": 16121850,\n    "mistyrose": 16770273,\n    "moccasin": 16770229,\n    "navajowhite": 16768685,\n    "navy": 128,\n    "oldlace": 16643558,\n    "olive": 8421376,\n    "olivedrab": 7048739,\n    "orange": 16753920,\n    "orangered": 16729344,\n    "orchid": 14315734,\n    "palegoldenrod": 15657130,\n    "palegreen": 10025880,\n    "paleturquoise": 11529966,\n    "palevioletred": 14381203,\n    "papayawhip": 16773077,\n    "peachpuff": 16767673,\n    "peru": 13468991,\n    "pink": 16761035,\n    "plum": 14524637,\n    "powderblue": 11591910,\n    "purple": 8388736,\n    "rebeccapurple": 6697881,\n    "red": 16711680,\n    "rosybrown": 12357519,\n    "royalblue": 4286945,\n    "saddlebrown": 9127187,\n    "salmon": 16416882,\n    "sandybrown": 16032864,\n    "seagreen": 3050327,\n    "seashell": 16774638,\n    "sienna": 10506797,\n    "silver": 12632256,\n    "skyblue": 8900331,\n    "slateblue": 6970061,\n    "slategray": 7372944,\n    "slategrey": 7372944,\n    "snow": 16775930,\n    "springgreen": 65407,\n    "steelblue": 4620980,\n    "tan": 13808780,\n    "teal": 32896,\n    "thistle": 14204888,\n    "tomato": 16737095,\n    "turquoise": 4251856,\n    "violet": 15631086,\n    "wheat": 16113331,\n    "white": 16777215,\n    "whitesmoke": 16119285,\n    "yellow": 16776960,\n    "yellowgreen": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === "number") {\n          this.setHex(value);\n        } else if (typeof value === "string") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");\n        }\n      }\n      let m;\n      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case "rgb":\n          case "rgba":\n            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case "hsl":\n          case "hsla":\n            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            console.warn("THREE.Color: Unknown color model " + style);\n        }\n      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          console.warn("THREE.Color: Invalid hex color " + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        console.warn("THREE.Color: Unknown color " + style);\n      }\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    getHexString(colorSpace = SRGBColorSpace) {\n      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n      }\n      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n    }\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  let _materialId = 0;\n  class Material extends EventDispatcher {\n    constructor() {\n      super();\n      this.isMaterial = true;\n      Object.defineProperty(this, "id", { value: _materialId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Material";\n      this.blending = NormalBlending;\n      this.side = FrontSide;\n      this.vertexColors = false;\n      this.opacity = 1;\n      this.transparent = false;\n      this.alphaHash = false;\n      this.blendSrc = SrcAlphaFactor;\n      this.blendDst = OneMinusSrcAlphaFactor;\n      this.blendEquation = AddEquation;\n      this.blendSrcAlpha = null;\n      this.blendDstAlpha = null;\n      this.blendEquationAlpha = null;\n      this.blendColor = new Color(0, 0, 0);\n      this.blendAlpha = 0;\n      this.depthFunc = LessEqualDepth;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.stencilWriteMask = 255;\n      this.stencilFunc = AlwaysStencilFunc;\n      this.stencilRef = 0;\n      this.stencilFuncMask = 255;\n      this.stencilFail = KeepStencilOp;\n      this.stencilZFail = KeepStencilOp;\n      this.stencilZPass = KeepStencilOp;\n      this.stencilWrite = false;\n      this.clippingPlanes = null;\n      this.clipIntersection = false;\n      this.clipShadows = false;\n      this.shadowSide = null;\n      this.colorWrite = true;\n      this.precision = null;\n      this.polygonOffset = false;\n      this.polygonOffsetFactor = 0;\n      this.polygonOffsetUnits = 0;\n      this.dithering = false;\n      this.alphaToCoverage = false;\n      this.premultipliedAlpha = false;\n      this.forceSinglePass = false;\n      this.visible = true;\n      this.toneMapped = true;\n      this.userData = {};\n      this.version = 0;\n      this._alphaTest = 0;\n    }\n    get alphaTest() {\n      return this._alphaTest;\n    }\n    set alphaTest(value) {\n      if (this._alphaTest > 0 !== value > 0) {\n        this.version++;\n      }\n      this._alphaTest = value;\n    }\n    // onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n    onBeforeRender() {\n    }\n    onBeforeCompile() {\n    }\n    customProgramCacheKey() {\n      return this.onBeforeCompile.toString();\n    }\n    setValues(values) {\n      if (values === void 0) return;\n      for (const key in values) {\n        const newValue = values[key];\n        if (newValue === void 0) {\n          console.warn(`THREE.Material: parameter \'${key}\' has value of undefined.`);\n          continue;\n        }\n        const currentValue = this[key];\n        if (currentValue === void 0) {\n          console.warn(`THREE.Material: \'${key}\' is not a property of THREE.${this.type}.`);\n          continue;\n        }\n        if (currentValue && currentValue.isColor) {\n          currentValue.set(newValue);\n        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (isRootObject) {\n        meta = {\n          textures: {},\n          images: {}\n        };\n      }\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: "Material",\n          generator: "Material.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (this.color && this.color.isColor) data.color = this.color.getHex();\n      if (this.roughness !== void 0) data.roughness = this.roughness;\n      if (this.metalness !== void 0) data.metalness = this.metalness;\n      if (this.sheen !== void 0) data.sheen = this.sheen;\n      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;\n      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;\n      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n      if (this.shininess !== void 0) data.shininess = this.shininess;\n      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;\n      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;\n      if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n      }\n      if (this.dispersion !== void 0) data.dispersion = this.dispersion;\n      if (this.iridescence !== void 0) data.iridescence = this.iridescence;\n      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;\n      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n      if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n      }\n      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n      }\n      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;\n      if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n      }\n      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n      if (this.lightMap && this.lightMap.isTexture) {\n        data.lightMap = this.lightMap.toJSON(meta).uuid;\n        data.lightMapIntensity = this.lightMapIntensity;\n      }\n      if (this.aoMap && this.aoMap.isTexture) {\n        data.aoMap = this.aoMap.toJSON(meta).uuid;\n        data.aoMapIntensity = this.aoMapIntensity;\n      }\n      if (this.bumpMap && this.bumpMap.isTexture) {\n        data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n        data.bumpScale = this.bumpScale;\n      }\n      if (this.normalMap && this.normalMap.isTexture) {\n        data.normalMap = this.normalMap.toJSON(meta).uuid;\n        data.normalMapType = this.normalMapType;\n        data.normalScale = this.normalScale.toArray();\n      }\n      if (this.displacementMap && this.displacementMap.isTexture) {\n        data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n      }\n      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n      if (this.envMap && this.envMap.isTexture) {\n        data.envMap = this.envMap.toJSON(meta).uuid;\n        if (this.combine !== void 0) data.combine = this.combine;\n      }\n      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();\n      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;\n      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;\n      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;\n      if (this.gradientMap && this.gradientMap.isTexture) {\n        data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n      }\n      if (this.transmission !== void 0) data.transmission = this.transmission;\n      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n      if (this.thickness !== void 0) data.thickness = this.thickness;\n      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();\n      if (this.size !== void 0) data.size = this.size;\n      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;\n      if (this.blending !== NormalBlending) data.blending = this.blending;\n      if (this.side !== FrontSide) data.side = this.side;\n      if (this.vertexColors === true) data.vertexColors = true;\n      if (this.opacity < 1) data.opacity = this.opacity;\n      if (this.transparent === true) data.transparent = true;\n      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n      if (this.depthTest === false) data.depthTest = this.depthTest;\n      if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n      if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;\n      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;\n      if (this.polygonOffset === true) data.polygonOffset = true;\n      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n      if (this.dashSize !== void 0) data.dashSize = this.dashSize;\n      if (this.gapSize !== void 0) data.gapSize = this.gapSize;\n      if (this.scale !== void 0) data.scale = this.scale;\n      if (this.dithering === true) data.dithering = true;\n      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n      if (this.alphaHash === true) data.alphaHash = true;\n      if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n      if (this.forceSinglePass === true) data.forceSinglePass = true;\n      if (this.wireframe === true) data.wireframe = true;\n      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n      if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;\n      if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;\n      if (this.flatShading === true) data.flatShading = true;\n      if (this.visible === false) data.visible = false;\n      if (this.toneMapped === false) data.toneMapped = false;\n      if (this.fog === false) data.fog = false;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data2 = cache[key];\n          delete data2.metadata;\n          values.push(data2);\n        }\n        return values;\n      }\n      if (isRootObject) {\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.blending = source.blending;\n      this.side = source.side;\n      this.vertexColors = source.vertexColors;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n      this.blendColor.copy(source.blendColor);\n      this.blendAlpha = source.blendAlpha;\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n      this.stencilWriteMask = source.stencilWriteMask;\n      this.stencilFunc = source.stencilFunc;\n      this.stencilRef = source.stencilRef;\n      this.stencilFuncMask = source.stencilFuncMask;\n      this.stencilFail = source.stencilFail;\n      this.stencilZFail = source.stencilZFail;\n      this.stencilZPass = source.stencilZPass;\n      this.stencilWrite = source.stencilWrite;\n      const srcPlanes = source.clippingPlanes;\n      let dstPlanes = null;\n      if (srcPlanes !== null) {\n        const n = srcPlanes.length;\n        dstPlanes = new Array(n);\n        for (let i2 = 0; i2 !== n; ++i2) {\n          dstPlanes[i2] = srcPlanes[i2].clone();\n        }\n      }\n      this.clippingPlanes = dstPlanes;\n      this.clipIntersection = source.clipIntersection;\n      this.clipShadows = source.clipShadows;\n      this.shadowSide = source.shadowSide;\n      this.colorWrite = source.colorWrite;\n      this.precision = source.precision;\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n      this.dithering = source.dithering;\n      this.alphaTest = source.alphaTest;\n      this.alphaHash = source.alphaHash;\n      this.alphaToCoverage = source.alphaToCoverage;\n      this.premultipliedAlpha = source.premultipliedAlpha;\n      this.forceSinglePass = source.forceSinglePass;\n      this.visible = source.visible;\n      this.toneMapped = source.toneMapped;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    onBuild() {\n      console.warn("Material: onBuild() has been removed.");\n    }\n  }\n  class MeshBasicMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isMeshBasicMaterial = true;\n      this.type = "MeshBasicMaterial";\n      this.color = new Color(16777215);\n      this.map = null;\n      this.lightMap = null;\n      this.lightMapIntensity = 1;\n      this.aoMap = null;\n      this.aoMapIntensity = 1;\n      this.specularMap = null;\n      this.alphaMap = null;\n      this.envMap = null;\n      this.envMapRotation = new Euler();\n      this.combine = MultiplyOperation;\n      this.reflectivity = 1;\n      this.refractionRatio = 0.98;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.wireframeLinecap = "round";\n      this.wireframeLinejoin = "round";\n      this.fog = true;\n      this.setValues(parameters);\n    }\n    copy(source) {\n      super.copy(source);\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.envMapRotation.copy(source.envMapRotation);\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }\n  const _vector$9 = /* @__PURE__ */ new Vector3();\n  const _vector2$1 = /* @__PURE__ */ new Vector2();\n  class BufferAttribute {\n    constructor(array, itemSize, normalized = false) {\n      if (Array.isArray(array)) {\n        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");\n      }\n      this.isBufferAttribute = true;\n      this.name = "";\n      this.array = array;\n      this.itemSize = itemSize;\n      this.count = array !== void 0 ? array.length / itemSize : 0;\n      this.normalized = normalized;\n      this.usage = StaticDrawUsage;\n      this.updateRanges = [];\n      this.gpuType = FloatType;\n      this.version = 0;\n    }\n    onUploadCallback() {\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n    addUpdateRange(start, count) {\n      this.updateRanges.push({ start, count });\n    }\n    clearUpdateRanges() {\n      this.updateRanges.length = 0;\n    }\n    copy(source) {\n      this.name = source.name;\n      this.array = new source.array.constructor(source.array);\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n      this.usage = source.usage;\n      this.gpuType = source.gpuType;\n      return this;\n    }\n    copyAt(index1, attribute, index2) {\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n      for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {\n        this.array[index1 + i2] = attribute.array[index2 + i2];\n      }\n      return this;\n    }\n    copyArray(array) {\n      this.array.set(array);\n      return this;\n    }\n    applyMatrix3(m) {\n      if (this.itemSize === 2) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector2$1.fromBufferAttribute(this, i2);\n          _vector2$1.applyMatrix3(m);\n          this.setXY(i2, _vector2$1.x, _vector2$1.y);\n        }\n      } else if (this.itemSize === 3) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector$9.fromBufferAttribute(this, i2);\n          _vector$9.applyMatrix3(m);\n          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n        }\n      }\n      return this;\n    }\n    applyMatrix4(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyMatrix4(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    applyNormalMatrix(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyNormalMatrix(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    transformDirection(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.transformDirection(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    set(value, offset = 0) {\n      this.array.set(value, offset);\n      return this;\n    }\n    getComponent(index, component) {\n      let value = this.array[index * this.itemSize + component];\n      if (this.normalized) value = denormalize(value, this.array);\n      return value;\n    }\n    setComponent(index, component, value) {\n      if (this.normalized) value = normalize$1(value, this.array);\n      this.array[index * this.itemSize + component] = value;\n      return this;\n    }\n    getX(index) {\n      let x2 = this.array[index * this.itemSize];\n      if (this.normalized) x2 = denormalize(x2, this.array);\n      return x2;\n    }\n    setX(index, x2) {\n      if (this.normalized) x2 = normalize$1(x2, this.array);\n      this.array[index * this.itemSize] = x2;\n      return this;\n    }\n    getY(index) {\n      let y = this.array[index * this.itemSize + 1];\n      if (this.normalized) y = denormalize(y, this.array);\n      return y;\n    }\n    setY(index, y) {\n      if (this.normalized) y = normalize$1(y, this.array);\n      this.array[index * this.itemSize + 1] = y;\n      return this;\n    }\n    getZ(index) {\n      let z = this.array[index * this.itemSize + 2];\n      if (this.normalized) z = denormalize(z, this.array);\n      return z;\n    }\n    setZ(index, z) {\n      if (this.normalized) z = normalize$1(z, this.array);\n      this.array[index * this.itemSize + 2] = z;\n      return this;\n    }\n    getW(index) {\n      let w = this.array[index * this.itemSize + 3];\n      if (this.normalized) w = denormalize(w, this.array);\n      return w;\n    }\n    setW(index, w) {\n      if (this.normalized) w = normalize$1(w, this.array);\n      this.array[index * this.itemSize + 3] = w;\n      return this;\n    }\n    setXY(index, x2, y) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      return this;\n    }\n    setXYZ(index, x2, y, z) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      return this;\n    }\n    setXYZW(index, x2, y, z, w) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n        w = normalize$1(w, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      this.array[index + 3] = w;\n      return this;\n    }\n    onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n    toJSON() {\n      const data = {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: Array.from(this.array),\n        normalized: this.normalized\n      };\n      if (this.name !== "") data.name = this.name;\n      if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n      return data;\n    }\n  }\n  class Uint16BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint16Array(array), itemSize, normalized);\n    }\n  }\n  class Uint32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint32Array(array), itemSize, normalized);\n    }\n  }\n  class Float32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Float32Array(array), itemSize, normalized);\n    }\n  }\n  let _id$1 = 0;\n  const _m1 = /* @__PURE__ */ new Matrix4();\n  const _obj = /* @__PURE__ */ new Object3D();\n  const _offset = /* @__PURE__ */ new Vector3();\n  const _box$2 = /* @__PURE__ */ new Box3();\n  const _boxMorphTargets = /* @__PURE__ */ new Box3();\n  const _vector$8 = /* @__PURE__ */ new Vector3();\n  class BufferGeometry extends EventDispatcher {\n    constructor() {\n      super();\n      this.isBufferGeometry = true;\n      Object.defineProperty(this, "id", { value: _id$1++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "BufferGeometry";\n      this.index = null;\n      this.indirect = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.morphTargetsRelative = false;\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.drawRange = { start: 0, count: Infinity };\n      this.userData = {};\n    }\n    getIndex() {\n      return this.index;\n    }\n    setIndex(index) {\n      if (Array.isArray(index)) {\n        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n      } else {\n        this.index = index;\n      }\n      return this;\n    }\n    setIndirect(indirect) {\n      this.indirect = indirect;\n      return this;\n    }\n    getIndirect() {\n      return this.indirect;\n    }\n    getAttribute(name) {\n      return this.attributes[name];\n    }\n    setAttribute(name, attribute) {\n      this.attributes[name] = attribute;\n      return this;\n    }\n    deleteAttribute(name) {\n      delete this.attributes[name];\n      return this;\n    }\n    hasAttribute(name) {\n      return this.attributes[name] !== void 0;\n    }\n    addGroup(start, count, materialIndex = 0) {\n      this.groups.push({\n        start,\n        count,\n        materialIndex\n      });\n    }\n    clearGroups() {\n      this.groups = [];\n    }\n    setDrawRange(start, count) {\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n    }\n    applyMatrix4(matrix) {\n      const position = this.attributes.position;\n      if (position !== void 0) {\n        position.applyMatrix4(matrix);\n        position.needsUpdate = true;\n      }\n      const normal = this.attributes.normal;\n      if (normal !== void 0) {\n        const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n        normal.applyNormalMatrix(normalMatrix);\n        normal.needsUpdate = true;\n      }\n      const tangent = this.attributes.tangent;\n      if (tangent !== void 0) {\n        tangent.transformDirection(matrix);\n        tangent.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n    applyQuaternion(q) {\n      _m1.makeRotationFromQuaternion(q);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    translate(x2, y, z) {\n      _m1.makeTranslation(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    scale(x2, y, z) {\n      _m1.makeScale(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n    center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n    setFromPoints(points) {\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute === void 0) {\n        const position = [];\n        for (let i2 = 0, l = points.length; i2 < l; i2++) {\n          const point = points[i2];\n          position.push(point.x, point.y, point.z || 0);\n        }\n        this.setAttribute("position", new Float32BufferAttribute(position, 3));\n      } else {\n        const l = Math.min(points.length, positionAttribute.count);\n        for (let i2 = 0; i2 < l; i2++) {\n          const point = points[i2];\n          positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);\n        }\n        if (points.length > positionAttribute.count) {\n          console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");\n        }\n        positionAttribute.needsUpdate = true;\n      }\n      return this;\n    }\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);\n        this.boundingBox.set(\n          new Vector3(-Infinity, -Infinity, -Infinity),\n          new Vector3(Infinity, Infinity, Infinity)\n        );\n        return;\n      }\n      if (position !== void 0) {\n        this.boundingBox.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _box$2.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n              this.boundingBox.expandByPoint(_vector$8);\n              _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n              this.boundingBox.expandByPoint(_vector$8);\n            } else {\n              this.boundingBox.expandByPoint(_box$2.min);\n              this.boundingBox.expandByPoint(_box$2.max);\n            }\n          }\n        }\n      } else {\n        this.boundingBox.makeEmpty();\n      }\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\', this);\n      }\n    }\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);\n        this.boundingSphere.set(new Vector3(), Infinity);\n        return;\n      }\n      if (position) {\n        const center = this.boundingSphere.center;\n        _box$2.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n              _box$2.expandByPoint(_vector$8);\n              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n              _box$2.expandByPoint(_vector$8);\n            } else {\n              _box$2.expandByPoint(_boxMorphTargets.min);\n              _box$2.expandByPoint(_boxMorphTargets.max);\n            }\n          }\n        }\n        _box$2.getCenter(center);\n        let maxRadiusSq = 0;\n        for (let i2 = 0, il = position.count; i2 < il; i2++) {\n          _vector$8.fromBufferAttribute(position, i2);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n        }\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            const morphTargetsRelative = this.morphTargetsRelative;\n            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n              _vector$8.fromBufferAttribute(morphAttribute, j);\n              if (morphTargetsRelative) {\n                _offset.fromBufferAttribute(position, j);\n                _vector$8.add(_offset);\n              }\n              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n            }\n          }\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\', this);\n        }\n      }\n    }\n    computeTangents() {\n      const index = this.index;\n      const attributes = this.attributes;\n      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");\n        return;\n      }\n      const positionAttribute = attributes.position;\n      const normalAttribute = attributes.normal;\n      const uvAttribute = attributes.uv;\n      if (this.hasAttribute("tangent") === false) {\n        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n      }\n      const tangentAttribute = this.getAttribute("tangent");\n      const tan1 = [], tan2 = [];\n      for (let i2 = 0; i2 < positionAttribute.count; i2++) {\n        tan1[i2] = new Vector3();\n        tan2[i2] = new Vector3();\n      }\n      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n      function handleTriangle(a, b, c) {\n        vA.fromBufferAttribute(positionAttribute, a);\n        vB.fromBufferAttribute(positionAttribute, b);\n        vC.fromBufferAttribute(positionAttribute, c);\n        uvA.fromBufferAttribute(uvAttribute, a);\n        uvB.fromBufferAttribute(uvAttribute, b);\n        uvC.fromBufferAttribute(uvAttribute, c);\n        vB.sub(vA);\n        vC.sub(vA);\n        uvB.sub(uvA);\n        uvC.sub(uvA);\n        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n        if (!isFinite(r)) return;\n        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n        tan1[a].add(sdir);\n        tan1[b].add(sdir);\n        tan1[c].add(sdir);\n        tan2[a].add(tdir);\n        tan2[b].add(tdir);\n        tan2[c].add(tdir);\n      }\n      let groups = this.groups;\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: index.count\n        }];\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleTriangle(\n            index.getX(j + 0),\n            index.getX(j + 1),\n            index.getX(j + 2)\n          );\n        }\n      }\n      const tmp = new Vector3(), tmp2 = new Vector3();\n      const n = new Vector3(), n2 = new Vector3();\n      function handleVertex(v) {\n        n.fromBufferAttribute(normalAttribute, v);\n        n2.copy(n);\n        const t = tan1[v];\n        tmp.copy(t);\n        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n        tmp2.crossVectors(n2, t);\n        const test = tmp2.dot(tan2[v]);\n        const w = test < 0 ? -1 : 1;\n        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleVertex(index.getX(j + 0));\n          handleVertex(index.getX(j + 1));\n          handleVertex(index.getX(j + 2));\n        }\n      }\n    }\n    computeVertexNormals() {\n      const index = this.index;\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute !== void 0) {\n        let normalAttribute = this.getAttribute("normal");\n        if (normalAttribute === void 0) {\n          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n          this.setAttribute("normal", normalAttribute);\n        } else {\n          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {\n            normalAttribute.setXYZ(i2, 0, 0, 0);\n          }\n        }\n        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n        const cb = new Vector3(), ab = new Vector3();\n        if (index) {\n          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {\n            const vA = index.getX(i2 + 0);\n            const vB = index.getX(i2 + 1);\n            const vC = index.getX(i2 + 2);\n            pA.fromBufferAttribute(positionAttribute, vA);\n            pB.fromBufferAttribute(positionAttribute, vB);\n            pC.fromBufferAttribute(positionAttribute, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            nA.fromBufferAttribute(normalAttribute, vA);\n            nB.fromBufferAttribute(normalAttribute, vB);\n            nC.fromBufferAttribute(normalAttribute, vC);\n            nA.add(cb);\n            nB.add(cb);\n            nC.add(cb);\n            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n          }\n        } else {\n          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {\n            pA.fromBufferAttribute(positionAttribute, i2 + 0);\n            pB.fromBufferAttribute(positionAttribute, i2 + 1);\n            pC.fromBufferAttribute(positionAttribute, i2 + 2);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);\n          }\n        }\n        this.normalizeNormals();\n        normalAttribute.needsUpdate = true;\n      }\n    }\n    normalizeNormals() {\n      const normals = this.attributes.normal;\n      for (let i2 = 0, il = normals.count; i2 < il; i2++) {\n        _vector$8.fromBufferAttribute(normals, i2);\n        _vector$8.normalize();\n        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);\n      }\n    }\n    toNonIndexed() {\n      function convertBufferAttribute(attribute, indices2) {\n        const array = attribute.array;\n        const itemSize = attribute.itemSize;\n        const normalized = attribute.normalized;\n        const array2 = new array.constructor(indices2.length * itemSize);\n        let index = 0, index2 = 0;\n        for (let i2 = 0, l = indices2.length; i2 < l; i2++) {\n          if (attribute.isInterleavedBufferAttribute) {\n            index = indices2[i2] * attribute.data.stride + attribute.offset;\n          } else {\n            index = indices2[i2] * itemSize;\n          }\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new BufferAttribute(array2, itemSize, normalized);\n      }\n      if (this.index === null) {\n        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");\n        return this;\n      }\n      const geometry2 = new BufferGeometry();\n      const indices = this.index.array;\n      const attributes = this.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        geometry2.setAttribute(name, newAttribute);\n      }\n      const morphAttributes = this.morphAttributes;\n      for (const name in morphAttributes) {\n        const morphArray = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {\n          const attribute = morphAttribute[i2];\n          const newAttribute = convertBufferAttribute(attribute, indices);\n          morphArray.push(newAttribute);\n        }\n        geometry2.morphAttributes[name] = morphArray;\n      }\n      geometry2.morphTargetsRelative = this.morphTargetsRelative;\n      const groups = this.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        geometry2.addGroup(group.start, group.count, group.materialIndex);\n      }\n      return geometry2;\n    }\n    toJSON() {\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: "BufferGeometry",\n          generator: "BufferGeometry.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      if (this.parameters !== void 0) {\n        const parameters = this.parameters;\n        for (const key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      data.data = { attributes: {} };\n      const index = this.index;\n      if (index !== null) {\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: Array.prototype.slice.call(index.array)\n        };\n      }\n      const attributes = this.attributes;\n      for (const key in attributes) {\n        const attribute = attributes[key];\n        data.data.attributes[key] = attribute.toJSON(data.data);\n      }\n      const morphAttributes = {};\n      let hasMorphAttributes = false;\n      for (const key in this.morphAttributes) {\n        const attributeArray = this.morphAttributes[key];\n        const array = [];\n        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {\n          const attribute = attributeArray[i2];\n          array.push(attribute.toJSON(data.data));\n        }\n        if (array.length > 0) {\n          morphAttributes[key] = array;\n          hasMorphAttributes = true;\n        }\n      }\n      if (hasMorphAttributes) {\n        data.data.morphAttributes = morphAttributes;\n        data.data.morphTargetsRelative = this.morphTargetsRelative;\n      }\n      const groups = this.groups;\n      if (groups.length > 0) {\n        data.data.groups = JSON.parse(JSON.stringify(groups));\n      }\n      const boundingSphere = this.boundingSphere;\n      if (boundingSphere !== null) {\n        data.data.boundingSphere = {\n          center: boundingSphere.center.toArray(),\n          radius: boundingSphere.radius\n        };\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      const data = {};\n      this.name = source.name;\n      const index = source.index;\n      if (index !== null) {\n        this.setIndex(index.clone(data));\n      }\n      const attributes = source.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        this.setAttribute(name, attribute.clone(data));\n      }\n      const morphAttributes = source.morphAttributes;\n      for (const name in morphAttributes) {\n        const array = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {\n          array.push(morphAttribute[i2].clone(data));\n        }\n        this.morphAttributes[name] = array;\n      }\n      this.morphTargetsRelative = source.morphTargetsRelative;\n      const groups = source.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        this.addGroup(group.start, group.count, group.materialIndex);\n      }\n      const boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      const boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count;\n      this.userData = source.userData;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\n  const _ray$3 = /* @__PURE__ */ new Ray();\n  const _sphere$6 = /* @__PURE__ */ new Sphere();\n  const _sphereHitAt = /* @__PURE__ */ new Vector3();\n  const _vA$1 = /* @__PURE__ */ new Vector3();\n  const _vB$1 = /* @__PURE__ */ new Vector3();\n  const _vC$1 = /* @__PURE__ */ new Vector3();\n  const _tempA = /* @__PURE__ */ new Vector3();\n  const _morphA = /* @__PURE__ */ new Vector3();\n  const _intersectionPoint = /* @__PURE__ */ new Vector3();\n  const _intersectionPointWorld = /* @__PURE__ */ new Vector3();\n  class Mesh extends Object3D {\n    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n      super();\n      this.isMesh = true;\n      this.type = "Mesh";\n      this.geometry = geometry;\n      this.material = material;\n      this.updateMorphTargets();\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.morphTargetInfluences !== void 0) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n      if (source.morphTargetDictionary !== void 0) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n    updateMorphTargets() {\n      const geometry = this.geometry;\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n    getVertexPosition(index, target) {\n      const geometry = this.geometry;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      target.fromBufferAttribute(position, index);\n      const morphInfluences = this.morphTargetInfluences;\n      if (morphPosition && morphInfluences) {\n        _morphA.set(0, 0, 0);\n        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {\n          const influence = morphInfluences[i2];\n          const morphAttribute = morphPosition[i2];\n          if (influence === 0) continue;\n          _tempA.fromBufferAttribute(morphAttribute, index);\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(target), influence);\n          }\n        }\n        target.add(_morphA);\n      }\n      return target;\n    }\n    raycast(raycaster, intersects) {\n      const geometry = this.geometry;\n      const material = this.material;\n      const matrixWorld = this.matrixWorld;\n      if (material === void 0) return;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$6.copy(geometry.boundingSphere);\n      _sphere$6.applyMatrix4(matrixWorld);\n      _ray$3.copy(raycaster.ray).recast(raycaster.near);\n      if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n      }\n      _inverseMatrix$3.copy(matrixWorld).invert();\n      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n      if (geometry.boundingBox !== null) {\n        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n      }\n      this._computeIntersections(raycaster, intersects, _ray$3);\n    }\n    _computeIntersections(raycaster, intersects, rayLocalSpace) {\n      let intersection;\n      const geometry = this.geometry;\n      const material = this.material;\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const uv = geometry.attributes.uv;\n      const uv1 = geometry.attributes.uv1;\n      const normal = geometry.attributes.normal;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n      if (index !== null) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = index.getX(i2);\n            const b = index.getX(i2 + 1);\n            const c = index.getX(i2 + 2);\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== void 0) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = i2;\n            const b = i2 + 1;\n            const c = i2 + 2;\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    }\n  }\n  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n    let intersect;\n    if (material.side === BackSide) {\n      intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n    }\n    if (intersect === null) return null;\n    _intersectionPointWorld.copy(point);\n    _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n    if (distance < raycaster.near || distance > raycaster.far) return null;\n    return {\n      distance,\n      point: _intersectionPointWorld.clone(),\n      object\n    };\n  }\n  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n    object.getVertexPosition(a, _vA$1);\n    object.getVertexPosition(b, _vB$1);\n    object.getVertexPosition(c, _vC$1);\n    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n    if (intersection) {\n      const barycoord = new Vector3();\n      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n      if (uv) {\n        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n      }\n      if (uv1) {\n        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n      }\n      if (normal) {\n        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n        if (intersection.normal.dot(ray.direction) > 0) {\n          intersection.normal.multiplyScalar(-1);\n        }\n      }\n      const face = {\n        a,\n        b,\n        c,\n        normal: new Vector3(),\n        materialIndex: 0\n      };\n      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n      intersection.face = face;\n      intersection.barycoord = barycoord;\n    }\n    return intersection;\n  }\n  function cloneUniforms(src) {\n    const dst = {};\n    for (const u in src) {\n      dst[u] = {};\n      for (const p in src[u]) {\n        const property = src[u][p];\n        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n          if (property.isRenderTargetTexture) {\n            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");\n            dst[u][p] = null;\n          } else {\n            dst[u][p] = property.clone();\n          }\n        } else if (Array.isArray(property)) {\n          dst[u][p] = property.slice();\n        } else {\n          dst[u][p] = property;\n        }\n      }\n    }\n    return dst;\n  }\n  function cloneUniformsGroups(src) {\n    const dst = [];\n    for (let u = 0; u < src.length; u++) {\n      dst.push(src[u].clone());\n    }\n    return dst;\n  }\n  var default_vertex = "void main() {\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}";\n  var default_fragment = "void main() {\\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}";\n  class ShaderMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isShaderMaterial = true;\n      this.type = "ShaderMaterial";\n      this.defines = {};\n      this.uniforms = {};\n      this.uniformsGroups = [];\n      this.vertexShader = default_vertex;\n      this.fragmentShader = default_fragment;\n      this.linewidth = 1;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.fog = false;\n      this.lights = false;\n      this.clipping = false;\n      this.forceSinglePass = true;\n      this.extensions = {\n        clipCullDistance: false,\n        // set to use vertex shader clipping\n        multiDraw: false\n        // set to use vertex shader multi_draw / enable gl_DrawID\n      };\n      this.defaultAttributeValues = {\n        "color": [1, 1, 1],\n        "uv": [0, 0],\n        "uv1": [0, 0]\n      };\n      this.index0AttributeName = void 0;\n      this.uniformsNeedUpdate = false;\n      this.glslVersion = null;\n      if (parameters !== void 0) {\n        this.setValues(parameters);\n      }\n    }\n    copy(source) {\n      super.copy(source);\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.fog = source.fog;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n      for (const name in this.uniforms) {\n        const uniform = this.uniforms[name];\n        const value = uniform.value;\n        if (value && value.isTexture) {\n          data.uniforms[name] = {\n            type: "t",\n            value: value.toJSON(meta).uuid\n          };\n        } else if (value && value.isColor) {\n          data.uniforms[name] = {\n            type: "c",\n            value: value.getHex()\n          };\n        } else if (value && value.isVector2) {\n          data.uniforms[name] = {\n            type: "v2",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector3) {\n          data.uniforms[name] = {\n            type: "v3",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector4) {\n          data.uniforms[name] = {\n            type: "v4",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix3) {\n          data.uniforms[name] = {\n            type: "m3",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix4) {\n          data.uniforms[name] = {\n            type: "m4",\n            value: value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value\n          };\n        }\n      }\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      data.lights = this.lights;\n      data.clipping = this.clipping;\n      const extensions = {};\n      for (const key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }\n  class Camera extends Object3D {\n    constructor() {\n      super();\n      this.isCamera = true;\n      this.type = "Camera";\n      this.matrixWorldInverse = new Matrix4();\n      this.projectionMatrix = new Matrix4();\n      this.projectionMatrixInverse = new Matrix4();\n      this.coordinateSystem = WebGLCoordinateSystem;\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      this.matrixWorldInverse.copy(source.matrixWorldInverse);\n      this.projectionMatrix.copy(source.projectionMatrix);\n      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n      this.coordinateSystem = source.coordinateSystem;\n      return this;\n    }\n    getWorldDirection(target) {\n      return super.getWorldDirection(target).negate();\n    }\n    updateMatrixWorld(force) {\n      super.updateMatrixWorld(force);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      super.updateWorldMatrix(updateParents, updateChildren);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Scene extends Object3D {\n    constructor() {\n      super();\n      this.isScene = true;\n      this.type = "Scene";\n      this.background = null;\n      this.environment = null;\n      this.fog = null;\n      this.backgroundBlurriness = 0;\n      this.backgroundIntensity = 1;\n      this.backgroundRotation = new Euler();\n      this.environmentIntensity = 1;\n      this.environmentRotation = new Euler();\n      this.overrideMaterial = null;\n      if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));\n      }\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.background !== null) this.background = source.background.clone();\n      if (source.environment !== null) this.environment = source.environment.clone();\n      if (source.fog !== null) this.fog = source.fog.clone();\n      this.backgroundBlurriness = source.backgroundBlurriness;\n      this.backgroundIntensity = source.backgroundIntensity;\n      this.backgroundRotation.copy(source.backgroundRotation);\n      this.environmentIntensity = source.environmentIntensity;\n      this.environmentRotation.copy(source.environmentRotation);\n      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      if (this.fog !== null) data.object.fog = this.fog.toJSON();\n      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;\n      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;\n      data.object.backgroundRotation = this.backgroundRotation.toArray();\n      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;\n      data.object.environmentRotation = this.environmentRotation.toArray();\n      return data;\n    }\n  }\n  class DataTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n      this.isDataTexture = true;\n      this.image = { data, width, height };\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n    }\n  }\n  class PlaneGeometry extends BufferGeometry {\n    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n      super();\n      this.type = "PlaneGeometry";\n      this.parameters = {\n        width,\n        height,\n        widthSegments,\n        heightSegments\n      };\n      const width_half = width / 2;\n      const height_half = height / 2;\n      const gridX = Math.floor(widthSegments);\n      const gridY = Math.floor(heightSegments);\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      const segment_width = width / gridX;\n      const segment_height = height / gridY;\n      const indices = [];\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segment_height - height_half;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x2 = ix * segment_width - width_half;\n          vertices.push(x2, -y, 0);\n          normals.push(0, 0, 1);\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n        }\n      }\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = ix + gridX1 * iy;\n          const b = ix + gridX1 * (iy + 1);\n          const c = ix + 1 + gridX1 * (iy + 1);\n          const d = ix + 1 + gridX1 * iy;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n      this.setIndex(indices);\n      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));\n      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));\n      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));\n    }\n    copy(source) {\n      super.copy(source);\n      this.parameters = Object.assign({}, source.parameters);\n      return this;\n    }\n    static fromJSON(data) {\n      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n    }\n  }\n  class RawShaderMaterial extends ShaderMaterial {\n    constructor(parameters) {\n      super(parameters);\n      this.isRawShaderMaterial = true;\n      this.type = "RawShaderMaterial";\n    }\n  }\n  const Cache = {\n    enabled: false,\n    files: {},\n    add: function(key, file) {\n      if (this.enabled === false) return;\n      this.files[key] = file;\n    },\n    get: function(key) {\n      if (this.enabled === false) return;\n      return this.files[key];\n    },\n    remove: function(key) {\n      delete this.files[key];\n    },\n    clear: function() {\n      this.files = {};\n    }\n  };\n  class LoadingManager {\n    constructor(onLoad, onProgress, onError) {\n      const scope = this;\n      let isLoading = false;\n      let itemsLoaded = 0;\n      let itemsTotal = 0;\n      let urlModifier = void 0;\n      const handlers = [];\n      this.onStart = void 0;\n      this.onLoad = onLoad;\n      this.onProgress = onProgress;\n      this.onError = onError;\n      this.itemStart = function(url) {\n        itemsTotal++;\n        if (isLoading === false) {\n          if (scope.onStart !== void 0) {\n            scope.onStart(url, itemsLoaded, itemsTotal);\n          }\n        }\n        isLoading = true;\n      };\n      this.itemEnd = function(url) {\n        itemsLoaded++;\n        if (scope.onProgress !== void 0) {\n          scope.onProgress(url, itemsLoaded, itemsTotal);\n        }\n        if (itemsLoaded === itemsTotal) {\n          isLoading = false;\n          if (scope.onLoad !== void 0) {\n            scope.onLoad();\n          }\n        }\n      };\n      this.itemError = function(url) {\n        if (scope.onError !== void 0) {\n          scope.onError(url);\n        }\n      };\n      this.resolveURL = function(url) {\n        if (urlModifier) {\n          return urlModifier(url);\n        }\n        return url;\n      };\n      this.setURLModifier = function(transform) {\n        urlModifier = transform;\n        return this;\n      };\n      this.addHandler = function(regex, loader) {\n        handlers.push(regex, loader);\n        return this;\n      };\n      this.removeHandler = function(regex) {\n        const index = handlers.indexOf(regex);\n        if (index !== -1) {\n          handlers.splice(index, 2);\n        }\n        return this;\n      };\n      this.getHandler = function(file) {\n        for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {\n          const regex = handlers[i2];\n          const loader = handlers[i2 + 1];\n          if (regex.global) regex.lastIndex = 0;\n          if (regex.test(file)) {\n            return loader;\n          }\n        }\n        return null;\n      };\n    }\n  }\n  const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();\n  class Loader {\n    constructor(manager) {\n      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;\n      this.crossOrigin = "anonymous";\n      this.withCredentials = false;\n      this.path = "";\n      this.resourcePath = "";\n      this.requestHeader = {};\n    }\n    load() {\n    }\n    loadAsync(url, onProgress) {\n      const scope = this;\n      return new Promise(function(resolve, reject) {\n        scope.load(url, resolve, onProgress, reject);\n      });\n    }\n    parse() {\n    }\n    setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    setWithCredentials(value) {\n      this.withCredentials = value;\n      return this;\n    }\n    setPath(path) {\n      this.path = path;\n      return this;\n    }\n    setResourcePath(resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    }\n    setRequestHeader(requestHeader) {\n      this.requestHeader = requestHeader;\n      return this;\n    }\n  }\n  Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";\n  const loading = {};\n  class HttpError extends Error {\n    constructor(message, response) {\n      super(message);\n      this.response = response;\n    }\n  }\n  class FileLoader extends Loader {\n    constructor(manager) {\n      super(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      if (url === void 0) url = "";\n      if (this.path !== void 0) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      const cached = Cache.get(url);\n      if (cached !== void 0) {\n        this.manager.itemStart(url);\n        setTimeout(() => {\n          if (onLoad) onLoad(cached);\n          this.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      }\n      if (loading[url] !== void 0) {\n        loading[url].push({\n          onLoad,\n          onProgress,\n          onError\n        });\n        return;\n      }\n      loading[url] = [];\n      loading[url].push({\n        onLoad,\n        onProgress,\n        onError\n      });\n      const req = new Request(url, {\n        headers: new Headers(this.requestHeader),\n        credentials: this.withCredentials ? "include" : "same-origin"\n        // An abort controller could be added within a future PR\n      });\n      const mimeType = this.mimeType;\n      const responseType = this.responseType;\n      fetch(req).then((response) => {\n        if (response.status === 200 || response.status === 0) {\n          if (response.status === 0) {\n            console.warn("THREE.FileLoader: HTTP Status 0 received.");\n          }\n          if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {\n            return response;\n          }\n          const callbacks = loading[url];\n          const reader = response.body.getReader();\n          const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");\n          const total = contentLength ? parseInt(contentLength) : 0;\n          const lengthComputable = total !== 0;\n          let loaded = 0;\n          const stream = new ReadableStream({\n            start(controller) {\n              readData();\n              function readData() {\n                reader.read().then(({ done, value }) => {\n                  if (done) {\n                    controller.close();\n                  } else {\n                    loaded += value.byteLength;\n                    const event = new ProgressEvent("progress", { lengthComputable, loaded, total });\n                    for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n                      const callback = callbacks[i2];\n                      if (callback.onProgress) callback.onProgress(event);\n                    }\n                    controller.enqueue(value);\n                    readData();\n                  }\n                }, (e) => {\n                  controller.error(e);\n                });\n              }\n            }\n          });\n          return new Response(stream);\n        } else {\n          throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);\n        }\n      }).then((response) => {\n        switch (responseType) {\n          case "arraybuffer":\n            return response.arrayBuffer();\n          case "blob":\n            return response.blob();\n          case "document":\n            return response.text().then((text) => {\n              const parser = new DOMParser();\n              return parser.parseFromString(text, mimeType);\n            });\n          case "json":\n            return response.json();\n          default:\n            if (mimeType === void 0) {\n              return response.text();\n            } else {\n              const re = /charset="?([^;"\\s]*)"?/i;\n              const exec = re.exec(mimeType);\n              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;\n              const decoder = new TextDecoder(label);\n              return response.arrayBuffer().then((ab) => decoder.decode(ab));\n            }\n        }\n      }).then((data) => {\n        Cache.add(url, data);\n        const callbacks = loading[url];\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onLoad) callback.onLoad(data);\n        }\n      }).catch((err2) => {\n        const callbacks = loading[url];\n        if (callbacks === void 0) {\n          this.manager.itemError(url);\n          throw err2;\n        }\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onError) callback.onError(err2);\n        }\n        this.manager.itemError(url);\n      }).finally(() => {\n        this.manager.itemEnd(url);\n      });\n      this.manager.itemStart(url);\n    }\n    setResponseType(value) {\n      this.responseType = value;\n      return this;\n    }\n    setMimeType(value) {\n      this.mimeType = value;\n      return this;\n    }\n  }\n  class Matrix2 {\n    constructor(n11, n12, n21, n22) {\n      Matrix2.prototype.isMatrix2 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n21, n22);\n      }\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 4; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    set(n11, n12, n21, n22) {\n      const te = this.elements;\n      te[0] = n11;\n      te[2] = n12;\n      te[1] = n21;\n      te[3] = n22;\n      return this;\n    }\n  }\n  if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== "undefined") {\n    if (window.__THREE__) {\n      console.warn("WARNING: Multiple instances of Three.js being imported.");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -9;\n  const LN_SCALE_MAX = 9;\n  const LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254;\n  const SCALE_MIN = Math.exp(LN_SCALE_MIN);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  const WASM_SPLAT_SORT = true;\n  function isIntType(type) {\n    return type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4";\n  }\n  function isUintType(type) {\n    return type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4";\n  }\n  function isFloatType(type) {\n    return type === "float" || type === "vec2" || type === "vec3" || type === "vec4";\n  }\n  function isMatFloatType(type) {\n    return type === "mat2" || type === "mat2x2" || type === "mat2x3" || type === "mat2x4" || type === "mat3" || type === "mat3x2" || type === "mat3x3" || type === "mat3x4" || type === "mat4" || type === "mat4x2" || type === "mat4x3" || type === "mat4x4";\n  }\n  function isAllFloatType(type) {\n    return isFloatType(type) || isMatFloatType(type);\n  }\n  function isMat2(type) {\n    return type === "mat2" || type === "mat2x2";\n  }\n  function isMat3(type) {\n    return type === "mat3" || type === "mat3x3";\n  }\n  function isMat4(type) {\n    return type === "mat4" || type === "mat4x4";\n  }\n  function numberAsInt(value) {\n    return Math.trunc(value).toString();\n  }\n  function numberAsUint(value) {\n    const v = Math.max(0, Math.trunc(value));\n    return `${v.toString()}u`;\n  }\n  function numberAsFloat(value) {\n    return value === Number.POSITIVE_INFINITY ? "INFINITY" : value === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(value) ? value.toFixed(1) : value.toString();\n  }\n  function valType(val) {\n    if (val instanceof DynoValue) {\n      return val.type;\n    }\n    const value = val.dynoOut();\n    return value.type;\n  }\n  class DynoValue {\n    constructor(type) {\n      this.__isDynoValue = true;\n      this.type = type;\n    }\n  }\n  class DynoOutput extends DynoValue {\n    constructor(dyno2, key) {\n      super(dyno2.outTypes[key]);\n      this.dyno = dyno2;\n      this.key = key;\n    }\n  }\n  class DynoLiteral extends DynoValue {\n    constructor(type, literal) {\n      super(type);\n      this.literal = literal;\n    }\n    getLiteral() {\n      return this.literal;\n    }\n  }\n  class DynoConst extends DynoLiteral {\n    constructor(type, value) {\n      super(type, "");\n      this.value = value;\n    }\n    getLiteral() {\n      const { type, value } = this;\n      switch (type) {\n        case "bool":\n          return value ? "true" : "false";\n        case "uint":\n          return numberAsUint(value);\n        case "int":\n          return numberAsInt(value);\n        case "float":\n          return numberAsFloat(value);\n        case "bvec2": {\n          const v = value;\n          return `bvec2(${v[0]}, ${v[1]})`;\n        }\n        case "uvec2": {\n          if (value instanceof Vector2) {\n            return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\n          }\n          const v = value;\n          return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;\n        }\n        case "ivec2": {\n          if (value instanceof Vector2) {\n            return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;\n          }\n          const v = value;\n          return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\n        }\n        case "vec2": {\n          if (value instanceof Vector2) {\n            return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\n          }\n          const v = value;\n          return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;\n        }\n        case "bvec3": {\n          const v = value;\n          return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\n        }\n        case "uvec3": {\n          if (value instanceof Vector3) {\n            return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;\n          }\n          const v = value;\n          return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;\n        }\n        case "ivec3": {\n          if (value instanceof Vector3) {\n            return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\n          }\n          const v = value;\n          return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;\n        }\n        case "vec3": {\n          if (value instanceof Vector3) {\n            return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;\n          }\n          const v = value;\n          return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;\n        }\n        case "bvec4": {\n          const v = value;\n          return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\n        }\n        case "uvec4": {\n          if (value instanceof Vector4) {\n            return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\n          }\n          const v = value;\n          return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\n        }\n        case "ivec4": {\n          if (value instanceof Vector4) {\n            return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\n          }\n          const v = value;\n          return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\n        }\n        case "vec4": {\n          if (value instanceof Vector4) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          if (value instanceof Quaternion) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          const v = value;\n          return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\n        }\n        case "mat2":\n        case "mat2x2": {\n          const m = value;\n          const e = m instanceof Matrix2 ? m.elements : value;\n          const arg = new Array(4).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x3": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x4": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3":\n        case "mat3x3": {\n          const m = value;\n          const e = m instanceof Matrix3 ? m.elements : value;\n          const arg = new Array(9).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x2": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x4": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4":\n        case "mat4x4": {\n          const m = value;\n          const e = m instanceof Matrix4 ? m.elements : value;\n          const arg = new Array(16).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x2": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x3": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        default:\n          throw new Error(`Type not implemented: ${String(type)}`);\n      }\n    }\n  }\n  function dynoConst(type, value) {\n    return new DynoConst(type, value);\n  }\n  const DEFAULT_INDENT = "    ";\n  class Compilation {\n    constructor({ indent } = {}) {\n      this.globals = /* @__PURE__ */ new Set();\n      this.statements = [];\n      this.uniforms = {};\n      this.declares = /* @__PURE__ */ new Set();\n      this.updaters = [];\n      this.sequence = 0;\n      this.indent = DEFAULT_INDENT;\n      this.indent = indent ?? DEFAULT_INDENT;\n    }\n    nextSequence() {\n      return this.sequence++;\n    }\n  }\n  class Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    }) {\n      this.inTypes = inTypes ?? {};\n      this.outTypes = outTypes ?? {};\n      this.inputs = inputs ?? {};\n      this.update = update;\n      this.globals = globals;\n      this.statements = statements;\n      this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {\n        var _a2, _b2;\n        return {\n          globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),\n          statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n        };\n      });\n    }\n    get outputs() {\n      const outputs = {};\n      for (const key in this.outTypes) {\n        outputs[key] = new DynoOutput(this, key);\n      }\n      return outputs;\n    }\n    apply(inputs) {\n      Object.assign(this.inputs, inputs);\n      return this.outputs;\n    }\n    compile({\n      inputs,\n      outputs,\n      compile\n    }) {\n      const result = [\n        `// ${this.constructor.name}(${Object.values(inputs).join(", ")}) => (${Object.values(outputs).join(", ")})`\n      ];\n      const declares = [];\n      for (const key in outputs) {\n        const name = outputs[key];\n        if (name && !compile.declares.has(name)) {\n          compile.declares.add(name);\n          declares.push(key);\n        }\n      }\n      const { globals, statements, uniforms } = this.generate({\n        inputs,\n        outputs,\n        compile\n      });\n      for (const global2 of globals ?? []) {\n        compile.globals.add(global2);\n      }\n      for (const key in uniforms) {\n        compile.uniforms[key] = uniforms[key];\n      }\n      if (this.update) {\n        compile.updaters.push(this.update);\n      }\n      for (const key of declares) {\n        const name = outputs[key];\n        if (name) {\n          if (!compile.uniforms[name]) {\n            result.push(`${dynoDeclare(name, this.outTypes[key])};`);\n          }\n        }\n      }\n      if (statements == null ? void 0 : statements.length) {\n        result.push("{");\n        result.push(...statements.map((line) => compile.indent + line));\n        result.push("}");\n      }\n      return result;\n    }\n  }\n  class DynoBlock extends Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      construct\n    }) {\n      super({\n        inTypes,\n        outTypes,\n        inputs,\n        update,\n        globals,\n        generate: (args) => this.generateBlock(args)\n      });\n      this.construct = construct;\n    }\n    generateBlock({\n      inputs,\n      outputs,\n      compile\n    }) {\n      var _a2, _b2;\n      const blockInputs = {};\n      const blockOutputs = {};\n      for (const key in inputs) {\n        if (inputs[key] != null) {\n          blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n        }\n      }\n      for (const key in outputs) {\n        if (outputs[key] != null) {\n          blockOutputs[key] = new DynoValue(this.outTypes[key]);\n        }\n      }\n      const options = { roots: [] };\n      const returned = this.construct(blockInputs, blockOutputs, options);\n      for (const global2 of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {\n        compile.globals.add(global2);\n      }\n      const ordering = [];\n      const nodeOuts = /* @__PURE__ */ new Map();\n      function visit(node, outKey, outName) {\n        let outs = nodeOuts.get(node);\n        if (!outs) {\n          outs = {\n            sequence: compile.nextSequence(),\n            outNames: /* @__PURE__ */ new Map(),\n            newOuts: /* @__PURE__ */ new Set()\n          };\n          nodeOuts.set(node, outs);\n          for (const key in node.inputs) {\n            let input = node.inputs[key];\n            while (input) {\n              if (input instanceof DynoValue) {\n                if (input instanceof DynoOutput) {\n                  visit(input.dyno, input.key);\n                }\n                break;\n              }\n              input = input.dynoOut();\n            }\n          }\n          ordering.push(node);\n        }\n        if (outKey) {\n          if (!outName) {\n            outs.newOuts.add(outKey);\n          }\n          outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\n        }\n      }\n      for (const root of options.roots) {\n        visit(root);\n      }\n      for (const key in blockOutputs) {\n        let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];\n        while (value) {\n          if (value instanceof DynoValue) {\n            if (value instanceof DynoOutput) {\n              visit(value.dyno, value.key, outputs[key]);\n            }\n            break;\n          }\n          value = value.dynoOut();\n        }\n        blockOutputs[key] = value;\n      }\n      const steps = [];\n      for (const dyno2 of ordering) {\n        const inputs2 = {};\n        const outputs2 = {};\n        for (const key in dyno2.inputs) {\n          let value = dyno2.inputs[key];\n          while (value) {\n            if (value instanceof DynoValue) {\n              if (value instanceof DynoLiteral) {\n                inputs2[key] = value.getLiteral();\n              } else if (value instanceof DynoOutput) {\n                const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);\n                if (!source) {\n                  throw new Error(\n                    `Source not found for ${value.dyno.constructor.name}.${value.key}`\n                  );\n                }\n                inputs2[key] = source;\n              }\n              break;\n            }\n            value = value.dynoOut();\n          }\n        }\n        const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };\n        for (const [key, name] of outs.outNames.entries()) {\n          outputs2[key] = name;\n        }\n        const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });\n        steps.push(newSteps);\n      }\n      const literalOutputs = [];\n      for (const key in outputs) {\n        if (blockOutputs[key] instanceof DynoLiteral) {\n          literalOutputs.push(\n            `${outputs[key]} = ${blockOutputs[key].getLiteral()};`\n          );\n        }\n      }\n      if (literalOutputs.length > 0) {\n        steps.push(literalOutputs);\n      }\n      const statements = steps.flatMap((step, index) => {\n        return index === 0 ? step : ["", ...step];\n      });\n      return { statements };\n    }\n  }\n  function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {\n    return new DynoBlock({ inTypes, outTypes, construct, update, globals });\n  }\n  function dyno({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  }) {\n    return new Dyno({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    });\n  }\n  function dynoDeclare(name, type, count) {\n    const typeStr = typeof type === "string" ? type : type.type;\n    if (!typeStr) {\n      throw new Error(`Invalid DynoType: ${String(type)}`);\n    }\n    return `${typeStr} ${name}${count != null ? `[${count}]` : ""}`;\n  }\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split("\\n").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(`^${indent}`);\n    return lines.map((line) => line.replace(regex, ""));\n  }\n  function unindent(s) {\n    return unindentLines(s).join("\\n");\n  }\n  class UnaryOp extends Dyno {\n    constructor({\n      a,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a) };\n      const outType = outTypeFunc(valType(a));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class BinaryOp extends Dyno {\n    constructor({\n      a,\n      b,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a), b: valType(b) };\n      const outType = outTypeFunc(valType(a), valType(b));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a, b } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  function toHalf(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalf(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ) {\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(a);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  const packedCenter = new Vector3();\n  const packedScales = new Vector3();\n  const packedQuaternion = new Quaternion();\n  const packedColor = new Color();\n  const packedFields = {\n    center: packedCenter,\n    scales: packedScales,\n    quaternion: packedQuaternion,\n    color: packedColor,\n    opacity: 0\n  };\n  function unpackSplat(packedSplats, index) {\n    const result = packedFields;\n    const i4 = index * 4;\n    const word0 = packedSplats[i4];\n    const word1 = packedSplats[i4 + 1];\n    const word2 = packedSplats[i4 + 2];\n    const word3 = packedSplats[i4 + 3];\n    result.color.set(\n      (word0 & 255) / 255,\n      (word0 >>> 8 & 255) / 255,\n      (word0 >>> 16 & 255) / 255\n    );\n    result.opacity = (word0 >>> 24 & 255) / 255;\n    result.center.set(\n      fromHalf(word1 & 65535),\n      fromHalf(word1 >>> 16 & 65535),\n      fromHalf(word2 & 65535)\n    );\n    const uScalesX = word3 & 255;\n    result.scales.x = uScalesX === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesX - 1) * LN_RESCALE);\n    const uScalesY = word3 >>> 8 & 255;\n    result.scales.y = uScalesY === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesY - 1) * LN_RESCALE);\n    const uScalesZ = word3 >>> 16 & 255;\n    result.scales.z = uScalesZ === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesZ - 1) * LN_RESCALE);\n    const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;\n    decodeQuatOctXy88R8(uQuat, result.quaternion);\n    return result;\n  }\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  const IDENT_VERTEX_SHADER = unindent(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = q.clone().normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? new Vector3(1, 0, 0) : new Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function decodeQuatOctXy88R8(encoded, out) {\n    const quantU = encoded & 255;\n    const quantV = encoded >>> 8 & 255;\n    const angleInt = encoded >>> 16 & 255;\n    const u_f = quantU / 255;\n    const v_f = quantV / 255;\n    let f_x = (u_f - 0.5) * 2;\n    let f_y = (v_f - 0.5) * 2;\n    const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\n    const t = Math.max(-f_z, 0);\n    f_x += f_x >= 0 ? -t : t;\n    f_y += f_y >= 0 ? -t : t;\n    const axis = new Vector3(f_x, f_y, f_z).normalize();\n    const theta = angleInt / 255 * Math.PI;\n    const halfTheta = theta * 0.5;\n    const s = Math.sin(halfTheta);\n    const w = Math.cos(halfTheta);\n    out.set(axis.x * s, axis.y * s, axis.z * s, w);\n    return out;\n  }\n  function packSint8Bytes(b0, b1, b2, b3) {\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n    const clampedB2 = Math.max(-127, Math.min(127, b2 * 127));\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb) {\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const value = Math.max(-63, Math.min(63, sh1Rgb[i2] * 63)) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb) {\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      sh2Rgb[0],\n      sh2Rgb[1],\n      sh2Rgb[2],\n      sh2Rgb[3]\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      sh2Rgb[4],\n      sh2Rgb[5],\n      sh2Rgb[6],\n      sh2Rgb[7]\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      sh2Rgb[8],\n      sh2Rgb[9],\n      sh2Rgb[10],\n      sh2Rgb[11]\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      sh2Rgb[12],\n      sh2Rgb[13],\n      sh2Rgb[14],\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb) {\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const value = Math.max(-31, Math.min(31, sh3Rgb[i2] * 31)) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error("Failed to decompress partial gzip");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.offset = 0;\n      this.chunks = [];\n      this.totalBytes = 0;\n      this.gunzip = new Gunzip((chunk, _final) => {\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      });\n    }\n    read(numBytes) {\n      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {\n        const end = Math.min(\n          this.offset + this.chunkBytes,\n          this.fileBytes.length\n        );\n        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);\n        this.offset = end;\n      }\n      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {\n        this.gunzip.push(new Uint8Array(0), true);\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error("Invalid .splat file size");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          for (const [i22, key] of sh1Index.entries()) {\n            sh1[i22] = getSh(splatOffset, key);\n          }\n          if (sh2) {\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n          }\n          if (sh3) {\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  function initEmscriptenModule(moduleFactory, wasmModule, moduleOptionOverrides = {}) {\n    let instantiateWasm;\n    if (wasmModule) {\n      instantiateWasm = (imports, callback) => {\n        const instance = new WebAssembly.Instance(wasmModule, imports);\n        callback(instance);\n        return instance.exports;\n      };\n    }\n    return moduleFactory({\n      // Just to be safe, don\'t automatically invoke any wasm functions\n      noInitialRun: true,\n      instantiateWasm,\n      ...moduleOptionOverrides\n    });\n  }\n  var Module = (() => {\n    var _scriptDir = self.location.href;\n    return function(Module2 = {}) {\n      var Module2 = typeof Module2 != "undefined" ? Module2 : {};\n      var readyPromiseResolve, readyPromiseReject;\n      Module2["ready"] = new Promise(function(resolve, reject) {\n        readyPromiseResolve = resolve;\n        readyPromiseReject = reject;\n      });\n      const isServiceWorker = globalThis.ServiceWorkerGlobalScope !== void 0;\n      const isRunningInCloudFlareWorkers = isServiceWorker && typeof self !== "undefined" && globalThis.caches && globalThis.caches.default !== void 0;\n      const isRunningInNode = typeof process === "object" && process.release && process.release.name === "node";\n      if (isRunningInCloudFlareWorkers || isRunningInNode) {\n        if (!globalThis.ImageData) {\n          globalThis.ImageData = class ImageData {\n            constructor(data, width, height) {\n              this.data = data;\n              this.width = width;\n              this.height = height;\n            }\n          };\n        }\n        if (self.location.href === void 0) {\n          self.location.href = "https://localhost";\n        }\n        if (typeof self !== "undefined" && self.location === void 0) {\n          self.location = { href: "" };\n        }\n      }\n      var moduleOverrides = Object.assign({}, Module2);\n      var ENVIRONMENT_IS_WEB = typeof window == "object";\n      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";\n      typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";\n      var scriptDirectory = "";\n      function locateFile(path) {\n        if (Module2["locateFile"]) {\n          return Module2["locateFile"](path, scriptDirectory);\n        }\n        return scriptDirectory + path;\n      }\n      var readBinary;\n      if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n        if (ENVIRONMENT_IS_WORKER) {\n          scriptDirectory = self.location.href;\n        } else if (typeof document != "undefined" && document.currentScript) {\n          scriptDirectory = document.currentScript.src;\n        }\n        if (_scriptDir) {\n          scriptDirectory = _scriptDir;\n        }\n        if (scriptDirectory.indexOf("blob:") !== 0) {\n          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);\n        } else {\n          scriptDirectory = "";\n        }\n        {\n          if (ENVIRONMENT_IS_WORKER) {\n            readBinary = (url) => {\n              var xhr = new XMLHttpRequest();\n              xhr.open("GET", url, false);\n              xhr.responseType = "arraybuffer";\n              xhr.send(null);\n              return new Uint8Array(xhr.response);\n            };\n          }\n        }\n      }\n      Module2["print"] || console.log.bind(console);\n      var err2 = Module2["printErr"] || console.warn.bind(console);\n      Object.assign(Module2, moduleOverrides);\n      moduleOverrides = null;\n      if (Module2["arguments"]) Module2["arguments"];\n      if (Module2["thisProgram"]) Module2["thisProgram"];\n      if (Module2["quit"]) Module2["quit"];\n      var wasmBinary;\n      if (Module2["wasmBinary"]) wasmBinary = Module2["wasmBinary"];\n      Module2["noExitRuntime"] || true;\n      if (typeof WebAssembly != "object") {\n        abort("no native wasm support detected");\n      }\n      var wasmMemory;\n      var ABORT = false;\n      function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n        var endIdx = idx + maxBytesToRead;\n        var str = "";\n        while (!(idx >= endIdx)) {\n          var u0 = heapOrArray[idx++];\n          if (!u0) return str;\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n          var u1 = heapOrArray[idx++] & 63;\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n          var u2 = heapOrArray[idx++] & 63;\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n          }\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n        return str;\n      }\n      function UTF8ToString(ptr, maxBytesToRead) {\n        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";\n      }\n      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n        if (!(maxBytesToWrite > 0)) return 0;\n        var startIdx = outIdx;\n        var endIdx = outIdx + maxBytesToWrite - 1;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var u = str.charCodeAt(i2);\n          if (u >= 55296 && u <= 57343) {\n            var u1 = str.charCodeAt(++i2);\n            u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n          }\n          if (u <= 127) {\n            if (outIdx >= endIdx) break;\n            heap[outIdx++] = u;\n          } else if (u <= 2047) {\n            if (outIdx + 1 >= endIdx) break;\n            heap[outIdx++] = 192 | u >> 6;\n            heap[outIdx++] = 128 | u & 63;\n          } else if (u <= 65535) {\n            if (outIdx + 2 >= endIdx) break;\n            heap[outIdx++] = 224 | u >> 12;\n            heap[outIdx++] = 128 | u >> 6 & 63;\n            heap[outIdx++] = 128 | u & 63;\n          } else {\n            if (outIdx + 3 >= endIdx) break;\n            heap[outIdx++] = 240 | u >> 18;\n            heap[outIdx++] = 128 | u >> 12 & 63;\n            heap[outIdx++] = 128 | u >> 6 & 63;\n            heap[outIdx++] = 128 | u & 63;\n          }\n        }\n        heap[outIdx] = 0;\n        return outIdx - startIdx;\n      }\n      function stringToUTF8(str, outPtr, maxBytesToWrite) {\n        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n      }\n      function lengthBytesUTF8(str) {\n        var len = 0;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var c = str.charCodeAt(i2);\n          if (c <= 127) {\n            len++;\n          } else if (c <= 2047) {\n            len += 2;\n          } else if (c >= 55296 && c <= 57343) {\n            len += 4;\n            ++i2;\n          } else {\n            len += 3;\n          }\n        }\n        return len;\n      }\n      var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n      function updateMemoryViews() {\n        var b = wasmMemory.buffer;\n        Module2["HEAP8"] = HEAP8 = new Int8Array(b);\n        Module2["HEAP16"] = HEAP16 = new Int16Array(b);\n        Module2["HEAP32"] = HEAP32 = new Int32Array(b);\n        Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);\n        Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);\n        Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);\n        Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);\n        Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);\n      }\n      var wasmTable;\n      var __ATPRERUN__ = [];\n      var __ATINIT__ = [];\n      var __ATPOSTRUN__ = [];\n      function preRun() {\n        if (Module2["preRun"]) {\n          if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];\n          while (Module2["preRun"].length) {\n            addOnPreRun(Module2["preRun"].shift());\n          }\n        }\n        callRuntimeCallbacks(__ATPRERUN__);\n      }\n      function initRuntime() {\n        callRuntimeCallbacks(__ATINIT__);\n      }\n      function postRun() {\n        if (Module2["postRun"]) {\n          if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];\n          while (Module2["postRun"].length) {\n            addOnPostRun(Module2["postRun"].shift());\n          }\n        }\n        callRuntimeCallbacks(__ATPOSTRUN__);\n      }\n      function addOnPreRun(cb) {\n        __ATPRERUN__.unshift(cb);\n      }\n      function addOnInit(cb) {\n        __ATINIT__.unshift(cb);\n      }\n      function addOnPostRun(cb) {\n        __ATPOSTRUN__.unshift(cb);\n      }\n      var runDependencies = 0;\n      var dependenciesFulfilled = null;\n      function addRunDependency(id) {\n        runDependencies++;\n        if (Module2["monitorRunDependencies"]) {\n          Module2["monitorRunDependencies"](runDependencies);\n        }\n      }\n      function removeRunDependency(id) {\n        runDependencies--;\n        if (Module2["monitorRunDependencies"]) {\n          Module2["monitorRunDependencies"](runDependencies);\n        }\n        if (runDependencies == 0) {\n          if (dependenciesFulfilled) {\n            var callback = dependenciesFulfilled;\n            dependenciesFulfilled = null;\n            callback();\n          }\n        }\n      }\n      function abort(what) {\n        if (Module2["onAbort"]) {\n          Module2["onAbort"](what);\n        }\n        what = "Aborted(" + what + ")";\n        err2(what);\n        ABORT = true;\n        what += ". Build with -sASSERTIONS for more info.";\n        var e = new WebAssembly.RuntimeError(what);\n        readyPromiseReject(e);\n        throw e;\n      }\n      var dataURIPrefix = "data:application/octet-stream;base64,";\n      function isDataURI(filename) {\n        return filename.startsWith(dataURIPrefix);\n      }\n      var wasmBinaryFile;\n      if (Module2["locateFile"]) {\n        wasmBinaryFile = "webp_dec.wasm";\n        if (!isDataURI(wasmBinaryFile)) {\n          wasmBinaryFile = locateFile(wasmBinaryFile);\n        }\n      } else {\n        wasmBinaryFile = new URL("data:application/wasm;base64,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AiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAvyAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkEEayABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBCGsgATYCACACQQxrIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQRBrIAE2AgAgAkEUayABNgIAIAJBGGsgATYCACACQRxrIAE2AgAgBCADQQRxQRhyIgRrIgJBIEkNACABrUKBgICAEH4hBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsgAAuXKQELfyMAQRBrIgskAAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQaDbACgCACIGQRAgAEELakF4cSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAkEDdCIBQcjbAGoiACABQdDbAGooAgAiASgCCCIERgRAQaDbACAGQX4gAndxNgIADAELIAQgADYCDCAAIAQ2AggLIAFBCGohACABIAJBA3QiAkEDcjYCBCABIAJqIgEgASgC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A39BBCECAn8gACABckEDcUUEQEEAIAAoAgAgASgCAEYNARoLAkADQCAALQAAIgMgAS0AACIERw0BIAFBAWohASAAQQFqIQAgAkEBayICDQALQQAPCyADIARrCwt0AQF/IAJFBEAgACgCBCABKAIERg8LIAAgAUYEQEEBDwsgASgCBCICLQAAIQECQCAAKAIEIgMtAAAiAEUNACAAIAFHDQADQCACLQABIQEgAy0AASIARQ0BIAJBAWohAiADQQFqIQMgACABRg0ACwsgACABRgv/AwERfyABQQNsIQ5BACABayEPIAFBfWwhEEEAIAFBAnRrIRFBACABQQF0IhJrIRMgBEEBdEEBciEUA0AgAyEEAkAgACATaiIKLQAAIgggACABaiIMLQAAIgtrIhVB78kAai0AACAAIA9qIg0tAAAiAyAALQAAIglrQe/JAGotAABBAnRqIBRKDQAgACARai0AACAAIBBqLQAAIgdrQe/JAGotAAAgBUoNACAHIAhrQe/JAGotAAAgBUoNACAIIANrQe/JAGotAAAiFiAFSg0AIAAgDmotAAAgACASai0AACIHa0HvyQBqLQAAIAVKDQAgByALa0HvyQBqLQAAIAVKDQAgCyAJa0HvyQBqLQAAIhcgBUoNACAJIANrQQNsIQcCfyAGIBZOIAYgF05xRQRAIA0gAyAHIBVB/DdqLAAAaiIDQQNqQQN1QfDAAGosAABqQe/DAGotAAA6AAAgACEMIAkgA0EEakEDdUHwwABqLAAAawwBCyAKIAggB0EEakEDdUHwwABqLAAAIghBAWpBAXUiCmpB78MAai0AADoAACANIAdBA2pBA3VB8MAAaiwAACADakHvwwBqLQAAOgAAIAAgCSAIa0HvwwBqLQAAOgAAIAsgCmsLIQMgDCADQe/DAGotAAA6AAALIARBAWshAyAAIAJqIQAgBEEBSw0ACwv0AQEHfwJAIAFBAEwNACAAQUBrIQYDQCAGKAIAIAAoAjhIBEAgACgCGEEATA0CCyAAKAIEBEAgACAAKQJMQiCJNwJMCyAAIAJBhOEAQYDhACAAKAIAGygCABEDAAJAIAAoAgQNACAAKAI0IAAoAghsQQBMDQAgACgCTCEHIAAoAlAhCEEAIQUDQCAHIAVBAnQiCWoiCiAKKAIAIAggCWooAgBqNgIAIAVBAWoiBSAAKAI0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akG0AWogBSANIAogBhAnIANBAUYNAQNAIAAgAkEBayIDQRRsakG0AWogBSANIAYgBhAnIAJBAUshBCADIQIgBA0ACwwBCyAGIApGDQAgBiAKIAggCWxBAnQQFBoLIA8gEGohAwJAIA5BAEwNAEEAIQlBACECIA5BBE8EQCAOQXxxIQ8DQCACIANqIAYgAkECdGooAgBBCHY6AAAgAyACQQFyIgRqIAYgBEECdGooAgBBCHY6AAAgAyACQQJyIgRqIAYgBEECdGooAgBBCHY6AAAgAyACQQNyIgRqIAYgBEECdGooAgBBCHY6AAAgAkEEaiICIA9HDQALCyAOQQNxIgRFDQADQCACIANqIAYgAkECdGooAgBBCHY6AAAgAkEBaiECIAlBAWoiCSAERw0ACwsgCygCDCIEBEAgCygCjAEhAiAIQQFxBH8gAiADIAMgByAEQQJ0QbDgAGooAgARAQAgBUEBaiEFIAMiAiAHagUgAwshBCAIQQFHBEADQCACIAQgBCAHIAsoAgxBAnRBsOAAaigCABEBACAEIAQgB2oiAiACIAcgCygCDEECdEGw4ABqKAIAEQEAIAIgB2ohBCACIQMgBUECaiIFIA1HDQALCyALIAM2AowBCyAKIAAoAmQiCSAIbEECdGohCiANIQUgDCAIayIMQQBKDQALCyAAIAE2AmwgACABNgJ0C+IBAQR/IAAEfyAALQAABUEACyEAAkAgA0EATA0AIANBA3EhBQJAIANBBEkEQEEAIQMMAQsgA0F8cSEHQQAhAwNAIAIgA2ogASADai0AACAAaiIAOgAAIAIgA0EBciIEaiABIARqLQAAIABqIgA6AAAgAiADQQJyIgRqIAEgBGotAAAgAGoiADoAACACIANBA3IiBGogASAEai0AACAAaiIAOgAAIANBBGoiAyAHRw0ACwsgBUUNAANAIAIgA2ogASADai0AACAAaiIAOgAAIANBAWohAyAGQQFqIgYgBUcNAAsLC88CAQR/AkAgAARAIANBAEwNASADQQFHBEAgA0EBcSEFIANBfnEhBwNAIAIgBGogASAEai0AACAAIARqLQAAajoAACACIARBAXIiA2ogASADai0AACAAIANqLQAAajoAACAEQQJqIgQgB0cNAAsgBUUNAgsgAiAEaiABIARqLQAAIAAgBGotAABqOgAADwsgA0EA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AigCGCACKAIcajYCGCACIAIoAkQgAigCSGo2AkQgAiACKAJAQQFqNgJAIAEoAhwiAigCGEEATARAQYjhACEDAkACQCACKAIEDQBBjOEAIQMgAigCFA0AIAIoAjQgAigCCGxBAEwNASACKAJMIQRBACEDA0AgAigCRCADaiAEIANBAnQiCGooAgA6AAAgAigCTCIEIAhqQQA2AgAgA0EBaiIDIAIoAjQgAigCCGxIDQALDAELIAIgAygCABEAAAsgAiACKAIYIAIoAhxqNgIYIAIgAigCRCACKAJIajYCRCACIAIoAkBBAWo2AkALIAEoAiAiAigCGEEATARAQYjhACEDAkACQCACKAIEDQBBjOEAIQMgAigCFA0AIAIoAjQgAigCCGxBAEwNASACKAJMIQRBACEDA0AgAigCRCADaiAEIANBAnQiCGooAgA6AAAgAigCTCIEIAhqQQA2AgAgA0EBaiIDIAIoAjQgAigCCGxIDQALDAELIAIgAygCABEAAAsgAiACKAIYIAIoAhxqNgIYIAIgAigCRCACKAJIajYCRCACIAIoAkBBAWo2AkAgASgCICECCyABKAIYIgMoAkQgASgCHCgCRCACKAJEIAwgAygCNCAOEQIAIAZBAWohBiAMIAsoAhRqIQwgASgCGCICQUBrKAIAIAIoAjhIDQALCyAGIAlqIQkgByAKSA0ACyAJC+kCAQl/IAEoAgAiBCgCHCIGIAQoAiwiAyABKAIQIghsaiEFAkAgACgCaCIHBEAgACgCECICQQBMDQEgBCgCICEJIAEoAiQhAyAAKAIAIQYgBCgCECEKQQAhAANAIAcgAyACIAcgBhAbIgsgBmxqIQcgAxAkIABqIQAgAiALayICQQBKDQALIABBAEwNASAKIAggCWxqIAQoAiAgBSAEKAIsIAEoAiQoAjQgAEEBEDFBAA8LIAZFDQAgAkEATA0AIAAoAmAhASACQQhPBEAgAkF4cSEEQQAhAANAIAVB/wEgARAVIANqQf8BIAEQFSADakH/ASABEBUgA2pB/wEgARAVIANqQf8BIAEQFSADakH/ASABEBUgA2pB/wEgARAVIANqQf8BIAEQFSADaiEFIABBCGoiACAERw0ACwsgAkEHcSICRQ0AQQAhAANAIAVB/wEgARAVIANqIQUgAEEBaiIAIAJHDQALC0EAC7MCAQd/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6OcAKAIAIgAEQEHo5wAgACgCCDYCACAAKAIEIAAoAgARAAAgABASDAELC0Hh5wBBADoAAAsGAEGAggQLJAEBf0HE4gAoAgAiAARAA0AgACgCABEKACAAKAIEIgANAAsLC4UBAQN/AkAgACgCBCICIgBBA3EEQANAIAAtAABFDQIgAEEBaiIAQQNxDQALCwNAIAAiAUEEaiEAIAEoAgAiA0F/cyADQYGChAhrcUGAgYKEeHFFDQALA0AgASIAQQFqIQEgAC0AAA0ACwsgACACa0EBaiIAEBYiAQR/IAEgAiAAEBQFQQALC9MBAQF+IAAgAC0A3wEgAEEZay0AACAALQC/ASAAQRprLQAAIAAtAJ8BIABBG2stAAAgAC0AfyAAQRxrLQAAIAAtAF8gAEEday0AACAALQA/IABBHmstAAAgAC0AHyAAQR9rLQAAIABBIGstAAAgAEEBay0AAGpqampqampqampqampqakEIakEEdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAAC9cIARJ/IABB78MAIABBIWstAABrIgIgAEEBay0AAGoiASAAQSBrIgstAAAiA2otAAA6AAAgACABIABBH2siDC0AACIEai0AADoAASAAIAEgAEEeayINLQAAIgVqLQAAOgACIAAgASAAQR1rIg4tAAAiBmotAAA6AAMgACABIABBHGsiDy0AACIHai0AADoABCAAIAEgAEEbayIQLQAAIghqLQAAOgAFIAAgASAAQRprIhEtAAAiCWotAAA6AAYgACABIABBGWsiEi0AACIKai0AADoAByAAIAogAiAALQAfaiIBai0AADoAJyAAIAEgCWotAAA6ACYgACABIAhqLQAAOgAlIAAgASAHai0AADoAJCAAIAEgBmotAAA6ACMgACABIAVqLQAAOgAiIAAgASAEai0AADoAISAAIAEgA2otAAA6ACAgACAKIAIgAC0AP2oiAWotAAA6AEcgACABIAlqLQAAOgBGIAAgASAIai0AADoARSAAIAEgB2otAAA6AEQgACABIAZqLQAAOgBDIAAgASAFai0AADoAQiAAIAEgBGotAAA6AEEgACABIANqLQAAOgBAIAAgAiAALQBfaiIBIAstAAAiA2otAAA6AGAgACABIAwtAAAiBGotAAA6AGEgACABIA0tAAAiBWotAAA6AGIgACABIA4tAAAiBmotAAA6AGMgACABIA8tAAAiB2otAAA6AGQgACABIBAtAAAiCGotAAA6AGUgACABIBEtAAAiCWotAAA6AGYgACABIBItAAAiCmotAAA6AGcgACAKIAIgAC0Af2oiAWotAAA6AIcBIAAgASAJai0AADoAhgEgACABIAhqLQAAOgCFASAAIAEgB2otAAA6AIQBIAAgASAGai0AADoAgwEgACABIAVqLQAAOgCCASAAIAEgBGotAAA6AIEBIAAgASADai0AADoAgAEgACAKIAIgAC0AnwFqIgFqLQAAOgCnASAAIAEgCWotAAA6AKYBIAAgASAIai0AADoApQEgACABIAdqLQAAOgCkASAAIAEgBmotAAA6AKMBIAAgASAFai0AADoAogEgACABIARqLQAAOgChASAAIAEgA2otAAA6AKABIAAgAiAALQC/AWoiASALLQAAIgtqLQAAOgDAASAAIAEgDC0AACIDai0AADoAwQEgACABIA0tAAAiDGotAAA6AMIBIAAgASAOLQAAIgRqLQAAOgDDASAAIAEgDy0AACINai0AADoAxAEgACABIBAtAAAiBWotAAA6AMUBIAAgASARLQAAIg5qLQAAOgDGASAAIAEgEi0AACIGai0AADoAxwEgACAGIAIgAC0A3wFqIgJqLQAAOgDnASAAIAIgDmotAAA6AOYBIAAgAiAFai0AADoA5QEgACACIA1qLQAAOgDkASAAIAIgBGotAAA6AOMBIAAgAiAMai0AADoA4gEgACACIANqLQAAOgDhASAAIAIgC2otAAA6AOABC0gBAX4gACAAQSBrKQAAIgE3AOABIAAgATcAwAEgACABNwCgASAAIAE3AIABIAAgATcAYCAAIAE3AEAgACABNwAgIAAgATcAAAu0AQAgACAAMQAfQoGChIiQoMCAAX43ACAgACAAMQA/QoGChIiQoMCAAX43AEAgACAAMQBfQoGChIiQoMCAAX43AGAgACAAMQB/QoGChIiQoMCAAX43AIABIAAgADEAnwFCgYKEiJCgwIABfjcAoAEgACAAMQC/AUKBgoSIkKDAgAF+NwDAASAAIAAxAN8BQoGChIiQoMCAAX43AOABIAAgAEEBazEAAEKBgoSIkKDAgAF+NwAAC4sBAQF+IAAgAC0A3wEgAC0AvwEgAC0AnwEgAC0AfyAALQBfIAAtAD8gAEEBay0AACAALQAfampqampqakEEakEDdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAAC50BAQF+IAAgAEEZay0AACAAQRprLQAAIABBG2stAAAgAEEcay0AACAAQR1rLQAAIABBHmstAAAgAEEgay0AACAAQR9rLQAAampqampqakEEakEDdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAACwcAIAARDwALhgEAIABCgIGChIiQoMCAfzcA4AEgAEKAgYKEiJCgwIB/NwDAASAAQoCBgoSIkKDAgH83AKABIABCgIGChIiQoMCAfzcAgAEgAEKAgYKEiJCgwIB/NwBgIABCgIGChIiQoMCAfzcAQCAAQoCBgoSIkKDAgH83ACAgAEKAgYKEiJCgwIB/NwAAC48EAQF+IAAgAEERay0AACAALQDfAyAAQRJrLQAAIAAtAL8DIABBE2stAAAgAC0AnwMgAEEUay0AACAALQD/AiAAQRVrLQAAIAAtAN8CIABBFmstAAAgAC0AvwIgAEEXay0AACAALQCfAiAAQRhrLQAAIAAtAP8BIABBGWstAAAgAC0A3wEgAEEaay0AACAALQC/ASAAQRtrLQAAIAAtAJ8BIABBHGstAAAgAC0AfyAAQR1rLQAAIAAtAF8gAEEeay0AACAALQA/IABBH2stAAAgAC0AHyAAQQFrLQAAIABBIGstAABqampqampqampqampqampqampqampqampqampqampqQRBqQQV2rUL/AYNCgYKEiJCgwIABfiIBNwAIIAAgATcAACAAIAE3ACAgACABNwAoIAAgATcAQCAAIAE3AEggACABNwBgIAAgATcAaCAAIAE3AIABIAAgATcAiAEgACABNwCgASAAIAE3AKgBIAAgATcAwAEgACABNwDIASAAIAE3AOgBIAAgATcA4AEgACABNwCIAiAAIAE3AIACIAAgATcAqAIgACABNwCgAiAAIAE3AMgCIAAgATcAwAIgACABNwDoAiAAIAE3AOACIAAgATcAiAMgACABNwCAAyAAIAE3AKgDIAAgATcAoAMgACABNwDIAyAAIAE3AMADIAAgATcA6AMgACABNwDgAwukAwETfyAAQRFrIQMgAEESayEEIABBE2shBSAAQRRrIQYgAEEVayEHIABBFmshCCAAQRdrIQkgAEEYayEKIABBGWshCyAAQRprIQwgAEEbayENIABBHGshDiAAQR1rIQ8gAEEeayEQIABBH2shESAAQSBrIRJB78MAIABBIWstAABrIRMDQCAAIBMgAEEBay0AAGoiASASLQAAai0AADoAACAAIAEgES0AAGotAAA6AAEgACABIBAtAABqLQAAOgACIAAgASAPLQAAai0AADoAAyAAIAEgDi0AAGotAAA6AAQgACABIA0tAABqLQAAOgAFIAAgASAMLQAAai0AADoABiAAIAEgCy0AAGotAAA6AAcgACABIAotAABqLQAAOgAIIAAgASAJLQAAai0AADoACSAAIAEgCC0AAGotAAA6AAogACABIActAABqLQAAOgALIAAgASAGLQAAai0AADoADCAAIAEgBS0AAGotAAA6AA0gACABIAQtAABqLQAAOgAOIAAgASADLQAAai0AADoADyAAQSBqIQAgAkEBaiICQRBHDQALC5cCAgJ+AX8gACAAQSBrIgMpAAAiATcAACAAIAE3ACAgACABNwBAIAAgATcAYCAAIAE3AIABIAAgATcAoAEgACABNwDAASAAIAE3AOABIAAgAykACCIBNwAIIAAgATcAKCAAIAE3AEggACABNwBoIAAgATcAiAEgACABNwCoASAAIAE3AMgBIAAgATcA6AEgACADKQAIIgE3AIgCIAAgAykAACICNwCAAiAAIAE3AKgCIAAgAjcAoAIgACABNwDIAiAAIAI3AMACIAAgATcA6AIgACACNwDgAiAAIAI3AIADIAAgATcAiAMgACABNwCoAyAAIAI3AKADIAAgAjcAwAMgACABNwDIAyAAIAE3AOgDIAAgAjcA4AMLigQBAX4gACAAMQAfQoGChIiQoMCAAX4iATcAICAAIAE3ACggACAAMQA/QoGChIiQoMCAAX4iATcAQCAAIAE3AEggACAAMQBfQoGChIiQoMCAAX4iATcAYCAAIAE3AGggACAAMQB/QoGChIiQoMCAAX4iATcAgAEgACABNwCIASAAIAAxAJ8BQoGChIiQoMCAAX4iATcAqAEgACABNwCgASAAIABBAWsxAABCgYKEiJCgwIABfiIBNwAAIAAgATcACCAAIAAxAL8BQoGChIiQoMCAAX4iATcAyAEgACABNwDAASAAIAAxAN8BQoGChIiQoMCAAX4iATcA6AEgACABNwDgASAAIAAxAP8BQoGChIiQoMCAAX4iATcAiAIgACABNwCAAiAAIAAxAJ8CQoGChIiQoMCAAX4iATcAqAIgACABNwCgAiAAIAAxAL8CQoGChIiQoMCAAX4iATcAyAIgACABNwDAAiAAIAAxAN8CQoGChIiQoMCAAX4iATcA6AIgACABNwDgAiAAIAAxAP8CQoGChIiQoMCAAX4iATcAiAMgACABNwCAAyAAIAAxAJ8DQoGChIiQoMCAAX4iATcAqAMgACABNwCgAyAAIAAxAL8DQoGChIiQoMCAAX4iATcAyAMgACABNwDAAyAAIAAxAN8DQoGChIiQoMCAAX4iATcA6AMgACABNwDgAwv/AgEBfiAAIAAtAN8DIAAtAL8DIAAtAJ8DIAAtAP8CIAAtAN8CIAAtAL8CIAAtAJ8CIAAtAP8BIAAtAN8BIAAtAL8BIAAtAJ8BIAAtAH8gAC0AXyAALQA/IABBAWstAAAgAC0AH2pqampqampqampqampqakEIakEEdq1C/wGDQoGChIiQoMCAAX4iATcAACAAIAE3AAggACABNwAoIAAgATcAICAAIAE3AEggACABNwBAIAAgATcAaCAAIAE3AGAgACABNwCIASAAIAE3AIABIAAgATcAqAEgACABNwCgASAAIAE3AMgBIAAgATcAwAEgACABNwDoASAAIAE3AOABIAAgATcAiAIgACABNwCAAiAAIAE3AKgCIAAgATcAoAIgACABNwDIAiAAIAE3AMACIAAgATcA6AIgACABNwDgAiAAIAE3AIgDIAAgATcAgAMgACABNwCoAyAAIAE3AKADIAAgATcAyAMgACABNwDAAyAAIAE3AOgDIAAgATcA4AMLoQMBAX4gACAAQRFrLQAAIABBEmstAAAgAEETay0AACAAQRRrLQAAIABBFWstAAAgAEEWay0AACAAQRdrLQAAIABBGGstAAAgAEEZay0AACAAQRprLQAAIABBG2stAAAgAEEcay0A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IAIgAigC/BE2AqQBAkAgA0ECRgRAIAIoAoASIQMgAiACKAKwATYCgBIgAiADNgKwAQwBCyACICwQKwsgAQRAIAIoAtQRIQEgAiACKAKsATYC1BEgAiABNgKsAQsgAigChAEiAQRAIAIoAogBIAIoAowBIAERBQAhASACIAIoApABIAFFcjYCkAELIAIgAigCmAFBAWoiAUEAIAEgAigCnAFHGzYCmAEMAgsgAiABNgKoASACIAIoAvwRNgKkASACICwQKyACIAlBJGoQLw0BC0EAIQMgAigCAA0FIAJBgxE2AgggAkIGNwIADAULIAIgAigC/BFBAWoiGTYC/BEgGSACKAK0AkgNAAsLIAIoApQBQQBKBEBBACEDIAIoApABDQMLQQEhAwwCC0EAIQMgAigCAA0BIAJBthE2AgggAkIHNwIADAELQQAhAyACKAIADQAgAkG0EDYCCCACQgE3AgALQQEhASACKAKUAUEASgRAIAIoApABRSEBCyAJKAJYIgQEQCAJQSRqIAQRAAALIAEgA3ENAgsgAkEANgKAASACKAK4EhASIAJCADcCuBIgAigCqBIiAQRAIAEoAhQiAwRAIAMQHSADEBILIAEQEgsgAkEANgKoEiACKALwERASIAJCADcCDCACQgA3AvARIAJCADcCFCACQgA3AhwgAkEANgIkIAJBADYCBAsgAigCACEBDAELQQAhASACQQA2AgQLIAJBADYCgAEgAigCuBIQEiACQgA3ArgSIAIoAqgSIgMEQCADKAIUIgQEQCAEEB0gBBASCyADEBILIAJBADYCqBIgAigC8BEQEgsgAhASIAEEQCAMKAJgIgNFDQEgAygCDEEATARAIAMoAlAQEgsgA0EANgJQDAELQQAhASAMKAJ0IgNFDQAgAygCMEUNACAMKAJgIgNFBEBBAiEBDAELIAMoAghBAWshBiADKAIQIQgCQCADKAIAQQpNBEAgAyAIIAYgA0EUaiIEKAIAIgNsajYCEAwBCyADQQAgAygCICIEazYCICADQQAgAygCJCIKazYCJCADQQAgAygCKCIFazYCKCADIAggBCAGbGo2AhAgAyADKAIUIAogBkEBdSIEbGo2AhQgAyADKAIYIAQgBWxqNgIYIAMoAhwiCEUNASADIAggA0EsaiIEKAIAIgMgBmxqNgIcCyAEQQAgA2s2AgALIAlBsAFqJAAgAQ0AIAwoAhgiAUUNAAJAQaDfAC0AAA0AQaDfAEEBOgAAQZDfAEGACBAENgIAQQYQJkGU3wBB/QoQBDYCAEEHECZBoN8ALQAADQBBoN8AQQE6AABBkN8AQYAIEAQ2AgBBBhAmQZTfAEH9ChAENgIAQQcQJgsgDCABNgIMIAwgKiArbEECdDYCCEGQ3wAoAgBBAUG8EiAMQQhqIgQQByIDEAggDCArNgIYIAwgKjYCECAMIAM2AgggAEGU3wAoAgBBA0HAEiAEEAc2AgAgAxADIAEQEgwBCyAAQQI2AgALIAxBwAFqJAALvwIBB38gACAAQR9rLQAAIgVBAWoiASAAQR5rLQAAIgJqQQF2IgM6AEAgACABIABBIGstAAAiBmpBAXY6AAAgACACIABBHWstAAAiAWpBAWpBAXYiBDoAQSAAIAM6AAEgACABIABBHGstAAAiA2pBAWpBAXYiBzoAQiAAIAQ6AAIgACAHOgADIAAgBSABQQJqIgRqIAJBAXRqQQJ2Igc6AGAgACAGIAJBAmoiAmogBUEBdGpBAnY6ACAgACADIAIgAUEBdGpqQQJ2IgU6AGEgACAHOgAhIABBGWstAAAhBiAAQRprLQAAIQIgACAAQRtrLQAAIgEgBCADQQF0ampBAnYiBDoAYiAAIAU6ACIgACAGIAEgAkEBdGpqQQJqQQJ2OgBjIAAgAiADIAFBAXRqakECakECdjoAQyAAIAQ6ACMLsAIBCX8gACAALQAfIgMgAC0APyIEakEBakEBdiICOgBiIAAgBCAALQBfIgdqQQFqQQF2OgBgIAAgAjoAQCAAIABBAWstAAAiBkEBaiIBIABBIWstAAAiAmpBAXYiBToAIiAAIAEgA2pBAXYiAToAQiAAIAU6AAAgACABOgAgIAAgAEEgay0AACIBIAZBAmoiBSACQQF0ampBAnYiCDoAIyAAIABBHmstAAAgASAAQR9rLQAAIglBAXRqakECakECdjoAAyAAIAkgAiABQQF0ampBAmpBAnY6AAIgACACIANBAmoiASAGQQF0ampBAnYiAjoAQyAAIAg6AAEgACAEIAVqIANBAXRqQQJ2IgM6AGMgACACOgAhIAAgASAHaiAEQQF0akECdjoAYSAAIAM6AEEL2QEBBn8gACAALQBfIgE6AGMgACABOgBiIAAgAToAYSAAIAE6AGAgACAALQAfIgRBAWoiAyAALQA/IgJqQQF2IgU6ACAgACADIABBAWstAAAiBmpBAXY6AAAgACABIAJqQQFqQQF2IgM6AEAgACAFOgACIAAgAzoAIiAAIAEgBGogAkEBdGpBAmpBAnYiAzoAISAAIAYgAkECaiICaiAEQQF0akECdjoAASAAIAEgAmogAUEBdGpBAnYiAjoAQSAAIAM6AAMgACACOgAjIAAgAToAQyAAIAE6AEILbgEBfyAAIAAtAF8gAEEday0AACAALQA/IABBHmstAAAgAC0AHyAAQR9rLQAAIABBIGstAAAgAEEBay0AAGpqampqampBBGpBA3ZB/wFxQYGChAhsIgE2AGAgACABNgBAIAAgATYAICAAIAE2AAALpAIBBn8gAEHvwwAgAEEhay0AAGsiAiAAQQFrLQAAaiIBIABBIGstAAAiA2otAAA6AAAgACABIABBH2stAAAiBGotAAA6AAEgACABIABBHmstAAAiBWotAAA6AAIgACABIABBHWstAAAiBmotAAA6AAMgACAGIAIgAC0AH2oiAWotAAA6ACMgACABIAVqLQAAOgAiIAAgASAEai0AADoAISAAIAEgA2otAAA6ACAgACAGIAIgAC0AP2oiAWotAAA6AEMgACABIAVqLQAAOgBCIAAgASAEai0AADoAQSAAIAEgA2otAAA6AEAgACAGIAIgAC0AX2oiAmotAAA6AGMgACACIAVqLQAAOgBiIAAgAiAEai0AADoAYSAAIAIgA2otAAA6AGAL4gEBBn8gACAAQRxrLQAAIABBHmstAAAiAkECaiIDIABBHWstAAAiAUEBdGpqQQJ2IgQ6AGMgACABIABBH2stAAAiBUECaiIGIAJBAXRqakECdiICOgBiIAAgAyAAQSBrLQAAIgFqIAVBAXRqQQJ2IgM6AGEgACAGIABBIWstAABqIAFBAXRqQQJ2IgE6AGAgACAEOgBDIAAgAjoAQiAAIAM6AEEgACABOgBAIAAgBDoAIyAAIAI6ACIgACADOgAhIAAgAToAICAAIAQ6AAMgACACOgACIAAgAzoAASAAIAE6AAALpgIBBX8gACAALQBfIAAtAB8iAUECaiIDIAAtAD8iAkEBdGpqQQJ2OgBgIAAgAiAAQQFrLQAAIgRBAmoiBSABQQF0ampBAnYiAToAYSAAIAE6AEAgACAAQSFrLQAAIgIgAyAEQQF0ampBAnYiAToAYiAAIAE6AEEgACABOgAgIAAgBSAAQSBrLQAAIgNqIAJBAXRqQQJ2IgE6AGMgACABOgBCIAAgAToAISAAIAE6AAAgAEEday0AACEFIABBHmstAAAhASAAIAIgAEEfay0AACIEaiADQQF0akECakECdiICOgBDIAAgAjoAIiAAIAI6AAEgACABIANqIARBAXRqQQJqQQJ2IgI6ACMgACACOgACIAAgBCAFaiABQQF0akECakECdjoAAwujAgEFfyAAIABBHWstAAAiAkECaiIFIABBH2stAAAiA2ogAEEeay0AACIBQQF0akECdiIEOgAgIAAgAUECaiIBIABBIGstAABqIANBAXRqQQJ2OgAAIAAgAEEcay0AACIDIAEgAkEBdGpqQQJ2IgE6AEAgACAEOgABIAAgAToAISAAIABBG2stAAAiBCAFIANBAXRqakECdiICOgBgIAAgAToAAiAAIAI6AEEgACACOgAiIAAgAjoAAyAAIABBGmstAAAiAiADIARBAXRqakECakECdiIDOgBhIAAgAEEZay0AACIBIAQgAkEBdGpqQQJqQQJ2IgQ6AGIgACADOgAjIAAgAzoAQiAAIAEgAmogAUEBdGpBAmpBAnY6AGMgACAEOgBDCy8AIAAgARAhIABBIGogAUEEahAhIABBQGsgAUGAAWoQISAAQeAAaiABQYQBahAhC08BAX8gAC8BACICBEAgAiABECALIAAvASAiAgRAIAIgAUEEahAgCyAALwFAIgIEQCACIAFBgAFqECALIAAvAWAiAARAIAAgAUGEAWoQIAsLqQIBBH8jAEEQayICJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEDghAyACIAVBgICAgHhyNgIIIAIgAzYCACACIAQ2AgQgAyAEaiEFDAELIAIgBDoACyACIARqIQUgAiEDIARFDQELIAMgAUEEaiAEEBQaCyAFQQA6AAAgAkEMaiACIAARAwAgAigCDBAIIAIoAgwiABADIAIsAAtBAEgEQCACKAIAEBILIAJBEGokACAADwtB2AAQFkHQAGoiA0Hk2gA2AgAgA0GQ2QA2AgBBGRA4IgFBADYCCCABQoyAgIDAATcCACABQQxqIgBBlwopAAA3AAUgAUGSCikAADcADCADIAA2AgQgA0HA2QA2AgAgA0Hg2QBBPBANAAvkEgETfwJAIAEgACgCbCIDayICQQBMDQAgACgCCCIIKAIAIQsgACgCECAAKAJkIgUgA2xBAnRqIQYgACgCFCEJAkAgACgCsAEiBEEASgRAIAAgBEEBayICQRRsakG0AWogAyABIAYgCRAnIARBAUYNAQNAIAAgAkEBayIGQRRsakG0AWogAyABIAkgCRAnIAJBAUshBCAGIQIgBA0ACwwBCyAGIAlGDQAgCSAGIAIgBWxBAnQQFBoLIAgoAlgiBiABIAEgBkobIgYgCCgCVCICIAAoAmwiAyACIANKIgUbIgRMDQAgCCAGIARrIgY2AhAgCCAEIAJrNgIIIAggCCgCUCAIKAJMIgprIgQ2AgwgCSALQQJ0IhAgAiADa2xBACAFG2ogCkECdGohCyAAKAIMIgIoAgAiEUEKTQRAIAIoAhAgAigCFCINIAAoAnRsaiEKAkAgCCgCXARAIAZBAEwEQEEAIQgMAgtBACEJQQAhCANAIAsgCSAQbGoiAyAQIAAoAowCIgIoAiwgAigCICIEIAIoAhhqQQFrIARtIgQgBiAJayICIAIgBEobEEEgACgCjAIgAiADIBAQGyAJaiEJQQAhBQJAIAAoAowCIgNBQGsiDigCACADKAI4Tg0AIAogCCANbGohEyADKAI0IQwgAygCRCESA0AgAygCGEEASg0BQYjhACECAkACQCADKAIEDQBBjOEAIQIgAygCFA0AIAMoAjQgAygCCGxBAEwNASADKAJMIQdBACECA0AgAygCRCACaiAHIAJBAnQiBGooAgA6AAAgAygCTCIHIARqQQA2AgAgAkEBaiICIAMoAjQgAygCCGxIDQALDAELIAMgAigCABEAAAsgAyADKAIYIAMoAhxqNgIYIAMgAygCRCADKAJIajYCRCAOIA4oAgBBAWo2AgBBACECIAxBAEoEQANAIBIgAkECdGoiFCgCACIEQf///3dNBEBBACEHIBQgBEGAgIAITwR/IARBgICAeHFBgICAeCAEQRh2biIHIARB/wFxbEGAgIAEakEYdnIgByAEQQh2Qf8BcWxBgICABGpBEHZBgP4DcXIgByAEQRB2Qf8BcWxBgICABGpBCHZBgID8B3FyBUEACzYCAAsgAkEBaiICIAxHDQALCyASIAwg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b2wAZW1zY3JpcHRlbjo6dmFsAGJhZCBwYXJ0aXRpb24gbGVuZ3RoAHVuc2lnbmVkIGxvbmcAc3RkOjp3c3RyaW5nAGJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBkb3VibGUAZGVjb2RlAEJhZCBjb2RlIHdvcmQAdm9pZABGcmFtZSBzZXR1cCBmYWlsZWQASW1hZ2VEYXRhAFZQOFgAV0VCUABWUDhMAE9LAEFMUEgAUklGRgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AEluY29ycmVjdCBrZXlmcmFtZSBwYXJhbWV0ZXJzLgBUcnVuY2F0ZWQgaGVhZGVyLgBubyBtZW1vcnkgZHVyaW5nIGZyYW1lIGluaXRpYWxpemF0aW9uLgBOb3QgYSBrZXkgZnJhbWUuAEZyYW1lIG5vdCBkaXNwbGF5YWJsZS4AT3V0cHV0IGFib3J0ZWQuAFByZW1hdHVyZSBlbmQtb2YtZmlsZSBlbmNvdW50ZXJlZC4AUHJlbWF0dXJlIGVuZC1vZi1wYXJ0aXRpb24wIGVuY291bnRlcmVkLgBDb3VsZCBub3QgZGVjb2RlIGFscGhhIGRhdGEuAG51bGwgVlA4SW8gcGFzc2VkIHRvIFZQOEdldEhlYWRlcnMoKQBWUDggAAAAwCgAAHwnAABpaWkA6CsAAGlpAAA4KQAAwCgAAOgrAADoKwAAAAAAAP///////////////////////////////////////////7D2////////////3/H8///////////5/f3////////////0/P//////////6v7+///////////9///////////////2/v//////////7/3+///////////+//7////////////4/v//////////+//+///////////////////////////9/v//////////+/7+///////////+//7////////////+/f/+////////+v/+//7////////+/////////////////////////////////////////////////////////9n/////////////4fzx/f///v/////q+vH6/f/9/v/////+////////////3/7+///////////u/f7+///////////4/v//////////+f7////////////////////////////9////////////9/7////////////////////////////9/v///////////P/////////////////////////////+/v///////////f/////////////////////////////+/f//////////+v/////////////+/////////////////////////////////////////////////////////7r7+v//////////6vv0/v/////////7+/P9/v/+///////9/v//////////7P3+///////////7/f3+/v/////////+/v///////////v7+///////////////////////////+/////////////v7////////////+/////////////////////////////v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////j/////////////+v78/v/////////4/vn9///////////9/f//////////9v39///////////8/vv+/v/////////+/P//////////+P79///////////9//7+///////////7/v//////////9fv+///////////9/f7////////////7/f///////////P3+/////////////v/////////////8////////////+f/+//////////////7//////////////f//////////+v///////////////////////////////////////////v///////////////////////////4CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgP2I/v/k24CAgICAvYHy/+PV/9uAgIBqfuP81tH//4CAgAFi+P/s4v//gICAtYXu/t3q/5qAgIBOhsr3xrT/24CAgAG5+f/z/4CAgICAuJb3/+zggICAgIBNbtj/7OaAgICAgAFl+//x/4CAgICAqovx/OzR//+AgIAldMTz5P///4CAgAHM/v/1/4CAgICAz6D6/+6AgICAgIBmZ+f/06uAgICAgAGY/P/w/4CAgICAsYfz/+rhgICAgIBQgdP/wuCAgICAgAEB/4CAgICAgICA9gH/gICAgICAgID/gICAgICAgICAgMYj7d/Bu6KgkZs+gy3G3ayw3J383QFEL5LQlafdov/fgAGV8f/d4P//gICAuI3q/d7c/8eAgIBRY7XysL75yv//gAGB6P3WxfLE//+AY3nS+snG/8qAgIAXW6Pyqrv30v//gAHI9v/q/4CAgICAbbLx/+f1//+AgIAsgsn9zcD//4CAgAGE7/vb0f+lgICAXojh+9q+//+AgIAWZK71uqH/x4CAgAG2+f/o64CAgICAfI/x/+PqgICAgIAjTbX7wdP/zYCAgAGd9//s5///gICAeY3r/+Hj//+AgIAtY7z7w9n/4ICAgAEB+//V/4CAgICAywH4//+AgICAgICJAbH/4P+AgICAgP0J+PvP0P/AgICArw3g88G5+cb//4BJEavdobPsp//qgAFf9/3Ut///gICA71r0+tPR//+AgICbTcP4vMP//4CAgAEY7/va2//NgICAyTPb/8S6gICAgIBFLr7vydr/5ICAgAG/+///gICAgICA36X5/9X/gICAgICNfPj//4CAgICAgAEQ+P//gICAgICAviTm/+z/gICAgICVAf+AgICAgICAgAHi/4CAgICAgICA98D/gICAgICAgIDwgP+AgICAgICAgAGG/P//gICAgICA1T76//+AgICAgIA3Xf+AgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMoY1eu6v9yg8K//fia26Km45K7/u4A9Lorbl7Lwqv/YgAFw5vrHv/ef//+Apm3k/NPX/66AgIAnTaLorLT1sv//gAE03PbGx/nc//+AfEq/87fB+t3//4AYR4Lbmqrztv//gAG24fnb8P/ggICAlZbi/NjN/6uAgIAcbKryt8L+3///gAFR5vzMy//AgICAe2bR97zE/+mAgIAUX5nzpK3/y4CAgAHe+P/Y1YCAgICAqK/2/OvN//+AgIAvdNf/09T//4CAgAF57P3U1v//gICAjVTV/MnK/9uAgIAqUKDworn/zYCAgAEB/4CAgICAgICA9AH/gICAgICAgIDuAf+AgICAgICAgOd4MFlzcXiYcJizQH6qdi5GX69Fj1BVUkibZzg6CqvavRENmHIaEaMswxUKrXkYUMMaPixAVZBHCiar1ZAiGqouNxOIoCHORz8UCHJy0AwJ4lEoC2C2VB0QJIa3WYliZWqllEi7ZIKdbyBLUEJmp2NKPijqgCk1CbLxjRoIa0orGpJJpjEXnUEmaaAzNB9zgGhPDBvZ/1cRB1dERyxyMw+6Fy8pDm62txURwkItGWbFvRcSFlhYk5YqLi3EzStht3VVJiOzPSc1yFcaFSvoqzgiM2hyZh1dTSccVas6pVpiQCIWdM4XIiumSWs2IBozAVErH0QZahZAqyThciITFWaEvBBMfD4STl9VOTIwM8FlI5/Xb1kubzyUH6zb5BUSb3BxTVWz/yZ4cigqAcT10QoZbVgrHYym1SUrmj0/HptDLUQB0WRQCCuaATMaR45OThD/gCLFqykoBWbTtwQB3TMyEajRwBcZUoofJKsbpiYs5UNXOqlScxo7sz87WrQ7pl1JmigoFXSP0SInry8PELci3zEtty4RIbcGYg8gtzkuFhiAATYRJUEgSXMcgBeAzSgDCXMzwBIG31clCXM7TUAVL2g3LNoJNjWC4kBaRs0oKRcaOTY5cLgFKSam1R4iGoWYdAoghicTNd0aciBJ/x8JQeoCDwF2SUsgDDPA/6ArM1gfI0NmVTe6VTgVF287zS0lwDcmRnxJZgEiYn1iKlhoVXWvUl9UNVmAZHFlLUtPey8zgFGrATkRBUdmOTUpMSYhDXk5SRoBVSkKQ4pNblovcnMVAgpm/6YXBmUdEApVgGXEGjkSCmZm1SIUK3UUDySjgEQBGmY9RyUiNR/zwEU8RyZJdxzeJUQtgCIBLwv1qz4RE0aSVTc+RiUrJZpko1WgAT8JXIgcQCDJVUsPCQlA/7h3EFYGHAVA/xn4ATgIEYSJ/zd0gDoPFFKHORp5KKQyH4mahRkj2jNnLIODex8GnlYoQIeU4C23gBYaEYPwmg4B0S0QFVtA3gcBxTgVJ5s8ihdm1VMMDTbA/0QvHFUaVVWAgCCSqxILBz+QqwQE9iMbCpKuqwwagL5QI2O0UH42LVV+L1ewMykUIGVLgIt2knSAVTgpD7DsVSUJPkceEXd2/xESimUmPIo3RisajpIkEx6r/2EbFIotPT7bAVG8QCApFHWXjhQVo3ATDD3DgDAEGABBoSoLEQH/Av4DBAb9Bfz7+gf5CPj3AEHAKgu1BQQFBgcICQoKCwwNDg8QERESExQUFRUWFhcXGBkZGhscHR4fICEiIyQlJSYnKCkqKywtLi4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xMTU5PUFFSU1RVVldYWVtdX2BiZGVmaGpsbnBydHZ6fH6AgoSGiIqMj5GUl5qdBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA8AD4AQABCAEQARgBIAEoATABOAFAAUgBUAFYAWABaAFwAXgBgAGIAZABmAGgAagBsAG4AcAByAHQAdwB6AH0AgACDAIYAiQCMAI8AkgCVAJgAmwCeAKEApACnAKoArQCxALUAuQC9AMEAxQDJAM0A0QDVANkA3QDhAOUA6gDvAPUA+QD+AAMBCAENARIBFwEcAQgHBgQEAgICAQEBAQACCAAAAAQACAAMAIAAhACIAIwAAAEEAQgBDAGAAYQBiAGMAQABBAgFAgMGCQwNCgcLDg8QFwAAFBcAABkXAAAfFwAArZSMALCbjIcAtJ2NhoIA/v7z5sSxmYyFgoEAAAAAAACKC4wLjguSC5oLqgvKCwoMjAyMDYwPjBMAAAAAAAAAABESAAECAwQFEAYHCAkKCwwNDg8CAwcDAwsAAAAAAAAAGAcXGSgGJykWGiYqOAU3ORUbNjolK0gER0kUHDU7RkokLFhFSzQ8A1dZEx1WWiMtRExVWzM9aAJnaRIeZmoiLlRcQ01lazI+eAF3eVNdER9kbEJOdnohL3V7MT9jbVJeAHR8QU8QIGJuMHN9UV9Acn5hb1Bxf2BwAwQDBAQCAgQEBAIBAQBBgDAL4BGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f38AAAAAAAAAAPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PAEHwwwAL4wgBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAP/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAAAAAAEAAAADAAAABwAAAA8AAAAfAAAAPwAAAH8AAAD/AAAA/wEAAP8DAAD/BwAA/w8AAP8fAAD/PwAA/38AAP//AAD//wEA//8DAP//BwD//w8A//8fAP//PwD//38A////AEHgzAALjQ4wUuENhhizA8usX3dqYogcVVw4aCi4sxT4/oVKS7jdSZfz/GSJAlVcAAApStrBfg2rt0BZfVeSVHLKGU5pjNM4Ze4BDF91oTJS9jdUMiy7WrFXqg/nM/Vz2u5faOLMY3WDDplu7acwR8bZwE88FWtJ+gMUTwz7GlQyC5lzHMvXJgY3zG/Yd7ssKi92dd3MJWRhVLMkFYd9CqgUBCJnvx4UgxW0VuMC5XNvscpEQk0mKPuuunPt61AK+7ZqHQvUOg1oO9s1gx4IK5Vrznfw5YFRvDuFeJSUnwA87eUnTlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAPQsAAA8JwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAPQsAACEJwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAPQsAADMJwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAD0LAAAFCgAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAA9CwAAGAoAABOMTBlbXNjcmlwdGVuM3ZhbEUAAPQsAACsKAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAAD0LAAAyCgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAA9CwAAPAoAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAPQsAAAYKQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAD0LAAAQCkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAA9CwAAGgpAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAPQsAACQKQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAD0LAAAuCkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAA9CwAAOApAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAPQsAAAIKgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAD0LAAAMCoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAA9CwAAFgqAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAA0LQAAgCoAACQtAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAAA0LQAAsCoAAKQqAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAAA0LQAA4CoAAKQqAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQA0LQAAECsAAAQrAAAAAAAAhCsAAGMAAABkAAAAZQAAAGYAAABnAAAATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FADQtAABcKwAApCoAAHYAAABIKwAAkCsAAGIAAABIKwAAnCsAAGMAAABIKwAAqCsAAGgAAABIKwAAtCsAAGEAAABIKwAAwCsAAHMAAABIKwAAzCsAAHQAAABIKwAA2CsAAGkAAABIKwAA5CsAAGoAAABIKwAA8CsAAGwAAABIKwAA/CsAAG0AAABIKwAACCwAAHgAAABIKwAAFCwAAHkAAABIKwAAICwAAGYAAABIKwAALCwAAGQAAABIKwAAOCwAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAAA0LQAARCwAANQqAABTdDlleGNlcHRpb24AAAAAAAAAAKwsAAA8AAAAaAAAAGkAAABTdDExbG9naWNfZXJyb3IANC0AAJwsAABULQAAAAAAAOAsAAA8AAAAagAAAGkAAABTdDEybGVuZ3RoX2Vycm9yAAAAADQtAADMLAAArCwAAAAAAADUKgAAYwAAAGsAAABlAAAAZgAAAGwAAABtAAAAbgAAAG8AAABTdDl0eXBlX2luZm8AAAAA9CwAABQtAAAAAAAAbCwAAGMAAABwAAAAZQAAAGYAAABsAAAAcQAAAHIAAABzAAAA9CwAAHgsAAAAAAAAVC0AAHQAAAB1AAAAdgBB8NoACyrwMwEAdC0AAHgtAAB8LQAAgC0AAIQtAACILQAAjC0AAJAtAACULQAAmC0=", self.location.href).href;\n      }\n      function getBinary(file) {\n        try {\n          if (file == wasmBinaryFile && wasmBinary) {\n            return new Uint8Array(wasmBinary);\n          }\n          if (readBinary) {\n            return readBinary(file);\n          }\n          throw "both async and sync fetching of the wasm failed";\n        } catch (err3) {\n          abort(err3);\n        }\n      }\n      function getBinaryPromise(binaryFile) {\n        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n          if (typeof fetch == "function") {\n            return fetch(binaryFile, { credentials: "same-origin" }).then(function(response) {\n              if (!response["ok"]) {\n                throw "failed to load wasm binary file at \'" + binaryFile + "\'";\n              }\n              return response["arrayBuffer"]();\n            }).catch(function() {\n              return getBinary(binaryFile);\n            });\n          }\n        }\n        return Promise.resolve().then(function() {\n          return getBinary(binaryFile);\n        });\n      }\n      function instantiateArrayBuffer(binaryFile, imports, receiver) {\n        return getBinaryPromise(binaryFile).then(function(binary) {\n          return WebAssembly.instantiate(binary, imports);\n        }).then(function(instance) {\n          return instance;\n        }).then(receiver, function(reason) {\n          err2("failed to asynchronously prepare wasm: " + reason);\n          abort(reason);\n        });\n      }\n      function instantiateAsync(binary, binaryFile, imports, callback) {\n        if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {\n          return fetch(binaryFile, { credentials: "same-origin" }).then(function(response) {\n            var result = WebAssembly.instantiateStreaming(response, imports);\n            return result.then(callback, function(reason) {\n              err2("wasm streaming compile failed: " + reason);\n              err2("falling back to ArrayBuffer instantiation");\n              return instantiateArrayBuffer(binaryFile, imports, callback);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n      }\n      function createWasm() {\n        var info = { "a": wasmImports };\n        function receiveInstance(instance, module) {\n          var exports = instance.exports;\n          Module2["asm"] = exports;\n          wasmMemory = Module2["asm"]["s"];\n          updateMemoryViews();\n          wasmTable = Module2["asm"]["y"];\n          addOnInit(Module2["asm"]["t"]);\n          removeRunDependency();\n          return exports;\n        }\n        addRunDependency();\n        function receiveInstantiationResult(result) {\n          receiveInstance(result["instance"]);\n        }\n        if (Module2["instantiateWasm"]) {\n          try {\n            return Module2["instantiateWasm"](info, receiveInstance);\n          } catch (e) {\n            err2("Module.instantiateWasm callback failed with error: " + e);\n            readyPromiseReject(e);\n          }\n        }\n        instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n        return {};\n      }\n      function callRuntimeCallbacks(callbacks) {\n        while (callbacks.length > 0) {\n          callbacks.shift()(Module2);\n        }\n      }\n      function ExceptionInfo(excPtr) {\n        this.excPtr = excPtr;\n        this.ptr = excPtr - 24;\n        this.set_type = function(type) {\n          HEAPU32[this.ptr + 4 >> 2] = type;\n        };\n        this.get_type = function() {\n          return HEAPU32[this.ptr + 4 >> 2];\n        };\n        this.set_destructor = function(destructor) {\n          HEAPU32[this.ptr + 8 >> 2] = destructor;\n        };\n        this.get_destructor = function() {\n          return HEAPU32[this.ptr + 8 >> 2];\n        };\n        this.set_refcount = function(refcount) {\n          HEAP32[this.ptr >> 2] = refcount;\n        };\n        this.set_caught = function(caught) {\n          caught = caught ? 1 : 0;\n          HEAP8[this.ptr + 12 >> 0] = caught;\n        };\n        this.get_caught = function() {\n          return HEAP8[this.ptr + 12 >> 0] != 0;\n        };\n        this.set_rethrown = function(rethrown) {\n          rethrown = rethrown ? 1 : 0;\n          HEAP8[this.ptr + 13 >> 0] = rethrown;\n        };\n        this.get_rethrown = function() {\n          return HEAP8[this.ptr + 13 >> 0] != 0;\n        };\n        this.init = function(type, destructor) {\n          this.set_adjusted_ptr(0);\n          this.set_type(type);\n          this.set_destructor(destructor);\n          this.set_refcount(0);\n          this.set_caught(false);\n          this.set_rethrown(false);\n        };\n        this.add_ref = function() {\n          var value = HEAP32[this.ptr >> 2];\n          HEAP32[this.ptr >> 2] = value + 1;\n        };\n        this.release_ref = function() {\n          var prev = HEAP32[this.ptr >> 2];\n          HEAP32[this.ptr >> 2] = prev - 1;\n          return prev === 1;\n        };\n        this.set_adjusted_ptr = function(adjustedPtr) {\n          HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n        };\n        this.get_adjusted_ptr = function() {\n          return HEAPU32[this.ptr + 16 >> 2];\n        };\n        this.get_exception_ptr = function() {\n          var isPointer = ___cxa_is_pointer_type(this.get_type());\n          if (isPointer) {\n            return HEAPU32[this.excPtr >> 2];\n          }\n          var adjusted = this.get_adjusted_ptr();\n          if (adjusted !== 0) return adjusted;\n          return this.excPtr;\n        };\n      }\n      function ___cxa_throw(ptr, type, destructor) {\n        var info = new ExceptionInfo(ptr);\n        info.init(type, destructor);\n        throw ptr;\n      }\n      function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {\n      }\n      function getShiftFromSize(size) {\n        switch (size) {\n          case 1:\n            return 0;\n          case 2:\n            return 1;\n          case 4:\n            return 2;\n          case 8:\n            return 3;\n          default:\n            throw new TypeError("Unknown type size: " + size);\n        }\n      }\n      function embind_init_charCodes() {\n        var codes = new Array(256);\n        for (var i2 = 0; i2 < 256; ++i2) {\n          codes[i2] = String.fromCharCode(i2);\n        }\n        embind_charCodes = codes;\n      }\n      var embind_charCodes = void 0;\n      function readLatin1String(ptr) {\n        var ret = "";\n        var c = ptr;\n        while (HEAPU8[c]) {\n          ret += embind_charCodes[HEAPU8[c++]];\n        }\n        return ret;\n      }\n      var awaitingDependencies = {};\n      var registeredTypes = {};\n      var typeDependencies = {};\n      var char_0 = 48;\n      var char_9 = 57;\n      function makeLegalFunctionName(name) {\n        if (void 0 === name) {\n          return "_unknown";\n        }\n        name = name.replace(/[^a-zA-Z0-9_]/g, "$");\n        var f = name.charCodeAt(0);\n        if (f >= char_0 && f <= char_9) {\n          return "_" + name;\n        }\n        return name;\n      }\n      function createNamedFunction(name, body) {\n        name = makeLegalFunctionName(name);\n        return { [name]: function() {\n          return body.apply(this, arguments);\n        } }[name];\n      }\n      function extendError(baseErrorType, errorName) {\n        var errorClass = createNamedFunction(errorName, function(message) {\n          this.name = errorName;\n          this.message = message;\n          var stack = new Error(message).stack;\n          if (stack !== void 0) {\n            this.stack = this.toString() + "\\n" + stack.replace(/^Error(:[^\\n]*)?\\n/, "");\n          }\n        });\n        errorClass.prototype = Object.create(baseErrorType.prototype);\n        errorClass.prototype.constructor = errorClass;\n        errorClass.prototype.toString = function() {\n          if (this.message === void 0) {\n            return this.name;\n          } else {\n            return this.name + ": " + this.message;\n          }\n        };\n        return errorClass;\n      }\n      var BindingError = void 0;\n      function throwBindingError(message) {\n        throw new BindingError(message);\n      }\n      var InternalError = void 0;\n      function throwInternalError(message) {\n        throw new InternalError(message);\n      }\n      function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n        myTypes.forEach(function(type) {\n          typeDependencies[type] = dependentTypes;\n        });\n        function onComplete(typeConverters2) {\n          var myTypeConverters = getTypeConverters(typeConverters2);\n          if (myTypeConverters.length !== myTypes.length) {\n            throwInternalError("Mismatched type converter count");\n          }\n          for (var i2 = 0; i2 < myTypes.length; ++i2) {\n            registerType(myTypes[i2], myTypeConverters[i2]);\n          }\n        }\n        var typeConverters = new Array(dependentTypes.length);\n        var unregisteredTypes = [];\n        var registered = 0;\n        dependentTypes.forEach((dt, i2) => {\n          if (registeredTypes.hasOwnProperty(dt)) {\n            typeConverters[i2] = registeredTypes[dt];\n          } else {\n            unregisteredTypes.push(dt);\n            if (!awaitingDependencies.hasOwnProperty(dt)) {\n              awaitingDependencies[dt] = [];\n            }\n            awaitingDependencies[dt].push(() => {\n              typeConverters[i2] = registeredTypes[dt];\n              ++registered;\n              if (registered === unregisteredTypes.length) {\n                onComplete(typeConverters);\n              }\n            });\n          }\n        });\n        if (0 === unregisteredTypes.length) {\n          onComplete(typeConverters);\n        }\n      }\n      function registerType(rawType, registeredInstance, options = {}) {\n        if (!("argPackAdvance" in registeredInstance)) {\n          throw new TypeError("registerType registeredInstance requires argPackAdvance");\n        }\n        var name = registeredInstance.name;\n        if (!rawType) {\n          throwBindingError(\'type "\' + name + \'" must have a positive integer typeid pointer\');\n        }\n        if (registeredTypes.hasOwnProperty(rawType)) {\n          if (options.ignoreDuplicateRegistrations) {\n            return;\n          } else {\n            throwBindingError("Cannot register type \'" + name + "\' twice");\n          }\n        }\n        registeredTypes[rawType] = registeredInstance;\n        delete typeDependencies[rawType];\n        if (awaitingDependencies.hasOwnProperty(rawType)) {\n          var callbacks = awaitingDependencies[rawType];\n          delete awaitingDependencies[rawType];\n          callbacks.forEach((cb) => cb());\n        }\n      }\n      function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n        var shift = getShiftFromSize(size);\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": function(wt) {\n          return !!wt;\n        }, "toWireType": function(destructors, o) {\n          return o ? trueValue : falseValue;\n        }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {\n          var heap;\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError("Unknown boolean type size: " + name);\n          }\n          return this["fromWireType"](heap[pointer >> shift]);\n        }, destructorFunction: null });\n      }\n      var emval_free_list = [];\n      var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];\n      function __emval_decref(handle) {\n        if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n          emval_handle_array[handle] = void 0;\n          emval_free_list.push(handle);\n        }\n      }\n      function count_emval_handles() {\n        var count = 0;\n        for (var i2 = 5; i2 < emval_handle_array.length; ++i2) {\n          if (emval_handle_array[i2] !== void 0) {\n            ++count;\n          }\n        }\n        return count;\n      }\n      function get_first_emval() {\n        for (var i2 = 5; i2 < emval_handle_array.length; ++i2) {\n          if (emval_handle_array[i2] !== void 0) {\n            return emval_handle_array[i2];\n          }\n        }\n        return null;\n      }\n      function init_emval() {\n        Module2["count_emval_handles"] = count_emval_handles;\n        Module2["get_first_emval"] = get_first_emval;\n      }\n      var Emval = { toValue: (handle) => {\n        if (!handle) {\n          throwBindingError("Cannot use deleted val. handle = " + handle);\n        }\n        return emval_handle_array[handle].value;\n      }, toHandle: (value) => {\n        switch (value) {\n          case void 0:\n            return 1;\n          case null:\n            return 2;\n          case true:\n            return 3;\n          case false:\n            return 4;\n          default: {\n            var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n            emval_handle_array[handle] = { refcount: 1, value };\n            return handle;\n          }\n        }\n      } };\n      function simpleReadValueFromPointer(pointer) {\n        return this["fromWireType"](HEAP32[pointer >> 2]);\n      }\n      function __embind_register_emval(rawType, name) {\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": function(handle) {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        }, "toWireType": function(destructors, value) {\n          return Emval.toHandle(value);\n        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });\n      }\n      function floatReadValueFromPointer(name, shift) {\n        switch (shift) {\n          case 2:\n            return function(pointer) {\n              return this["fromWireType"](HEAPF32[pointer >> 2]);\n            };\n          case 3:\n            return function(pointer) {\n              return this["fromWireType"](HEAPF64[pointer >> 3]);\n            };\n          default:\n            throw new TypeError("Unknown float type: " + name);\n        }\n      }\n      function __embind_register_float(rawType, name, size) {\n        var shift = getShiftFromSize(size);\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": function(value) {\n          return value;\n        }, "toWireType": function(destructors, value) {\n          return value;\n        }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name, shift), destructorFunction: null });\n      }\n      function runDestructors(destructors) {\n        while (destructors.length) {\n          var ptr = destructors.pop();\n          var del = destructors.pop();\n          del(ptr);\n        }\n      }\n      function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n        var argCount = argTypes.length;\n        if (argCount < 2) {\n          throwBindingError("argTypes array size mismatch! Must at least get return value and \'this\' types!");\n        }\n        argTypes[1] !== null && classType !== null;\n        var needsDestructorStack = false;\n        for (var i2 = 1; i2 < argTypes.length; ++i2) {\n          if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {\n            needsDestructorStack = true;\n            break;\n          }\n        }\n        var returns = argTypes[0].name !== "void";\n        var expectedArgCount = argCount - 2;\n        var argsWired = new Array(expectedArgCount);\n        var invokerFuncArgs = [];\n        var destructors = [];\n        return function() {\n          if (arguments.length !== expectedArgCount) {\n            throwBindingError("function " + humanName + " called with " + arguments.length + " arguments, expected " + expectedArgCount + " args!");\n          }\n          destructors.length = 0;\n          var thisWired;\n          invokerFuncArgs.length = 1;\n          invokerFuncArgs[0] = cppTargetFunc;\n          for (var i3 = 0; i3 < expectedArgCount; ++i3) {\n            argsWired[i3] = argTypes[i3 + 2]["toWireType"](destructors, arguments[i3]);\n            invokerFuncArgs.push(argsWired[i3]);\n          }\n          var rv = cppInvokerFunc.apply(null, invokerFuncArgs);\n          function onDone(rv2) {\n            if (needsDestructorStack) {\n              runDestructors(destructors);\n            } else {\n              for (var i4 = 2; i4 < argTypes.length; i4++) {\n                var param = i4 === 1 ? thisWired : argsWired[i4 - 2];\n                if (argTypes[i4].destructorFunction !== null) {\n                  argTypes[i4].destructorFunction(param);\n                }\n              }\n            }\n            if (returns) {\n              return argTypes[0]["fromWireType"](rv2);\n            }\n          }\n          return onDone(rv);\n        };\n      }\n      function ensureOverloadTable(proto, methodName, humanName) {\n        if (void 0 === proto[methodName].overloadTable) {\n          var prevFunc = proto[methodName];\n          proto[methodName] = function() {\n            if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n              throwBindingError("Function \'" + humanName + "\' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");\n            }\n            return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n          };\n          proto[methodName].overloadTable = [];\n          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n        }\n      }\n      function exposePublicSymbol(name, value, numArguments) {\n        if (Module2.hasOwnProperty(name)) {\n          if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {\n            throwBindingError("Cannot register public name \'" + name + "\' twice");\n          }\n          ensureOverloadTable(Module2, name, name);\n          if (Module2.hasOwnProperty(numArguments)) {\n            throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");\n          }\n          Module2[name].overloadTable[numArguments] = value;\n        } else {\n          Module2[name] = value;\n          if (void 0 !== numArguments) {\n            Module2[name].numArguments = numArguments;\n          }\n        }\n      }\n      function heap32VectorToArray(count, firstElement) {\n        var array = [];\n        for (var i2 = 0; i2 < count; i2++) {\n          array.push(HEAPU32[firstElement + i2 * 4 >> 2]);\n        }\n        return array;\n      }\n      function replacePublicSymbol(name, value, numArguments) {\n        if (!Module2.hasOwnProperty(name)) {\n          throwInternalError("Replacing nonexistant public symbol");\n        }\n        if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {\n          Module2[name].overloadTable[numArguments] = value;\n        } else {\n          Module2[name] = value;\n          Module2[name].argCount = numArguments;\n        }\n      }\n      function dynCallLegacy(sig, ptr, args) {\n        var f = Module2["dynCall_" + sig];\n        return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n      }\n      var wasmTableMirror = [];\n      function getWasmTableEntry(funcPtr) {\n        var func = wasmTableMirror[funcPtr];\n        if (!func) {\n          if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n          wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n        }\n        return func;\n      }\n      function dynCall(sig, ptr, args) {\n        if (sig.includes("j")) {\n          return dynCallLegacy(sig, ptr, args);\n        }\n        var rtn = getWasmTableEntry(ptr).apply(null, args);\n        return rtn;\n      }\n      function getDynCaller(sig, ptr) {\n        var argCache = [];\n        return function() {\n          argCache.length = 0;\n          Object.assign(argCache, arguments);\n          return dynCall(sig, ptr, argCache);\n        };\n      }\n      function embind__requireFunction(signature, rawFunction) {\n        signature = readLatin1String(signature);\n        function makeDynCaller() {\n          if (signature.includes("j")) {\n            return getDynCaller(signature, rawFunction);\n          }\n          return getWasmTableEntry(rawFunction);\n        }\n        var fp = makeDynCaller();\n        if (typeof fp != "function") {\n          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);\n        }\n        return fp;\n      }\n      var UnboundTypeError = void 0;\n      function getTypeName(type) {\n        var ptr = ___getTypeName(type);\n        var rv = readLatin1String(ptr);\n        _free(ptr);\n        return rv;\n      }\n      function throwUnboundTypeError(message, types) {\n        var unboundTypes = [];\n        var seen = {};\n        function visit(type) {\n          if (seen[type]) {\n            return;\n          }\n          if (registeredTypes[type]) {\n            return;\n          }\n          if (typeDependencies[type]) {\n            typeDependencies[type].forEach(visit);\n            return;\n          }\n          unboundTypes.push(type);\n          seen[type] = true;\n        }\n        types.forEach(visit);\n        throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));\n      }\n      function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {\n        var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n        name = readLatin1String(name);\n        rawInvoker = embind__requireFunction(signature, rawInvoker);\n        exposePublicSymbol(name, function() {\n          throwUnboundTypeError("Cannot call " + name + " due to unbound types", argTypes);\n        }, argCount - 1);\n        whenDependentTypesAreResolved([], argTypes, function(argTypes2) {\n          var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));\n          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n          return [];\n        });\n      }\n      function integerReadValueFromPointer(name, shift, signed) {\n        switch (shift) {\n          case 0:\n            return signed ? function readS8FromPointer(pointer) {\n              return HEAP8[pointer];\n            } : function readU8FromPointer(pointer) {\n              return HEAPU8[pointer];\n            };\n          case 1:\n            return signed ? function readS16FromPointer(pointer) {\n              return HEAP16[pointer >> 1];\n            } : function readU16FromPointer(pointer) {\n              return HEAPU16[pointer >> 1];\n            };\n          case 2:\n            return signed ? function readS32FromPointer(pointer) {\n              return HEAP32[pointer >> 2];\n            } : function readU32FromPointer(pointer) {\n              return HEAPU32[pointer >> 2];\n            };\n          default:\n            throw new TypeError("Unknown integer type: " + name);\n        }\n      }\n      function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n        name = readLatin1String(name);\n        var shift = getShiftFromSize(size);\n        var fromWireType = (value) => value;\n        if (minRange === 0) {\n          var bitshift = 32 - 8 * size;\n          fromWireType = (value) => value << bitshift >>> bitshift;\n        }\n        var isUnsignedType = name.includes("unsigned");\n        var checkAssertions = (value, toTypeName) => {\n        };\n        var toWireType;\n        if (isUnsignedType) {\n          toWireType = function(destructors, value) {\n            checkAssertions(value, this.name);\n            return value >>> 0;\n          };\n        } else {\n          toWireType = function(destructors, value) {\n            checkAssertions(value, this.name);\n            return value;\n          };\n        }\n        registerType(primitiveType, { name, "fromWireType": fromWireType, "toWireType": toWireType, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0), destructorFunction: null });\n      }\n      function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n        var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n        var TA = typeMapping[dataTypeIndex];\n        function decodeMemoryView(handle) {\n          handle = handle >> 2;\n          var heap = HEAPU32;\n          var size = heap[handle];\n          var data = heap[handle + 1];\n          return new TA(heap.buffer, data, size);\n        }\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });\n      }\n      function __embind_register_std_string(rawType, name) {\n        name = readLatin1String(name);\n        var stdStringIsUTF8 = name === "std::string";\n        registerType(rawType, { name, "fromWireType": function(value) {\n          var length = HEAPU32[value >> 2];\n          var payload = value + 4;\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            for (var i2 = 0; i2 <= length; ++i2) {\n              var currentBytePtr = payload + i2;\n              if (i2 == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === void 0) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i2 = 0; i2 < length; ++i2) {\n              a[i2] = String.fromCharCode(HEAPU8[payload + i2]);\n            }\n            str = a.join("");\n          }\n          _free(value);\n          return str;\n        }, "toWireType": function(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var length;\n          var valueIsOfTypeString = typeof value == "string";\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError("Cannot pass non-string to std::string");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[base >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i2 = 0; i2 < length; ++i2) {\n                var charCode = value.charCodeAt(i2);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError("String has UTF-16 code units that do not fit in 8 bits");\n                }\n                HEAPU8[ptr + i2] = charCode;\n              }\n            } else {\n              for (var i2 = 0; i2 < length; ++i2) {\n                HEAPU8[ptr + i2] = value[i2];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {\n          _free(ptr);\n        } });\n      }\n      function UTF16ToString(ptr, maxBytesToRead) {\n        var str = "";\n        for (var i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {\n          var codeUnit = HEAP16[ptr + i2 * 2 >> 1];\n          if (codeUnit == 0) break;\n          str += String.fromCharCode(codeUnit);\n        }\n        return str;\n      }\n      function stringToUTF16(str, outPtr, maxBytesToWrite) {\n        if (maxBytesToWrite === void 0) {\n          maxBytesToWrite = 2147483647;\n        }\n        if (maxBytesToWrite < 2) return 0;\n        maxBytesToWrite -= 2;\n        var startPtr = outPtr;\n        var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n        for (var i2 = 0; i2 < numCharsToWrite; ++i2) {\n          var codeUnit = str.charCodeAt(i2);\n          HEAP16[outPtr >> 1] = codeUnit;\n          outPtr += 2;\n        }\n        HEAP16[outPtr >> 1] = 0;\n        return outPtr - startPtr;\n      }\n      function lengthBytesUTF16(str) {\n        return str.length * 2;\n      }\n      function UTF32ToString(ptr, maxBytesToRead) {\n        var i2 = 0;\n        var str = "";\n        while (!(i2 >= maxBytesToRead / 4)) {\n          var utf32 = HEAP32[ptr + i2 * 4 >> 2];\n          if (utf32 == 0) break;\n          ++i2;\n          if (utf32 >= 65536) {\n            var ch = utf32 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          } else {\n            str += String.fromCharCode(utf32);\n          }\n        }\n        return str;\n      }\n      function stringToUTF32(str, outPtr, maxBytesToWrite) {\n        if (maxBytesToWrite === void 0) {\n          maxBytesToWrite = 2147483647;\n        }\n        if (maxBytesToWrite < 4) return 0;\n        var startPtr = outPtr;\n        var endPtr = startPtr + maxBytesToWrite - 4;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var codeUnit = str.charCodeAt(i2);\n          if (codeUnit >= 55296 && codeUnit <= 57343) {\n            var trailSurrogate = str.charCodeAt(++i2);\n            codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n          }\n          HEAP32[outPtr >> 2] = codeUnit;\n          outPtr += 4;\n          if (outPtr + 4 > endPtr) break;\n        }\n        HEAP32[outPtr >> 2] = 0;\n        return outPtr - startPtr;\n      }\n      function lengthBytesUTF32(str) {\n        var len = 0;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var codeUnit = str.charCodeAt(i2);\n          if (codeUnit >= 55296 && codeUnit <= 57343) ++i2;\n          len += 4;\n        }\n        return len;\n      }\n      function __embind_register_std_wstring(rawType, charSize, name) {\n        name = readLatin1String(name);\n        var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n        if (charSize === 2) {\n          decodeString = UTF16ToString;\n          encodeString = stringToUTF16;\n          lengthBytesUTF = lengthBytesUTF16;\n          getHeap = () => HEAPU16;\n          shift = 1;\n        } else if (charSize === 4) {\n          decodeString = UTF32ToString;\n          encodeString = stringToUTF32;\n          lengthBytesUTF = lengthBytesUTF32;\n          getHeap = () => HEAPU32;\n          shift = 2;\n        }\n        registerType(rawType, { name, "fromWireType": function(value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i2 = 0; i2 <= length; ++i2) {\n            var currentBytePtr = value + 4 + i2 * charSize;\n            if (i2 == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === void 0) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        }, "toWireType": function(destructors, value) {\n          if (!(typeof value == "string")) {\n            throwBindingError("Cannot pass non-string to C++ string type " + name);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {\n          _free(ptr);\n        } });\n      }\n      function __embind_register_void(rawType, name) {\n        name = readLatin1String(name);\n        registerType(rawType, { isVoid: true, name, "argPackAdvance": 0, "fromWireType": function() {\n          return void 0;\n        }, "toWireType": function(destructors, o) {\n          return void 0;\n        } });\n      }\n      var emval_symbols = {};\n      function getStringOrSymbol(address) {\n        var symbol = emval_symbols[address];\n        if (symbol === void 0) {\n          return readLatin1String(address);\n        }\n        return symbol;\n      }\n      function emval_get_global() {\n        if (typeof globalThis == "object") {\n          return globalThis;\n        }\n        function testGlobal(obj) {\n          obj["$$$embind_global$$$"] = obj;\n          var success = typeof $$$embind_global$$$ == "object" && obj["$$$embind_global$$$"] == obj;\n          if (!success) {\n            delete obj["$$$embind_global$$$"];\n          }\n          return success;\n        }\n        if (typeof $$$embind_global$$$ == "object") {\n          return $$$embind_global$$$;\n        }\n        if (typeof global == "object" && testGlobal(global)) {\n          $$$embind_global$$$ = global;\n        } else if (typeof self == "object" && testGlobal(self)) {\n          $$$embind_global$$$ = self;\n        }\n        if (typeof $$$embind_global$$$ == "object") {\n          return $$$embind_global$$$;\n        }\n        throw Error("unable to get global object.");\n      }\n      function __emval_get_global(name) {\n        if (name === 0) {\n          return Emval.toHandle(emval_get_global());\n        } else {\n          name = getStringOrSymbol(name);\n          return Emval.toHandle(emval_get_global()[name]);\n        }\n      }\n      function __emval_incref(handle) {\n        if (handle > 4) {\n          emval_handle_array[handle].refcount += 1;\n        }\n      }\n      function requireRegisteredType(rawType, humanName) {\n        var impl = registeredTypes[rawType];\n        if (void 0 === impl) {\n          throwBindingError(humanName + " has unknown type " + getTypeName(rawType));\n        }\n        return impl;\n      }\n      function craftEmvalAllocator(argCount) {\n        var argsList = new Array(argCount + 1);\n        return function(constructor, argTypes, args) {\n          argsList[0] = constructor;\n          for (var i2 = 0; i2 < argCount; ++i2) {\n            var argType = requireRegisteredType(HEAPU32[argTypes + i2 * 4 >> 2], "parameter " + i2);\n            argsList[i2 + 1] = argType["readValueFromPointer"](args);\n            args += argType["argPackAdvance"];\n          }\n          var obj = new (constructor.bind.apply(constructor, argsList))();\n          return Emval.toHandle(obj);\n        };\n      }\n      var emval_newers = {};\n      function __emval_new(handle, argCount, argTypes, args) {\n        handle = Emval.toValue(handle);\n        var newer = emval_newers[argCount];\n        if (!newer) {\n          newer = craftEmvalAllocator(argCount);\n          emval_newers[argCount] = newer;\n        }\n        return newer(handle, argTypes, args);\n      }\n      function _abort() {\n        abort("");\n      }\n      function _emscripten_memcpy_big(dest, src, num) {\n        HEAPU8.copyWithin(dest, src, src + num);\n      }\n      function getHeapMax() {\n        return 2147483648;\n      }\n      function emscripten_realloc_buffer(size) {\n        var b = wasmMemory.buffer;\n        try {\n          wasmMemory.grow(size - b.byteLength + 65535 >>> 16);\n          updateMemoryViews();\n          return 1;\n        } catch (e) {\n        }\n      }\n      function _emscripten_resize_heap(requestedSize) {\n        var oldSize = HEAPU8.length;\n        requestedSize = requestedSize >>> 0;\n        var maxHeapSize = getHeapMax();\n        if (requestedSize > maxHeapSize) {\n          return false;\n        }\n        let alignUp = (x2, multiple) => x2 + (multiple - x2 % multiple) % multiple;\n        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n          var replacement = emscripten_realloc_buffer(newSize);\n          if (replacement) {\n            return true;\n          }\n        }\n        return false;\n      }\n      embind_init_charCodes();\n      BindingError = Module2["BindingError"] = extendError(Error, "BindingError");\n      InternalError = Module2["InternalError"] = extendError(Error, "InternalError");\n      init_emval();\n      UnboundTypeError = Module2["UnboundTypeError"] = extendError(Error, "UnboundTypeError");\n      var wasmImports = { "n": ___cxa_throw, "o": __embind_register_bigint, "l": __embind_register_bool, "r": __embind_register_emval, "k": __embind_register_float, "c": __embind_register_function, "b": __embind_register_integer, "a": __embind_register_memory_view, "g": __embind_register_std_string, "f": __embind_register_std_wstring, "m": __embind_register_void, "d": __emval_decref, "e": __emval_get_global, "i": __emval_incref, "h": __emval_new, "j": _abort, "q": _emscripten_memcpy_big, "p": _emscripten_resize_heap };\n      createWasm();\n      var _malloc = function() {\n        return (_malloc = Module2["asm"]["u"]).apply(null, arguments);\n      };\n      var _free = function() {\n        return (_free = Module2["asm"]["v"]).apply(null, arguments);\n      };\n      var ___getTypeName = Module2["___getTypeName"] = function() {\n        return (___getTypeName = Module2["___getTypeName"] = Module2["asm"]["w"]).apply(null, arguments);\n      };\n      Module2["__embind_initialize_bindings"] = function() {\n        return (Module2["__embind_initialize_bindings"] = Module2["asm"]["x"]).apply(null, arguments);\n      };\n      var ___cxa_is_pointer_type = function() {\n        return (___cxa_is_pointer_type = Module2["asm"]["z"]).apply(null, arguments);\n      };\n      var calledRun;\n      dependenciesFulfilled = function runCaller() {\n        if (!calledRun) run();\n        if (!calledRun) dependenciesFulfilled = runCaller;\n      };\n      function run() {\n        if (runDependencies > 0) {\n          return;\n        }\n        preRun();\n        if (runDependencies > 0) {\n          return;\n        }\n        function doRun() {\n          if (calledRun) return;\n          calledRun = true;\n          Module2["calledRun"] = true;\n          if (ABORT) return;\n          initRuntime();\n          readyPromiseResolve(Module2);\n          if (Module2["onRuntimeInitialized"]) Module2["onRuntimeInitialized"]();\n          postRun();\n        }\n        if (Module2["setStatus"]) {\n          Module2["setStatus"]("Running...");\n          setTimeout(function() {\n            setTimeout(function() {\n              Module2["setStatus"]("");\n            }, 1);\n            doRun();\n          }, 1);\n        } else {\n          doRun();\n        }\n      }\n      if (Module2["preInit"]) {\n        if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];\n        while (Module2["preInit"].length > 0) {\n          Module2["preInit"].pop()();\n        }\n      }\n      run();\n      return Module2.ready;\n    };\n  })();\n  let emscriptenModule;\n  async function init(module, moduleOptionOverrides) {\n    let actualModule = module;\n    let actualOptions = moduleOptionOverrides;\n    if (arguments.length === 1 && !(module instanceof WebAssembly.Module)) {\n      actualModule = void 0;\n      actualOptions = module;\n    }\n    emscriptenModule = initEmscriptenModule(Module, actualModule, actualOptions);\n  }\n  async function decode(buffer) {\n    if (!emscriptenModule)\n      init();\n    const module = await emscriptenModule;\n    const result = module.decode(buffer);\n    if (!result)\n      throw new Error("Decoding error");\n    return result;\n  }\n  async function unpackPcSogs(fileBytes, extraFiles) {\n    const json = JSON.parse(new TextDecoder().decode(fileBytes));\n    if (json.quats.encoding !== "quaternion_packed") {\n      throw new Error("Unsupported quaternion encoding");\n    }\n    const numSplats = json.means.shape[0];\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    const means = await Promise.all([\n      decodeImageRgba(extraFiles[json.means.files[0]]),\n      decodeImageRgba(extraFiles[json.means.files[1]])\n    ]);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;\n      const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;\n      const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;\n      let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;\n      let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;\n      let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\n      x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\n      y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\n      z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);\n      setPackedSplatCenter(packedArray, i2, x2, y, z);\n    }\n    const scales = await decodeImageRgba(extraFiles[json.scales.files[0]]);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const fx = scales[i4 + 0] / 255;\n      const fy = scales[i4 + 1] / 255;\n      const fz = scales[i4 + 2] / 255;\n      const x2 = json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * fx;\n      const y = json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * fy;\n      const z = json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * fz;\n      setPackedSplatScales(packedArray, i2, Math.exp(x2), Math.exp(y), Math.exp(z));\n    }\n    const quats = await decodeImageRgba(extraFiles[json.quats.files[0]]);\n    const SQRT2 = Math.sqrt(2);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const r0 = (quats[i4 + 0] / 255 - 0.5) * SQRT2;\n      const r1 = (quats[i4 + 1] / 255 - 0.5) * SQRT2;\n      const r2 = (quats[i4 + 2] / 255 - 0.5) * SQRT2;\n      const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n      const rOrder = quats[i4 + 3] - 252;\n      const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n      const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n      const quatZ = rOrder <= 2 ? r2 : rr;\n      const quatW = rOrder === 0 ? rr : r0;\n      setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\n    }\n    const sh0 = await decodeImageRgba(extraFiles[json.sh0.files[0]]);\n    const SH_C02 = 0.28209479177387814;\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const f0 = sh0[i4 + 0] / 255;\n      const f1 = sh0[i4 + 1] / 255;\n      const f2 = sh0[i4 + 2] / 255;\n      const f3 = sh0[i4 + 3] / 255;\n      const dc0 = json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * f0;\n      const dc1 = json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * f1;\n      const dc2 = json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * f2;\n      const opa = json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * f3;\n      const r = SH_C02 * dc0 + 0.5;\n      const g = SH_C02 * dc1 + 0.5;\n      const b = SH_C02 * dc2 + 0.5;\n      const a = 1 / (1 + Math.exp(-opa));\n      setPackedSplatRgba(packedArray, i2, r, g, b, a);\n    }\n    if (json.shN) {\n      extra.sh1 = new Uint32Array(numSplats * 2);\n      extra.sh2 = new Uint32Array(numSplats * 4);\n      extra.sh3 = new Uint32Array(numSplats * 4);\n      const sh1 = new Float32Array(9);\n      const sh2 = new Float32Array(15);\n      const sh3 = new Float32Array(21);\n      const [centroids, labels] = await Promise.all([\n        decodeImage(extraFiles[json.shN.files[0]]),\n        decodeImage(extraFiles[json.shN.files[1]])\n      ]);\n      for (let i2 = 0; i2 < numSplats; ++i2) {\n        const i4 = i2 * 4;\n        const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);\n        const col = (label & 63) * 15;\n        const row = label >>> 6;\n        const offset = row * centroids.width + col;\n        for (let d = 0; d < 3; ++d) {\n          for (let k = 0; k < 3; ++k) {\n            sh1[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + k) * 4 + d] / 255;\n          }\n          for (let k = 0; k < 5; ++k) {\n            sh2[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + 3 + k) * 4 + d] / 255;\n          }\n          for (let k = 0; k < 7; ++k) {\n            sh3[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + 8 + k) * 4 + d] / 255;\n          }\n        }\n        encodeSh1Rgb(extra.sh1, i2, sh1);\n        encodeSh2Rgb(extra.sh2, i2, sh2);\n        encodeSh3Rgb(extra.sh3, i2, sh3);\n      }\n    }\n    return { packedArray, numSplats, extra };\n  }\n  async function decodeImage(fileBytes) {\n    const { data: rgba, width, height } = await decode(fileBytes);\n    return { rgba, width, height };\n  }\n  async function decodeImageRgba(fileBytes) {\n    const { rgba } = await decodeImage(fileBytes);\n    return rgba;\n  }\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = "";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // "vertex" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = "";\n      const headerTerminator = "end_header\\n";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error("Failed to read header");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split("\\n").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== "ply") {\n            throw new Error("Invalid PLY header");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(" ");\n        switch (fields[0]) {\n          case "format":\n            if (fields[1] === "binary_little_endian") {\n              this.littleEndian = true;\n            } else if (fields[1] === "binary_big_endian") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\n            }\n            if (fields[2] !== "1.0") {\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\n            }\n            break;\n          case "end_header":\n            break;\n          case "comment":\n            this.comments.push(trimmedLine.slice("comment ".length));\n            break;\n          case "element": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case "property":\n            if (curElement == null) {\n              throw new Error("Property must be inside an element");\n            }\n            if (fields[1] === "list") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No data to parse");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = {};\n        const parsers = [];\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            item[propertyName] = 0;\n            parsers.push(() => {\n              item[propertyName] = PARSE_FIELD[property.type](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            item[propertyName] = [];\n            parsers.push(() => {\n              const list = item[propertyName];\n              list.length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              for (let i2 = 0; i2 < list.length; i2++) {\n                list[i2] = PARSE_FIELD[property.type](\n                  data,\n                  offset,\n                  this.littleEndian\n                );\n                offset += FIELD_BYTES[property.type];\n              }\n            });\n          }\n        }\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error("No vertex element found");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${k + d * num_f_rest / 3}`)\n        );\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${3 + k + d * num_f_rest / 3}`)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${8 + k + d * num_f_rest / 3}`)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error("Missing sh1");\n        }\n        for (const [i2, key] of sh1Props.entries()) {\n          sh1[i2] = item[key] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (const [i2, key] of sh2Props.entries()) {\n            sh2[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (const [i2, key] of sh3Props.entries()) {\n            sh3[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\n          throw new Error("Missing PLY chunk properties");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === "sh") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error("Missing PLY chunk");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\n          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === "chunk") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error("Missing PLY properties: x, y, z");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            if (sh1) {\n              for (const [i2, key] of sh1Props.entries()) {\n                sh1[i2] = item[key];\n              }\n            }\n            if (sh2) {\n              for (const [i2, key] of sh2Props.entries()) {\n                sh2[i2] = item[key];\n              }\n            }\n            if (sh3) {\n              for (const [i2, key] of sh3Props.entries()) {\n                sh3[i2] = item[key];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No parsed data");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error("Invalid RGBA array length");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === "vertex";\n        if (isVertex) {\n          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {\n            if (!properties[name] || properties[name].type !== "float") {\n              throw new Error(`Can\'t injectRgba due to property: ${name}`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {\n                const component = Number.parseInt(\n                  propertyName.slice("f_dc_".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === "opacity") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[`f_rest_${num_f_rest}`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\n    }\n    return numSh;\n  }\n  const Gsplat = { type: "Gsplat" };\n  const TPackedSplats = { type: "PackedSplats" };\n  const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });\n  const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });\n  const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\n  const combineGsplat = ({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x: x2,\n    y,\n    z,\n    r,\n    g,\n    b\n  }) => {\n    return new CombineGsplat({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    });\n  };\n  const transformGsplat = (gsplat, {\n    scale,\n    rotate,\n    translate,\n    recolor\n  }) => {\n    return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\n  };\n  const defineGsplat = unindent(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`);\n  const definePackedSplats = unindent(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`);\n  const defineReadPackedSplat = unindent(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\n  class ReadPackedSplat extends Dyno {\n    constructor({\n      packedSplats,\n      index\n    }) {\n      super({\n        inTypes: { packedSplats: TPackedSplats, index: "int" },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2) {\n            statements = unindentLines(`\n            if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${index2}, ${gsplat})) {\n              bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n              ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${gsplat}.flags = 0u;\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class ReadPackedSplatRange extends Dyno {\n    constructor({\n      packedSplats,\n      index,\n      base,\n      count\n    }) {\n      super({\n        inTypes: {\n          packedSplats: TPackedSplats,\n          index: "int",\n          base: "int",\n          count: "int"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index, base, count },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2 && base2 && count2) {\n            statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n            if ((${index2} >= ${base2}) && (${index2} < (${base2} + ${count2}))) {\n              if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${index2}, ${gsplat})) {\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class SplitGsplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        outTypes: {\n          flags: "uint",\n          active: "bool",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: gsplat2 } = inputs;\n          const {\n            flags,\n            active,\n            index,\n            center,\n            scales,\n            quaternion,\n            rgba,\n            rgb,\n            opacity,\n            x: x2,\n            y,\n            z,\n            r,\n            g,\n            b\n          } = outputs;\n          return [\n            !flags ? null : `${flags} = ${gsplat2 ? `${gsplat2}.flags` : "0u"};`,\n            !active ? null : `${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : "0u"});`,\n            !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : "0"};`,\n            !center ? null : `${center} = ${gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)"};`,\n            !scales ? null : `${scales} = ${gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)"};`,\n            !quaternion ? null : `${quaternion} = ${gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};`,\n            !rgba ? null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};`,\n            !rgb ? null : `${rgb} = ${gsplat2 ? `${gsplat2}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};`,\n            !opacity ? null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : "0.0"};`,\n            !x2 ? null : `${x2} = ${gsplat2 ? `${gsplat2}.center.x` : "0.0"};`,\n            !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : "0.0"};`,\n            !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : "0.0"};`,\n            !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : "0.0"};`,\n            !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : "0.0"};`,\n            !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : "0.0"};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class CombineGsplat extends Dyno {\n    constructor({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          flags: "uint",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: {\n          gsplat,\n          flags,\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba,\n          rgb,\n          opacity,\n          x: x2,\n          y,\n          z,\n          r,\n          g,\n          b\n        },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: outGsplat } = outputs;\n          if (!outGsplat) {\n            return [];\n          }\n          const {\n            gsplat: gsplat2,\n            flags: flags2,\n            index: index2,\n            center: center2,\n            scales: scales2,\n            quaternion: quaternion2,\n            rgba: rgba2,\n            rgb: rgb2,\n            opacity: opacity2,\n            x: x22,\n            y: y2,\n            z: z2,\n            r: r2,\n            g: g2,\n            b: b2\n          } = inputs;\n          return [\n            `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? `${gsplat2}.flags` : "0u")};`,\n            `${outGsplat}.index = ${index2 ?? (gsplat2 ? `${gsplat2}.index` : "0")};`,\n            `${outGsplat}.center = ${center2 ?? (gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.quaternion = ${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,\n            `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,\n            !rgb2 ? null : `${outGsplat}.rgba.rgb = ${rgb2};`,\n            !opacity2 ? null : `${outGsplat}.rgba.a = ${opacity2};`,\n            !x22 ? null : `${outGsplat}.center.x = ${x22};`,\n            !y2 ? null : `${outGsplat}.center.y = ${y2};`,\n            !z2 ? null : `${outGsplat}.center.z = ${z2};`,\n            !r2 ? null : `${outGsplat}.rgba.r = ${r2};`,\n            !g2 ? null : `${outGsplat}.rgba.g = ${g2};`,\n            !b2 ? null : `${outGsplat}.rgba.b = ${b2};`\n          ].filter(Boolean);\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  unindent(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);\n  class TransformGsplat extends Dyno {\n    constructor({\n      gsplat,\n      scale,\n      rotate,\n      translate,\n      recolor\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          scale: "float",\n          rotate: "vec4",\n          translate: "vec3",\n          recolor: "vec4"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { gsplat, scale, rotate, translate, recolor },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs, compile }) => {\n          const { gsplat: gsplat2 } = outputs;\n          if (!gsplat2 || !inputs.gsplat) {\n            return [];\n          }\n          const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;\n          const indent = compile.indent;\n          const statements = [\n            `${gsplat2} = ${inputs.gsplat};`,\n            `if (isGsplatActive(${gsplat2}.flags)) {`,\n            scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, ${gsplat2}.center);` : null,\n            translate2 ? `${indent}${gsplat2}.center += ${translate2};` : null,\n            scale2 ? `${indent}${gsplat2}.scales *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, ${gsplat2}.quaternion);` : null,\n            recolor2 ? `${indent}${gsplat2}.rgba *= ${recolor2};` : null,\n            "}"\n          ].filter(Boolean);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  const outputPackedSplat = (gsplat) => new OutputPackedSplat({ gsplat });\n  class OutputPackedSplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { output } = outputs;\n          if (!output) {\n            return [];\n          }\n          const { gsplat: gsplat2 } = inputs;\n          if (gsplat2) {\n            return unindentLines(`\n            if (isGsplatActive(${gsplat2}.flags)) {\n              ${output} = packSplat(${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba);\n            } else {\n              ${output} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `);\n          }\n          return [`${output} = uvec4(0u, 0u, 0u, 0u);`];\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "output");\n    }\n  }\n  class OutputRgba8 extends Dyno {\n    constructor({ rgba8 }) {\n      super({\n        inTypes: { rgba8: "vec4" },\n        inputs: { rgba8 },\n        statements: ({ inputs, outputs }) => [\n          `target = ${inputs.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`\n        ]\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "rgba8");\n    }\n  }\n  class DynoUniform extends Dyno {\n    constructor({\n      key,\n      type,\n      count,\n      value,\n      update,\n      globals\n    }) {\n      key = key ?? "value";\n      super({\n        outTypes: { [key]: type },\n        update: () => {\n          if (update) {\n            const value2 = update(this.value);\n            if (value2 !== void 0) {\n              this.value = value2;\n            }\n          }\n          this.uniform.value = this.value;\n        },\n        generate: ({ inputs, outputs }) => {\n          const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];\n          const uniforms = {};\n          const name = outputs[key];\n          if (name) {\n            allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);\n            uniforms[name] = this.uniform;\n          }\n          return { globals: allGlobals, uniforms };\n        }\n      });\n      this.type = type;\n      this.count = count;\n      this.value = value;\n      this.uniform = { value };\n      this.outKey = key;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class DynoInt extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "int", value, update });\n    }\n  }\n  class DynoFloat extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "float", value, update });\n    }\n  }\n  class DynoVec3 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec3", value, update });\n    }\n  }\n  class DynoVec4 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec4", value, update });\n    }\n  }\n  class DynoUsampler2DArray extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "usampler2DArray", value, update });\n    }\n  }\n  class DynoProgram {\n    constructor({\n      graph,\n      inputs,\n      outputs,\n      template\n    }) {\n      this.graph = graph;\n      this.template = template;\n      this.inputs = inputs ?? {};\n      this.outputs = outputs ?? {};\n      const compile = new Compilation({ indent: this.template.indent });\n      for (const key in this.outputs) {\n        if (this.outputs[key]) {\n          compile.declares.add(this.outputs[key]);\n        }\n      }\n      const statements = graph.compile({\n        inputs: this.inputs,\n        outputs: this.outputs,\n        compile\n      });\n      this.shader = template.generate({ globals: compile.globals, statements });\n      this.uniforms = compile.uniforms;\n      this.updaters = compile.updaters;\n    }\n    prepareMaterial() {\n      return getMaterial(this);\n    }\n    update() {\n      for (const updater of this.updaters) {\n        updater();\n      }\n    }\n  }\n  class DynoProgramTemplate {\n    constructor(template) {\n      const globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\n      const statements = template.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n      if (!globals || !statements) {\n        throw new Error(\n          "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"\n        );\n      }\n      this.before = template.substring(0, globals.index);\n      this.between = template.substring(\n        globals.index + globals[0].length,\n        statements.index\n      );\n      this.after = template.substring(\n        statements.index + statements[0].length\n      );\n      this.indent = statements[1];\n    }\n    generate({\n      globals,\n      statements\n    }) {\n      return this.before + Array.from(globals).join("\\n\\n") + this.between + statements.map((s) => this.indent + s).join("\\n") + this.after;\n    }\n  }\n  const programMaterial = /* @__PURE__ */ new Map();\n  function getMaterial(program) {\n    let material = programMaterial.get(program);\n    if (material) {\n      return material;\n    }\n    material = new RawShaderMaterial({\n      glslVersion: GLSL3,\n      vertexShader: IDENT_VERTEX_SHADER,\n      fragmentShader: program.shader,\n      uniforms: program.uniforms\n    });\n    programMaterial.set(program, material);\n    return material;\n  }\n  function addOutputType(a, b, operation = "add") {\n    const error = () => {\n      throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n    };\n    if (a === b) return a;\n    if (a === "int") {\n      if (isIntType(b)) return b;\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return a;\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return b;\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return a;\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return b;\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return a;\n      error();\n    }\n    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n  }\n  function subOutputType(a, b) {\n    return addOutputType(a, b, "sub");\n  }\n  function mulOutputType(a, b) {\n    const error = () => {\n      throw new Error(`Invalid mul types: ${a}, ${b}`);\n    };\n    const result = (value) => value;\n    if (a === "int") {\n      if (isIntType(b)) return result(b);\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return result(a);\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return result(b);\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return result(a);\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return result(b);\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return result(a);\n      error();\n    }\n    if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n      if (a === b) return result(a);\n      error();\n    }\n    if (a === "vec2") {\n      if (b === "vec2" || isMat2(b)) return result("vec2");\n      if (b === "mat3x2") return result("vec3");\n      if (b === "mat4x2") return result("vec4");\n      error();\n    }\n    if (a === "vec3") {\n      if (b === "mat2x3") return result("vec2");\n      if (b === "vec3" || isMat3(b)) return result("vec3");\n      if (b === "mat4x3") return result("vec4");\n      error();\n    }\n    if (a === "vec4") {\n      if (b === "mat2x4") return result("vec2");\n      if (b === "mat3x4") return result("vec3");\n      if (b === "vec4" || isMat4(b)) return result("vec4");\n      error();\n    }\n    if (b === "vec2") {\n      if (isMat2(a)) return result("vec2");\n      if (a === "mat2x3") return result("vec3");\n      if (a === "mat2x4") return result("vec4");\n      error();\n    }\n    if (b === "vec3") {\n      if (a === "mat3x2") return result("vec2");\n      if (isMat3(a)) return result("vec3");\n      if (a === "mat3x4") return result("vec4");\n      error();\n    }\n    if (b === "vec4") {\n      if (a === "mat4x2") return result("vec2");\n      if (a === "mat4x3") return result("vec3");\n      if (isMat4(a)) return result("vec4");\n      error();\n    }\n    if (isMat2(a)) {\n      if (isMat2(b)) return result("mat2");\n      if (b === "mat3x2") return result("mat3x2");\n      if (b === "mat4x2") return result("mat4x2");\n      error();\n    }\n    if (a === "mat2x3") {\n      if (isMat2(b)) return result("mat2x3");\n      if (b === "mat3x2") return result("mat3");\n      if (b === "mat4x2") return result("mat4x3");\n      error();\n    }\n    if (a === "mat2x4") {\n      if (isMat2(b)) return result("mat2x4");\n      if (b === "mat3x2") return result("mat3x4");\n      if (b === "mat4x2") return result("mat4");\n      error();\n    }\n    if (a === "mat3x2") {\n      if (b === "mat2x3") return result("mat2");\n      if (isMat3(b)) return result("mat3x2");\n      if (b === "mat4x3") return result("mat4x2");\n      error();\n    }\n    if (isMat3(a)) {\n      if (b === "mat2x3") return result("mat2x3");\n      if (isMat3(b)) return result("mat3");\n      if (b === "mat4x3") return result("mat4x3");\n      error();\n    }\n    if (a === "mat3x4") {\n      if (b === "mat2x3") return result("mat2x4");\n      if (isMat3(b)) return result("mat3x4");\n      if (b === "mat4x3") return result("mat4");\n      error();\n    }\n    if (a === "mat4x2") {\n      if (b === "mat2x4") return result("mat2");\n      if (b === "mat3x4") return result("mat3x2");\n      if (isMat4(b)) return result("mat4x2");\n      error();\n    }\n    if (a === "mat4x3") {\n      if (b === "mat2x4") return result("mat2x3");\n      if (b === "mat3x4") return result("mat3");\n      if (isMat4(b)) return result("mat4x3");\n      error();\n    }\n    if (isMat4(a)) {\n      if (b === "mat2x4") return result("mat2x4");\n      if (b === "mat3x4") return result("mat3x4");\n      if (isMat4(b)) return result("mat4");\n      error();\n    }\n    throw new Error(`Invalid mul types: ${a}, ${b}`);\n  }\n  const add = (a, b) => new Add({ a, b });\n  const sub = (a, b) => new Sub({ a, b });\n  const mul = (a, b) => new Mul({ a, b });\n  class Add extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "sum", outTypeFunc: addOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];\n      };\n    }\n  }\n  class Sub extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "difference", outTypeFunc: subOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\n      };\n    }\n  }\n  class Mul extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "product", outTypeFunc: mulOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];\n      };\n    }\n  }\n  const normalize = (a) => new Normalize({ a });\n  const extendVec = (a, b) => new ExtendVec({ a, b });\n  class Normalize extends UnaryOp {\n    constructor({ a }) {\n      super({ a, outTypeFunc: (aType) => aType, outKey: "normalize" });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.normalize} = normalize(${inputs.a});`\n      ];\n    }\n  }\n  function extendVecOutputType(type) {\n    if (type === "float") return "vec2";\n    if (type === "vec2") return "vec3";\n    if (type === "vec3") return "vec4";\n    throw new Error("Invalid type");\n  }\n  class ExtendVec extends BinaryOp {\n    constructor({ a, b }) {\n      const type = valType(a);\n      const outType = extendVecOutputType(type);\n      super({ a, b, outKey: "extend", outTypeFunc: () => outType });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`\n      ];\n    }\n  }\n  const transformPos = (position, {\n    scale,\n    scales,\n    rotate,\n    translate\n  }) => {\n    return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;\n  };\n  const transformDir = (dir, {\n    scale,\n    scales,\n    rotate\n  }) => {\n    return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\n  };\n  class TransformPosition extends Dyno {\n    constructor({\n      position,\n      scale,\n      scales,\n      rotate,\n      translate\n    }) {\n      super({\n        inTypes: {\n          position: "vec3",\n          scale: "float",\n          scales: "vec3",\n          rotate: "vec4",\n          translate: "vec3"\n        },\n        outTypes: { position: "vec3" },\n        inputs: { position, scale, scales, rotate, translate },\n        statements: ({ inputs, outputs }) => {\n          const { position: position2 } = outputs;\n          if (!position2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;\n          return [\n            `${position2} = ${inputs.position ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${position2} *= ${scale2};`,\n            !scales2 ? null : `${position2} *= ${scales2};`,\n            !rotate2 ? null : `${position2} = quatVec(${rotate2}, ${position2});`,\n            !translate2 ? null : `${position2} += ${translate2};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class TransformDir extends Dyno {\n    constructor({\n      dir,\n      scale,\n      scales,\n      rotate\n    }) {\n      super({\n        inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },\n        outTypes: { dir: "vec3" },\n        inputs: { dir, scale, scales, rotate },\n        statements: ({ inputs, outputs }) => {\n          const { dir: dir2 } = outputs;\n          if (!dir2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n          return [\n            `${dir2} = ${inputs.dir ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${dir2} *= ${scale2};`,\n            !scales2 ? null : `${dir2} *= ${scales2};`,\n            !rotate2 ? null : `${dir2} = quatVec(${rotate2}, ${dir2});`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  var computeUvec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        produceSplat(index);\\n    } else {\\n        target = uvec4(0u, 0u, 0u, 0u);\\n    }\\n}";\n  const _PackedSplats = class _PackedSplats {\n    constructor(options = {}) {\n      this.maxSplats = 0;\n      this.numSplats = 0;\n      this.packedArray = null;\n      this.isInitialized = false;\n      this.target = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.extra = {};\n      this.dyno = new DynoPackedSplats({ packedSplats: this });\n      this.initialized = Promise.resolve(this);\n      this.reinitialize(options);\n    }\n    reinitialize(options) {\n      this.isInitialized = false;\n      if (options.url || options.fileBytes || options.construct) {\n        this.initialized = this.asyncInitialize(options).then(() => {\n          this.isInitialized = true;\n          return this;\n        });\n      } else {\n        this.initialize(options);\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n      }\n    }\n    initialize(options) {\n      if (options.packedArray) {\n        this.packedArray = options.packedArray;\n        this.maxSplats = Math.floor(this.packedArray.length / 4);\n        this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.numSplats = Math.min(\n          this.maxSplats,\n          options.numSplats ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.maxSplats = options.maxSplats ?? 0;\n        this.numSplats = 0;\n      }\n      this.extra = options.extra ?? {};\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, construct } = options;\n      if (url) {\n        const loader = new SplatLoader();\n        loader.packedSplats = this;\n        await loader.loadAsync(url);\n      } else if (fileBytes) {\n        const unpacked = await unpackSplats({\n          input: fileBytes,\n          fileType: options.fileType,\n          pathOrUrl: options.fileName ?? url\n        });\n        this.initialize(unpacked);\n      }\n      if (construct) {\n        const maybePromise = construct(this);\n        if (maybePromise instanceof Promise) {\n          await maybePromise;\n        }\n      }\n    }\n    // Call this when you are finished with the PackedSplats and want to free\n    // any buffers it holds.\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensures that this.packedArray can fit numSplats Gsplats. If it\'s too small,\n    // resize exponentially and copy over the original data.\n    //\n    // Typically you don\'t need to call this, because calling this.setSplat(index, ...)\n    // and this.pushSplat(...) will automatically call ensureSplats() so we have\n    // enough splats.\n    ensureSplats(numSplats) {\n      const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (\n        // Grow exponentially to avoid frequent reallocations\n        Math.max(numSplats, 2 * this.maxSplats)\n      );\n      const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\n      if (!this.packedArray || targetSize > currentSize) {\n        this.maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(this.maxSplats * 4);\n        if (this.packedArray) {\n          newArray.set(this.packedArray);\n        }\n        this.packedArray = newArray;\n      }\n      return this.packedArray;\n    }\n    // Ensure the extra array for the given level is large enough to hold numSplats\n    ensureSplatsSh(level, numSplats) {\n      let wordsPerSplat;\n      let key;\n      if (level === 0) {\n        return this.ensureSplats(numSplats);\n      }\n      if (level === 1) {\n        wordsPerSplat = 2;\n        key = "sh1";\n      } else if (level === 2) {\n        wordsPerSplat = 4;\n        key = "sh2";\n      } else if (level === 3) {\n        wordsPerSplat = 4;\n        key = "sh3";\n      } else {\n        throw new Error(`Invalid level: ${level}`);\n      }\n      let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n      const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\n      if (!this.extra[key] || targetSize > maxSplats) {\n        maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(maxSplats * wordsPerSplat);\n        if (this.extra[key]) {\n          newArray.set(this.extra[key]);\n        }\n        this.extra[key] = newArray;\n      }\n      return this.extra[key];\n    }\n    // Unpack the 16-byte Gsplat data at index into the Three.js components\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number 0..1, color: THREE.Color 0..1.\n    getSplat(index) {\n      if (!this.packedArray || index >= this.numSplats) {\n        throw new Error("Invalid index");\n      }\n      return unpackSplat(this.packedArray, index);\n    }\n    // Set all PackedSplat components at index with the provided Gsplat attributes\n    // (can be the same objects returned by getSplat). Ensures there is capacity\n    // for at least index+1 Gsplats.\n    setSplat(index, center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(index + 1);\n      setPackedSplat(\n        packedSplats,\n        index,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      this.numSplats = Math.max(this.numSplats, index + 1);\n    }\n    // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n    // construction where you just want to iterate and create a collection of Gsplats.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(this.numSplats + 1);\n      setPackedSplat(\n        packedSplats,\n        this.numSplats,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      ++this.numSplats;\n    }\n    // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n    // and invoke the callback function with the Gsplat attributes.\n    forEachSplat(callback) {\n      if (!this.packedArray || !this.numSplats) {\n        return;\n      }\n      for (let i2 = 0; i2 < this.numSplats; ++i2) {\n        const unpacked = unpackSplat(this.packedArray, i2);\n        callback(\n          i2,\n          unpacked.center,\n          unpacked.scales,\n          unpacked.quaternion,\n          unpacked.opacity,\n          unpacked.color\n        );\n      }\n    }\n    // Ensures our PackedSplats.target render target has enough space to generate\n    // maxSplats total Gsplats, and reallocate if not large enough.\n    ensureGenerate(maxSplats) {\n      if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\n        return false;\n      }\n      this.dispose();\n      const textureSize = getTextureSize(maxSplats ?? 1);\n      const { width, height, depth } = textureSize;\n      this.maxSplats = textureSize.maxSplats;\n      this.target = new WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n        magFilter: NearestFilter,\n        minFilter: NearestFilter\n      });\n      this.target.texture.format = RGBAIntegerFormat;\n      this.target.texture.type = UnsignedIntType;\n      this.target.texture.internalFormat = "RGBA32UI";\n      this.target.scissorTest = true;\n      return true;\n    }\n    // Given an array of splatCounts (.numSplats for each\n    // SplatGenerator/SplatMesh in the scene), compute a\n    // "mapping layout" in the composite array of generated outputs.\n    generateMapping(splatCounts) {\n      let maxSplats = 0;\n      const mapping = splatCounts.map((numSplats) => {\n        const base = maxSplats;\n        const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        maxSplats += rounded;\n        return { base, count: numSplats };\n      });\n      return { maxSplats, mapping };\n    }\n    // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n    // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n    getTexture() {\n      if (this.target) {\n        return this.target.texture;\n      }\n      if (this.source || this.packedArray) {\n        const source = this.maybeUpdateSource();\n        return source;\n      }\n      return _PackedSplats.getEmpty();\n    }\n    // Check if source texture needs to be created/updated\n    maybeUpdateSource() {\n      if (!this.packedArray) {\n        throw new Error("No packed splats");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.maxSplats !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.maxSplats);\n          this.source = new DataArrayTexture(\n            this.packedArray,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAIntegerFormat;\n          this.source.type = UnsignedIntType;\n          this.source.internalFormat = "RGBA32UI";\n          this.source.needsUpdate = true;\n        } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.packedArray.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_PackedSplats.emptySource) {\n        const { width, height, depth, maxSplats } = getTextureSize(1);\n        const emptyArray = new Uint32Array(maxSplats * 4);\n        _PackedSplats.emptySource = new DataArrayTexture(\n          emptyArray,\n          width,\n          height,\n          depth\n        );\n        _PackedSplats.emptySource.format = RGBAIntegerFormat;\n        _PackedSplats.emptySource.type = UnsignedIntType;\n        _PackedSplats.emptySource.internalFormat = "RGBA32UI";\n        _PackedSplats.emptySource.needsUpdate = true;\n      }\n      return _PackedSplats.emptySource;\n    }\n    // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(generator) {\n      let program = _PackedSplats.generatorProgram.get(generator);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { output: "uvec4" },\n          ({ index }) => {\n            generator.inputs.index = index;\n            const gsplat = generator.outputs.gsplat;\n            const output = outputPackedSplat(gsplat);\n            return { output };\n          }\n        );\n        if (!_PackedSplats.programTemplate) {\n          _PackedSplats.programTemplate = new DynoProgramTemplate(\n            computeUvec4_default\n          );\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { output: "target" },\n          template: _PackedSplats.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _PackedSplats.generatorProgram.set(generator, program);\n      }\n      const material = program.prepareMaterial();\n      _PackedSplats.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    // Executes a dyno program specified by generator which is any DynoBlock that\n    // maps { index: "int" } to { gsplat: Gsplat }. This is called in\n    // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n    // SplatGenerator instances whose version is newer than what was generated\n    // for it last time.\n    generate({\n      generator,\n      base,\n      count,\n      renderer\n    }) {\n      if (!this.target) {\n        throw new Error("Target must be initialized with ensureSplats");\n      }\n      if (base + count > this.maxSplats) {\n        throw new Error("Base + count exceeds maxSplats");\n      }\n      const { program, material } = this.prepareProgramMaterial(generator);\n      program.update();\n      const renderState = this.saveRenderState(renderer);\n      const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = base;\n      material.uniforms.targetCount.value = count;\n      while (base < nextBase) {\n        const layer = Math.floor(base / layerSize);\n        material.uniforms.targetLayer.value = layer;\n        const layerBase = layer * layerSize;\n        const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        this.target.scissor.set(\n          0,\n          layerYStart,\n          SPLAT_TEX_WIDTH,\n          layerYEnd - layerYStart\n        );\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        renderer.render(_PackedSplats.scene, _PackedSplats.camera);\n        base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\n      }\n      this.resetRenderState(renderer, renderState);\n      return { nextBase };\n    }\n  };\n  _PackedSplats.emptySource = null;\n  _PackedSplats.programTemplate = null;\n  _PackedSplats.generatorProgram = /* @__PURE__ */ new Map();\n  _PackedSplats.geometry = new PlaneGeometry(2, 2);\n  _PackedSplats.mesh = new Mesh(\n    _PackedSplats.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _PackedSplats.scene = new Scene().add(_PackedSplats.mesh);\n  _PackedSplats.camera = new Camera();\n  let PackedSplats = _PackedSplats;\n  class DynoPackedSplats extends DynoUniform {\n    constructor({ packedSplats } = {}) {\n      super({\n        key: "packedSplats",\n        type: TPackedSplats,\n        globals: () => [definePackedSplats],\n        value: {\n          texture: PackedSplats.getEmpty(),\n          numSplats: 0\n        },\n        update: (value) => {\n          var _a2, _b2;\n          value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();\n          value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n          return value;\n        }\n      });\n      this.packedSplats = packedSplats;\n    }\n  }\n  var computeVec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}";\n  const _Readback = class _Readback {\n    constructor({ renderer } = {}) {\n      this.renderer = renderer;\n      this.capacity = 0;\n      this.count = 0;\n    }\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = void 0;\n      }\n    }\n    // Ensure we have a buffer large enough for the readback of count indices.\n    // Pass in previous bufer of the desired type.\n    ensureBuffer(count, buffer) {\n      const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const bytes = roundedCount * 4;\n      if (buffer.byteLength >= bytes) {\n        return buffer;\n      }\n      const newBuffer = new ArrayBuffer(bytes);\n      if (buffer instanceof ArrayBuffer) {\n        return newBuffer;\n      }\n      const ctor = buffer.constructor;\n      return new ctor(newBuffer);\n    }\n    // Ensure our render target is large enough for the readback of capacity indices.\n    ensureCapacity(capacity) {\n      const { width, height, depth, maxSplats } = getTextureSize(capacity);\n      if (!this.target || maxSplats > this.capacity) {\n        this.dispose();\n        this.capacity = maxSplats;\n        this.target = new WebGLArrayRenderTarget(width, height, depth, {\n          depthBuffer: false,\n          stencilBuffer: false,\n          generateMipmaps: false,\n          magFilter: NearestFilter,\n          minFilter: NearestFilter\n        });\n        this.target.texture.format = RGBAFormat;\n        this.target.texture.type = UnsignedByteType;\n        this.target.texture.internalFormat = "RGBA8";\n        this.target.scissorTest = true;\n      }\n    }\n    // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(reader) {\n      let program = _Readback.readbackProgram.get(reader);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            reader.inputs.index = index;\n            const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\n            return { rgba8 };\n          }\n        );\n        if (!_Readback.programTemplate) {\n          _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { rgba8: "target" },\n          template: _Readback.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _Readback.readbackProgram.set(reader, program);\n      }\n      const material = program.prepareMaterial();\n      _Readback.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    process({\n      count,\n      material\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = 0;\n      material.uniforms.targetCount.value = count;\n      let baseIndex = 0;\n      while (baseIndex < count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        material.uniforms.targetLayer.value = layer;\n        this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        renderer.render(_Readback.scene, _Readback.camera);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      this.count = count;\n    }\n    async read({\n      readback\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      if (readback.byteLength < roundedCount * 4) {\n        throw new Error(\n          `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`\n        );\n      }\n      const readbackUint8 = new Uint8Array(\n        readback instanceof ArrayBuffer ? readback : readback.buffer\n      );\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      let baseIndex = 0;\n      const promises = [];\n      while (baseIndex < this.count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setRenderTarget(this.target, layer);\n        const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\n        const subReadback = readbackUint8.subarray(\n          layerBase * 4,\n          layerBase * 4 + readbackSize\n        );\n        const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(\n          this.target,\n          0,\n          0,\n          SPLAT_TEX_WIDTH,\n          layerYEnd,\n          subReadback\n        );\n        promises.push(promise);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      return Promise.all(promises).then(() => readback);\n    }\n    // Perform render operation to run the Rgba8Readback program\n    // but don\'t perform the readback yet.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      this.resetRenderState(this.renderer, renderState);\n    }\n    // Perform a readback of the render target, returning a buffer of the\n    // given type.\n    async readback({\n      readback\n    }) {\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      const renderState = this.saveRenderState(this.renderer);\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    // Perform a render and readback operation for the given Rgba8Readback,\n    // and readback buffer (call ensureBuffer first).\n    async renderReadback({\n      reader,\n      count,\n      renderer,\n      readback\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    getTexture() {\n      var _a2;\n      return (_a2 = this.target) == null ? void 0 : _a2.texture;\n    }\n  };\n  _Readback.programTemplate = null;\n  _Readback.readbackProgram = /* @__PURE__ */ new Map();\n  _Readback.geometry = new PlaneGeometry(2, 2);\n  _Readback.mesh = new Mesh(\n    _Readback.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _Readback.scene = new Scene().add(_Readback.mesh);\n  _Readback.camera = new Camera();\n  let Readback = _Readback;\n  const _RgbaArray = class _RgbaArray {\n    constructor(options = {}) {\n      this.capacity = 0;\n      this.count = 0;\n      this.array = null;\n      this.readback = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.dyno = new DynoUniform({\n        key: "rgbaArray",\n        type: TRgbaArray,\n        globals: () => [defineRgbaArray],\n        value: {\n          texture: _RgbaArray.getEmpty(),\n          count: 0\n        },\n        update: (value) => {\n          var _a2;\n          value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();\n          value.count = this.count;\n          return value;\n        }\n      });\n      if (options.array) {\n        this.array = options.array;\n        this.capacity = Math.floor(this.array.length / 4);\n        this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.count = Math.min(\n          this.capacity,\n          options.count ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.capacity = options.capacity ?? 0;\n        this.count = 0;\n      }\n    }\n    // Free up resources\n    dispose() {\n      if (this.readback) {\n        this.readback.dispose();\n        this.readback = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensure that our array is large enough to hold capacity RGBA8 values.\n    ensureCapacity(capacity) {\n      var _a2;\n      if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n        this.capacity = getTextureSize(capacity).maxSplats;\n        const newArray = new Uint8Array(this.capacity * 4);\n        if (this.array) {\n          newArray.set(this.array);\n        }\n        this.array = newArray;\n      }\n      return this.array;\n    }\n    // Get the THREE.DataArrayTexture from either the readback or the source.\n    getTexture() {\n      var _a2;\n      let texture = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n      if (this.source || this.array) {\n        texture = this.maybeUpdateSource();\n      }\n      return texture ?? _RgbaArray.getEmpty();\n    }\n    // Create or get a THREE.DataArrayTexture from the data array.\n    maybeUpdateSource() {\n      if (!this.array) {\n        throw new Error("No array");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.capacity !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.capacity);\n          this.source = new DataArrayTexture(\n            this.array,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAFormat;\n          this.source.type = UnsignedByteType;\n          this.source.internalFormat = "RGBA8";\n          this.source.needsUpdate = true;\n        } else if (this.array.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.array.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Generate the RGBA8 values from a Rgba8Readback dyno program.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      if (!this.readback) {\n        this.readback = new Readback({ renderer });\n      }\n      this.readback.render({ reader, count, renderer });\n      this.capacity = this.readback.capacity;\n      this.count = this.readback.count;\n    }\n    // Extract the RGBA8 values from a PackedSplats collection.\n    fromPackedSplats({\n      packedSplats,\n      base,\n      count,\n      renderer\n    }) {\n      const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();\n      dynoSplats.packedSplats = packedSplats;\n      dynoBase.value = base;\n      dynoCount.value = count;\n      this.render({ reader, count, renderer });\n      return this;\n    }\n    // Read back the RGBA8 values from the readback buffer.\n    async read() {\n      if (!this.readback) {\n        throw new Error("No readback");\n      }\n      if (!this.array || this.array.length < this.count * 4) {\n        this.array = new Uint8Array(this.capacity * 4);\n      }\n      const result = await this.readback.readback({ readback: this.array });\n      return result.subarray(0, this.count * 4);\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_RgbaArray.emptySource) {\n        const emptyArray = new Uint8Array(1 * 4);\n        _RgbaArray.emptySource = new DataArrayTexture(emptyArray, 1, 1, 1);\n        _RgbaArray.emptySource.format = RGBAFormat;\n        _RgbaArray.emptySource.type = UnsignedByteType;\n        _RgbaArray.emptySource.internalFormat = "RGBA8";\n        _RgbaArray.emptySource.needsUpdate = true;\n      }\n      return _RgbaArray.emptySource;\n    }\n    // Create a dyno program that can extract RGBA8 values from a PackedSplats\n    static makeDynos() {\n      if (!_RgbaArray.dynos) {\n        const dynoSplats = new DynoPackedSplats();\n        const dynoBase = new DynoInt({ value: 0 });\n        const dynoCount = new DynoInt({ value: 0 });\n        const reader = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            if (!index) {\n              throw new Error("index is undefined");\n            }\n            index = add(index, dynoBase);\n            const gsplat = readPackedSplatRange(\n              dynoSplats,\n              index,\n              dynoBase,\n              dynoCount\n            );\n            return { rgba8: splitGsplat(gsplat).outputs.rgba };\n          }\n        );\n        _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n      }\n      return _RgbaArray.dynos;\n    }\n  };\n  _RgbaArray.emptySource = null;\n  _RgbaArray.dynos = null;\n  let RgbaArray = _RgbaArray;\n  const TRgbaArray = { type: "RgbaArray" };\n  const defineRgbaArray = unindent(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);\n  function readRgbaArray(rgba, index) {\n    const dyno2 = new Dyno({\n      inTypes: { rgba: TRgbaArray, index: "int" },\n      outTypes: { rgba: "vec4" },\n      inputs: { rgba, index },\n      globals: () => [defineRgbaArray],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) {\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n    });\n    return dyno2.outputs.rgba;\n  }\n  function sdfTypeToNumber(type) {\n    switch (type) {\n      case "all":\n        return 0;\n      case "plane":\n        return 1;\n      case "sphere":\n        return 2;\n      case "box":\n        return 3;\n      case "ellipsoid":\n        return 4;\n      case "cylinder":\n        return 5;\n      case "capsule":\n        return 6;\n      case "infinite_cone":\n        return 7;\n      default:\n        throw new Error(`Unknown SDF type: ${type}`);\n    }\n  }\n  function rgbaBlendModeToNumber(mode) {\n    switch (mode) {\n      case "multiply":\n        return 0;\n      case "set_rgb":\n        return 1;\n      case "add_rgba":\n        return 2;\n      default:\n        throw new Error(`Unknown blend mode: ${mode}`);\n    }\n  }\n  class SplatEditSdf extends Object3D {\n    constructor(options = {}) {\n      super();\n      const { type, invert, opacity, color, displace, radius } = options;\n      this.type = type ?? "sphere";\n      this.invert = invert ?? false;\n      this.opacity = opacity ?? 1;\n      this.color = color ?? new Color(1, 1, 1);\n      this.displace = displace ?? new Vector3(0, 0, 0);\n      this.radius = radius ?? 0;\n    }\n  }\n  const _SplatEdit = class _SplatEdit extends Object3D {\n    constructor(options = {}) {\n      const {\n        name,\n        rgbaBlendMode = "multiply",\n        sdfSmooth = 0,\n        softEdge = 0,\n        invert = false,\n        sdfs = null\n      } = options;\n      super();\n      this.rgbaBlendMode = rgbaBlendMode;\n      this.sdfSmooth = sdfSmooth;\n      this.softEdge = softEdge;\n      this.invert = invert;\n      this.sdfs = sdfs;\n      this.ordering = _SplatEdit.nextOrdering++;\n      this.name = name ?? `Edit ${this.ordering}`;\n    }\n    addSdf(sdf) {\n      if (this.sdfs == null) {\n        this.sdfs = [];\n      }\n      if (!this.sdfs.includes(sdf)) {\n        this.sdfs.push(sdf);\n      }\n    }\n    removeSdf(sdf) {\n      if (this.sdfs == null) {\n        return;\n      }\n      this.sdfs = this.sdfs.filter((s) => s !== sdf);\n    }\n  };\n  _SplatEdit.nextOrdering = 1;\n  let SplatEdit = _SplatEdit;\n  class SplatEdits {\n    constructor({ maxSdfs, maxEdits }) {\n      this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n      this.numSdfs = 0;\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      this.dynoSdfArray = new DynoUniform({\n        key: "sdfArray",\n        type: SdfArray,\n        globals: () => [defineSdfArray],\n        value: {\n          numSdfs: 0,\n          sdfTexture: this.sdfTexture\n        },\n        update: (uniform) => {\n          uniform.numSdfs = this.numSdfs;\n          uniform.sdfTexture = this.sdfTexture;\n          return uniform;\n        }\n      });\n      this.maxEdits = Math.max(16, maxEdits ?? 0);\n      this.numEdits = 0;\n      this.editData = new Uint32Array(this.maxEdits * 4);\n      this.editFloatData = new Float32Array(this.editData.buffer);\n      this.dynoNumEdits = new DynoInt({ value: 0 });\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n    }\n    newSdfTexture(data, maxSdfs) {\n      const texture = new DataTexture(\n        data,\n        8,\n        maxSdfs,\n        RGBAIntegerFormat,\n        UnsignedIntType\n      );\n      texture.internalFormat = "RGBA32UI";\n      texture.needsUpdate = true;\n      return texture;\n    }\n    newEdits(data, maxEdits) {\n      return new DynoUniform({\n        key: "edits",\n        type: "uvec4",\n        count: maxEdits,\n        globals: () => [defineEdit],\n        value: data\n      });\n    }\n    // Ensure our SDF texture and edits uniform array have enough capacity.\n    // Reallocate if not.\n    ensureCapacity({\n      maxSdfs,\n      maxEdits\n    }) {\n      let dynoUpdated = false;\n      if (maxSdfs > this.sdfTexture.image.height) {\n        this.sdfTexture.dispose();\n        this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n        this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n        this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n        this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      }\n      if (maxEdits > (this.dynoEdits.count ?? 0)) {\n        this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\n        this.editData = new Uint32Array(this.maxEdits * 4);\n        this.editFloatData = new Float32Array(this.editData.buffer);\n        this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n        dynoUpdated = true;\n      }\n      return dynoUpdated;\n    }\n    updateEditData(offset, value) {\n      const updated = this.editData[offset] !== value;\n      this.editData[offset] = value;\n      return updated;\n    }\n    updateEditFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.editFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.editFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeEdit(editIndex, {\n      sdfFirst,\n      sdfCount,\n      invert,\n      rgbaBlendMode,\n      softEdge,\n      sdfSmooth\n    }) {\n      const base = editIndex * 4;\n      let updated = false;\n      updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;\n      updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;\n      updated = this.updateEditFloatData(base + 2, softEdge) || updated;\n      updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\n      return updated;\n    }\n    updateSdfData(offset, value) {\n      const updated = this.sdfData[offset] !== value;\n      this.sdfData[offset] = value;\n      return updated;\n    }\n    updateSdfFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.sdfFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.sdfFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeSdf(sdfIndex, {\n      sdfType,\n      invert,\n      center,\n      quaternion,\n      scale,\n      sizes\n    }, values) {\n      const base = sdfIndex * (8 * 4);\n      const flags = sdfType | (invert ? 1 << 8 : 0);\n      let updated = false;\n      updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 3, flags) || updated;\n      updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 11, 0) || updated;\n      updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;\n      const nValues = Math.min(4, values.length);\n      for (let i2 = 0; i2 < nValues; ++i2) {\n        const vBase = base + 16 + i2 * 4;\n        updated = this.updateSdfFloatData(vBase + 0, values[i2].x) || updated;\n        updated = this.updateSdfFloatData(vBase + 1, values[i2].y) || updated;\n        updated = this.updateSdfFloatData(vBase + 2, values[i2].z) || updated;\n        updated = this.updateSdfFloatData(vBase + 3, values[i2].w) || updated;\n      }\n      return updated;\n    }\n    // Update the SDFs and edits from an array of SplatEdits and their\n    // associated SplatEditSdfs, updating it for the dyno shader program.\n    update(edits) {\n      const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\n      const dynoUpdated = this.ensureCapacity({\n        maxEdits: edits.length,\n        maxSdfs: sdfCount\n      });\n      const values = [new Vector4(), new Vector4()];\n      const center = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      const sizes = new Vector4();\n      let sdfIndex = 0;\n      let updated = dynoUpdated;\n      if (edits.length !== this.dynoNumEdits.value) {\n        this.dynoNumEdits.value = edits.length;\n        this.numEdits = edits.length;\n        updated = true;\n      }\n      for (const [editIndex, { edit, sdfs }] of edits.entries()) {\n        updated = this.encodeEdit(editIndex, {\n          sdfFirst: sdfIndex,\n          sdfCount: sdfs.length,\n          invert: edit.invert,\n          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\n          softEdge: edit.softEdge,\n          sdfSmooth: edit.sdfSmooth\n        }) || updated;\n        let sdfUpdated = false;\n        for (const sdf of sdfs) {\n          sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n          sdf.scale.setScalar(1);\n          sdf.updateMatrixWorld();\n          const worldToSdf = sdf.matrixWorld.clone().invert();\n          worldToSdf.decompose(center, quaternion, scale);\n          sdf.scale.set(sizes.x, sizes.y, sizes.z);\n          sdf.updateMatrixWorld();\n          values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n          values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n          sdfUpdated = this.encodeSdf(\n            sdfIndex,\n            {\n              sdfType: sdfTypeToNumber(sdf.type),\n              invert: sdf.invert,\n              center,\n              quaternion,\n              scale,\n              sizes\n            },\n            values\n          ) || sdfUpdated;\n          sdfIndex += 1;\n        }\n        this.numSdfs = sdfIndex;\n        if (sdfUpdated) {\n          this.sdfTexture.needsUpdate = true;\n        }\n        updated || (updated = sdfUpdated);\n      }\n      return { updated, dynoUpdated };\n    }\n    // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n    modify(gsplat) {\n      return applyGsplatRgbaDisplaceEdits(\n        gsplat,\n        this.dynoSdfArray,\n        this.dynoNumEdits,\n        this.dynoEdits\n      );\n    }\n  }\n  const SdfArray = { type: "SdfArray" };\n  const defineSdfArray = unindent(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`);\n  const defineEdit = unindent(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);\n  function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {\n    const dyno2 = new Dyno({\n      inTypes: {\n        gsplat: Gsplat,\n        sdfArray: SdfArray,\n        numEdits: "int",\n        rgbaDisplaceEdits: "uvec4"\n      },\n      outTypes: { gsplat: Gsplat },\n      globals: () => [defineSdfArray, defineEdit],\n      inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\n      statements: ({ inputs, outputs }) => {\n        const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n        const { gsplat: gsplat2 } = outputs;\n        return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${rgbaDisplaceEdits2}[editIndex], ${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,\n              ${gsplat2}.center, ${gsplat2}.rgba\n            );\n          }\n        }\n      `);\n      }\n    });\n    return dyno2.outputs.gsplat;\n  }\n  const tempFloat32 = new Float32Array(1);\n  class SplatTransformer {\n    // Create the dyno uniforms that parameterize the transform, setting them\n    // to initial values that are different from any valid transform.\n    constructor() {\n      this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n      this.rotate = new DynoVec4({\n        value: new Quaternion(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n      this.translate = new DynoVec3({\n        value: new Vector3(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n    }\n    // Apply the transform to a Vec3 position in a dyno program.\n    apply(position) {\n      return transformPos(position, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    applyDir(dir) {\n      return transformDir(dir, {\n        rotate: this.rotate\n      });\n    }\n    // Apply the transform to a Gsplat in a dyno program.\n    applyGsplat(gsplat) {\n      return transformGsplat(gsplat, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    // Update the uniforms to match the given transform matrix.\n    updateFromMatrix(transform) {\n      const scale = new Vector3();\n      const quaternion = new Quaternion();\n      const position = new Vector3();\n      transform.decompose(position, quaternion, scale);\n      const newScale = (scale.x + scale.y + scale.z) / 3;\n      let updated = false;\n      if (newScale !== this.scale.value) {\n        this.scale.value = newScale;\n        updated = true;\n      }\n      if (!position.equals(this.translate.value)) {\n        this.translate.value.copy(position);\n        updated = true;\n      }\n      if (!quaternion.equals(this.rotate.value)) {\n        this.rotate.value.copy(quaternion);\n        updated = true;\n      }\n      return updated;\n    }\n    // Update this transform to match the object\'s to-world transform.\n    update(object) {\n      object.updateMatrixWorld();\n      return this.updateFromMatrix(object.matrixWorld);\n    }\n  }\n  class SplatGenerator extends Object3D {\n    constructor({\n      numSplats,\n      generator,\n      construct,\n      update\n    }) {\n      super();\n      this.numSplats = numSplats ?? 0;\n      this.generator = generator;\n      this.frameUpdate = update;\n      this.version = 0;\n      if (construct) {\n        const constructed = construct(this);\n        Object.assign(this, constructed);\n      }\n    }\n    updateVersion() {\n      this.version += 1;\n    }\n    set needsUpdate(value) {\n      if (value) {\n        this.updateVersion();\n      }\n    }\n  }\n  const _SplatMesh = class _SplatMesh extends SplatGenerator {\n    constructor(options = {}) {\n      const transform = new SplatTransformer();\n      const viewToWorld = new SplatTransformer();\n      const worldToView = new SplatTransformer();\n      const viewToObject = new SplatTransformer();\n      const recolor = new DynoVec4({\n        value: new Vector4(\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY\n        )\n      });\n      const time = new DynoFloat({ value: 0 });\n      const deltaTime = new DynoFloat({ value: 0 });\n      const context = {\n        transform,\n        viewToWorld,\n        worldToView,\n        viewToObject,\n        recolor,\n        time,\n        deltaTime\n      };\n      super({\n        update: ({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits })\n      });\n      this.isInitialized = false;\n      this.recolor = new Color(1, 1, 1);\n      this.opacity = 1;\n      this.enableViewToObject = false;\n      this.enableViewToWorld = false;\n      this.enableWorldToView = false;\n      this.skinning = null;\n      this.edits = null;\n      this.rgbaDisplaceEdits = null;\n      this.splatRgba = null;\n      this.maxSh = 3;\n      this.packedSplats = options.packedSplats ?? new PackedSplats();\n      this.numSplats = this.packedSplats.numSplats;\n      this.editable = options.editable ?? true;\n      this.onFrame = options.onFrame;\n      this.context = context;\n      this.objectModifier = options.objectModifier;\n      this.worldModifier = options.worldModifier;\n      this.updateGenerator();\n      if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {\n        this.initialized = this.asyncInitialize(options).then(async () => {\n          this.updateGenerator();\n          this.isInitialized = true;\n          if (options.onLoad) {\n            const maybePromise = options.onLoad(this);\n            if (maybePromise instanceof Promise) {\n              await maybePromise;\n            }\n          }\n          return this;\n        });\n      } else {\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n        if (options.onLoad) {\n          const maybePromise = options.onLoad(this);\n          if (maybePromise instanceof Promise) {\n            this.initialized = maybePromise.then(() => this);\n          }\n        }\n      }\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, fileType, fileName, maxSplats, constructSplats } = options;\n      if (url || fileBytes || constructSplats) {\n        const packedSplatsOptions = {\n          url,\n          fileBytes,\n          fileType,\n          fileName,\n          maxSplats,\n          construct: constructSplats\n        };\n        this.packedSplats.reinitialize(packedSplatsOptions);\n      }\n      if (this.packedSplats) {\n        await this.packedSplats.initialized;\n        this.numSplats = this.packedSplats.numSplats;\n        this.updateGenerator();\n      }\n    }\n    static async staticInitialize() {\n      await __wbg_init();\n      _SplatMesh.isStaticInitialized = true;\n    }\n    // Creates a new Gsplat with the provided parameters (all values in "float" space,\n    // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n    // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n    // doubling strategy to fit the new data, so it\'s fairly efficient to just\n    // pushSplat(...) each Gsplat you want to create in a loop.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\n    }\n    // This method iterates over all Gsplats in this instance\'s packedSplats,\n    // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n    // Note that the objects passed in as center etc. are the same for every callback\n    // invocation: these objects are reused for efficiency. Changing these values has\n    // no effect as they are decoded/unpacked copies of the underlying data. To update\n    // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n    // quaternion, opacity, color).\n    forEachSplat(callback) {\n      this.packedSplats.forEachSplat(callback);\n    }\n    // Call this when you are finished with the SplatMesh and want to free\n    // any buffers it holds (via packedSplats).\n    dispose() {\n      this.packedSplats.dispose();\n    }\n    constructGenerator(context) {\n      const { transform, viewToObject, recolor } = context;\n      const generator = dynoBlock(\n        { index: "int" },\n        { gsplat: Gsplat },\n        ({ index }) => {\n          if (!index) {\n            throw new Error("index is undefined");\n          }\n          let gsplat = readPackedSplat(this.packedSplats.dyno, index);\n          if (this.maxSh >= 1) {\n            const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();\n            if (sh1Texture) {\n              const viewCenterInObject = viewToObject.translate;\n              const { center } = splitGsplat(gsplat).outputs;\n              const viewDir = normalize(sub(center, viewCenterInObject));\n              let rgb = evaluateSH1(gsplat, sh1Texture, viewDir);\n              if (this.maxSh >= 2 && sh2Texture) {\n                rgb = add(rgb, evaluateSH2(gsplat, sh2Texture, viewDir));\n              }\n              if (this.maxSh >= 3 && sh3Texture) {\n                rgb = add(rgb, evaluateSH3(gsplat, sh3Texture, viewDir));\n              }\n              let { rgba } = splitGsplat(gsplat).outputs;\n              rgba = add(rgba, extendVec(rgb, dynoConst("float", 0)));\n              gsplat = combineGsplat({ gsplat, rgba });\n            }\n          }\n          if (this.splatRgba) {\n            const rgba = readRgbaArray(this.splatRgba.dyno, index);\n            gsplat = combineGsplat({ gsplat, rgba });\n          }\n          if (this.skinning) {\n            gsplat = this.skinning.modify(gsplat);\n          }\n          if (this.objectModifier) {\n            gsplat = this.objectModifier.apply({ gsplat }).gsplat;\n          }\n          gsplat = transform.applyGsplat(gsplat);\n          const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\n          gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\n          if (this.rgbaDisplaceEdits) {\n            gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n          }\n          if (this.worldModifier) {\n            gsplat = this.worldModifier.apply({ gsplat }).gsplat;\n          }\n          return { gsplat };\n        }\n      );\n      this.generator = generator;\n    }\n    // Call this whenever something changes in the Gsplat processing pipeline,\n    // for example changing maxSh or updating objectModifier or worldModifier.\n    // Compiled generators are cached for efficiency and re-use when the same\n    // pipeline structure emerges after successive changes.\n    updateGenerator() {\n      this.constructGenerator(this.context);\n    }\n    // This is called automatically by SparkRenderer and you should not have to\n    // call it. It updates parameters for the generated pipeline and calls\n    // updateGenerator() if the pipeline needs to change.\n    update({\n      time,\n      viewToWorld,\n      deltaTime,\n      globalEdits\n    }) {\n      var _a2;\n      this.numSplats = this.packedSplats.numSplats;\n      this.context.time.value = time;\n      this.context.deltaTime.value = deltaTime;\n      _SplatMesh.dynoTime.value = time;\n      const { transform, viewToObject, recolor } = this.context;\n      let updated = transform.update(this);\n      if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {\n        updated = true;\n      }\n      const worldToView = viewToWorld.clone().invert();\n      if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {\n        updated = true;\n      }\n      const objectToWorld = new Matrix4().compose(\n        transform.translate.value,\n        transform.rotate.value,\n        new Vector3().setScalar(transform.scale.value)\n      );\n      const worldToObject = objectToWorld.invert();\n      const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\n      if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {\n        updated = true;\n      }\n      const newRecolor = new Vector4(\n        this.recolor.r,\n        this.recolor.g,\n        this.recolor.b,\n        this.opacity\n      );\n      if (!newRecolor.equals(recolor.value)) {\n        recolor.value.copy(newRecolor);\n        updated = true;\n      }\n      const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n      if (this.editable && !this.edits) {\n        this.traverseVisible((node) => {\n          if (node instanceof SplatEdit) {\n            edits.push(node);\n          }\n        });\n      }\n      edits.sort((a, b) => a.ordering - b.ordering);\n      const editsSdfs = edits.map((edit) => {\n        if (edit.sdfs != null) {\n          return { edit, sdfs: edit.sdfs };\n        }\n        const sdfs = [];\n        edit.traverseVisible((node) => {\n          if (node instanceof SplatEditSdf) {\n            sdfs.push(node);\n          }\n        });\n        return { edit, sdfs };\n      });\n      if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\n        const edits2 = editsSdfs.length;\n        const sdfs = editsSdfs.reduce(\n          (total, edit) => total + edit.sdfs.length,\n          0\n        );\n        this.rgbaDisplaceEdits = new SplatEdits({\n          maxEdits: edits2,\n          maxSdfs: sdfs\n        });\n        this.updateGenerator();\n      }\n      if (this.rgbaDisplaceEdits) {\n        const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n        updated || (updated = editResult.updated);\n        if (editResult.dynoUpdated) {\n          this.updateGenerator();\n        }\n      }\n      if (updated) {\n        this.updateVersion();\n      }\n      (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });\n    }\n    // This method conforms to the standard THREE.Raycaster API, performing object-ray\n    // intersections using this method to populate the provided intersects[] array\n    // with each intersection point.\n    raycast(raycaster, intersects) {\n      if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\n        return;\n      }\n      const { near, far, ray } = raycaster;\n      const worldToMesh = this.matrixWorld.clone().invert();\n      const worldToMeshRot = new Matrix3().setFromMatrix4(worldToMesh);\n      const origin = ray.origin.clone().applyMatrix4(worldToMesh);\n      const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\n      const scales = new Vector3();\n      worldToMesh.decompose(new Vector3(), new Quaternion(), scales);\n      (scales.x * scales.y * scales.z) ** (1 / 3);\n      const RAYCAST_ELLIPSOID = true;\n      const distances = raycast_splats(\n        origin.x,\n        origin.y,\n        origin.z,\n        direction.x,\n        direction.y,\n        direction.z,\n        near,\n        far,\n        this.packedSplats.numSplats,\n        this.packedSplats.packedArray,\n        RAYCAST_ELLIPSOID\n      );\n      for (const distance of distances) {\n        const point = ray.direction.clone().multiplyScalar(distance).add(ray.origin);\n        intersects.push({\n          distance,\n          point,\n          object: this\n        });\n      }\n    }\n    ensureShTextures() {\n      if (!this.packedSplats.extra.sh1) {\n        return {};\n      }\n      let sh1Texture = this.packedSplats.extra.sh1Texture;\n      if (!sh1Texture) {\n        let sh1 = this.packedSplats.extra.sh1;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh1.length / 2\n        );\n        if (sh1.length < maxSplats * 2) {\n          const newSh1 = new Uint32Array(maxSplats * 2);\n          newSh1.set(sh1);\n          this.packedSplats.extra.sh1 = newSh1;\n          sh1 = newSh1;\n        }\n        const texture = new DataArrayTexture(sh1, width, height, depth);\n        texture.format = RGIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RG32UI";\n        texture.needsUpdate = true;\n        sh1Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh1"\n        });\n        this.packedSplats.extra.sh1Texture = sh1Texture;\n      }\n      if (!this.packedSplats.extra.sh2) {\n        return { sh1Texture };\n      }\n      let sh2Texture = this.packedSplats.extra.sh2Texture;\n      if (!sh2Texture) {\n        let sh2 = this.packedSplats.extra.sh2;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh2.length / 4\n        );\n        if (sh2.length < maxSplats * 4) {\n          const newSh2 = new Uint32Array(maxSplats * 4);\n          newSh2.set(sh2);\n          this.packedSplats.extra.sh2 = newSh2;\n          sh2 = newSh2;\n        }\n        const texture = new DataArrayTexture(sh2, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh2Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh2"\n        });\n        this.packedSplats.extra.sh2Texture = sh2Texture;\n      }\n      if (!this.packedSplats.extra.sh3) {\n        return { sh1Texture, sh2Texture };\n      }\n      let sh3Texture = this.packedSplats.extra.sh3Texture;\n      if (!sh3Texture) {\n        let sh3 = this.packedSplats.extra.sh3;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh3.length / 4\n        );\n        if (sh3.length < maxSplats * 4) {\n          const newSh3 = new Uint32Array(maxSplats * 4);\n          newSh3.set(sh3);\n          this.packedSplats.extra.sh3 = newSh3;\n          sh3 = newSh3;\n        }\n        const texture = new DataArrayTexture(sh3, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh3Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh3"\n        });\n        this.packedSplats.extra.sh3Texture = sh3Texture;\n      }\n      return { sh1Texture, sh2Texture, sh3Texture };\n    }\n  };\n  _SplatMesh.staticInitialized = _SplatMesh.staticInitialize();\n  _SplatMesh.isStaticInitialized = false;\n  _SplatMesh.dynoTime = new DynoFloat({ value: 0 });\n  let SplatMesh = _SplatMesh;\n  const defineEvaluateSH1 = unindent(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`);\n  const defineEvaluateSH2 = unindent(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`);\n  const defineEvaluateSH3 = unindent(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\n  function evaluateSH1(gsplat, sh1, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh1: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh1, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH1],\n      statements: ({ inputs, outputs }) => {\n        const statements = unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `);\n        return statements;\n      }\n    }).outputs.rgb;\n  }\n  function evaluateSH2(gsplat, sh2, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh2: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh2, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH2],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  function evaluateSH3(gsplat, sh3, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh3: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh3, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH3],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  function WorkerWrapper(options) {\n    return new Worker(\n      self.location.href,\n      {\n        name: options == null ? void 0 : options.name\n      }\n    );\n  }\n  class SplatWorker {\n    constructor() {\n      this.messages = {};\n      this.messageIdNext = 0;\n      this.worker = new WorkerWrapper();\n      this.worker.onmessage = (event) => this.onMessage(event);\n    }\n    makeMessageId() {\n      return ++this.messageIdNext;\n    }\n    makeMessagePromiseId() {\n      const id = this.makeMessageId();\n      const promise = new Promise((resolve, reject) => {\n        this.messages[id] = { resolve, reject };\n      });\n      return { id, promise };\n    }\n    onMessage(event) {\n      const { id, result, error } = event.data;\n      const handler = this.messages[id];\n      if (handler) {\n        delete this.messages[id];\n        if (error) {\n          handler.reject(error);\n        } else {\n          handler.resolve(result);\n        }\n      }\n    }\n    // Invoke an RPC on the worker with the given name and arguments.\n    // The normal usage of a worker is to run one activity at a time,\n    // but this function allows for concurrent calls, tagging each request\n    // with a unique message Id and awaiting a response to that same Id.\n    // The method will automatically transfer any ArrayBuffers in the\n    // arguments to the worker. If you\'d like to transfer a copy of a\n    // buffer then you must clone it before passing to this function.\n    async call(name, args) {\n      const { id, promise } = this.makeMessagePromiseId();\n      this.worker.postMessage(\n        { name, args, id },\n        { transfer: getArrayBuffers(args) }\n      );\n      return promise;\n    }\n  }\n  let maxWorkers = 4;\n  let numWorkers = 0;\n  const freeWorkers = [];\n  const workerQueue = [];\n  async function allocWorker() {\n    const worker = freeWorkers.shift();\n    if (worker) {\n      return worker;\n    }\n    if (numWorkers < maxWorkers) {\n      const worker2 = new SplatWorker();\n      numWorkers += 1;\n      return worker2;\n    }\n    return new Promise((resolve) => {\n      workerQueue.push(resolve);\n    });\n  }\n  function freeWorker(worker) {\n    if (numWorkers > maxWorkers) {\n      numWorkers -= 1;\n      return;\n    }\n    const waiter = workerQueue.shift();\n    if (waiter) {\n      waiter(worker);\n      return;\n    }\n    freeWorkers.push(worker);\n  }\n  async function withWorker(callback) {\n    const worker = await allocWorker();\n    try {\n      return await callback(worker);\n    } finally {\n      freeWorker(worker);\n    }\n  }\n  class SplatLoader extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.fileLoader = new FileLoader(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      this.fileLoader.setResponseType("arraybuffer");\n      this.fileLoader.setCrossOrigin(this.crossOrigin);\n      this.fileLoader.setWithCredentials(this.withCredentials);\n      this.fileLoader.setPath(this.path);\n      this.fileLoader.setResourcePath(this.resourcePath);\n      this.fileLoader.setRequestHeader(this.requestHeader);\n      this.fileLoader.load(\n        url,\n        async (response) => {\n          if (onLoad) {\n            const input = response;\n            const extraFiles = {};\n            const promises = [];\n            let fileType = this.fileType;\n            try {\n              const pcSogsJson = tryPcSogs(input);\n              if (this.fileType === "pcsogs") {\n                if (pcSogsJson === void 0) {\n                  throw new Error("Invalid PC SOGS file");\n                }\n              }\n              if (pcSogsJson !== void 0) {\n                fileType = "pcsogs";\n                for (const key of ["means", "scales", "quats", "sh0", "shN"]) {\n                  const prop = pcSogsJson[key];\n                  if (prop) {\n                    const files = prop.files;\n                    for (const file of files) {\n                      const fileUrl = new URL(file, url).toString();\n                      this.manager.itemStart(fileUrl);\n                      const promise = this.loadExtra(fileUrl).then((data) => {\n                        extraFiles[file] = data;\n                      }).catch((error) => {\n                        this.manager.itemError(fileUrl);\n                        throw error;\n                      }).finally(() => {\n                        this.manager.itemEnd(fileUrl);\n                      });\n                      promises.push(promise);\n                    }\n                  }\n                }\n              }\n              await Promise.all(promises);\n              const decoded = await unpackSplats({\n                input,\n                extraFiles,\n                fileType,\n                pathOrUrl: url\n              });\n              if (this.packedSplats) {\n                this.packedSplats.initialize(decoded);\n                onLoad(this.packedSplats);\n              } else {\n                onLoad(new PackedSplats(decoded));\n              }\n            } catch (error) {\n              onError == null ? void 0 : onError(error);\n            }\n          }\n        },\n        onProgress,\n        onError\n      );\n    }\n    async loadAsync(url, onProgress) {\n      return new Promise((resolve, reject) => {\n        this.load(\n          url,\n          (decoded) => {\n            resolve(decoded);\n          },\n          onProgress,\n          reject\n        );\n      });\n    }\n    async loadExtra(url) {\n      return new Promise((resolve, reject) => {\n        this.fileLoader.load(\n          url,\n          (response) => resolve(response),\n          void 0,\n          (error) => reject(error)\n        );\n      });\n    }\n    parse(packedSplats) {\n      return new SplatMesh({ packedSplats });\n    }\n  }\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2["PLY"] = "ply";\n    SplatFileType2["SPZ"] = "spz";\n    SplatFileType2["SPLAT"] = "splat";\n    SplatFileType2["KSPLAT"] = "ksplat";\n    SplatFileType2["PCSOGS"] = "pcsogs";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return "ply";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return "spz";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf("/"),\n      noTrailing.lastIndexOf("\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(".");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return "";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === "ply") {\n      return "ply";\n    }\n    if (extension === "spz") {\n      return "spz";\n    }\n    if (extension === "splat") {\n      return "splat";\n    }\n    if (extension === "ksplat") {\n      return "ksplat";\n    }\n    return void 0;\n  }\n  function tryPcSogs(input) {\n    try {\n      let text;\n      if (typeof input === "string") {\n        text = input;\n      } else {\n        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n        if (fileBytes.length > 65536) {\n          return void 0;\n        }\n        text = new TextDecoder().decode(fileBytes);\n      }\n      const json = JSON.parse(text);\n      if (!json || typeof json !== "object" || Array.isArray(json)) {\n        return void 0;\n      }\n      for (const key of ["means", "scales", "quats", "sh0"]) {\n        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {\n          return void 0;\n        }\n        if (!json[key].shape || !json[key].files) {\n          return void 0;\n        }\n        if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {\n          return void 0;\n        }\n      }\n      return json;\n    } catch {\n      return void 0;\n    }\n  }\n  async function unpackSplats({\n    input,\n    extraFiles,\n    fileType,\n    pathOrUrl\n  }) {\n    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let splatFileType = fileType;\n    if (!fileType) {\n      splatFileType = getSplatFileType(fileBytes);\n      if (!splatFileType && pathOrUrl) {\n        splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n      }\n    }\n    switch (splatFileType) {\n      case "ply": {\n        const ply = new PlyReader({ fileBytes });\n        await ply.parseHeader();\n        const numSplats = ply.numSplats;\n        const maxSplats = getTextureSize(numSplats).maxSplats;\n        const args = { fileBytes, packedArray: new Uint32Array(maxSplats * 4) };\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats: numSplats2, extra } = await worker.call(\n            "unpackPly",\n            args\n          );\n          return { packedArray, numSplats: numSplats2, extra };\n        });\n      }\n      case "spz": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodeSpz",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case "splat": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats } = await worker.call(\n            "decodeAntiSplat",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats };\n        });\n      }\n      case "ksplat": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodeKsplat",\n            { fileBytes }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case "pcsogs": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodePcSogs",\n            { fileBytes, extraFiles }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      default: {\n        throw new Error(`Unknown splat file type: ${splatFileType}`);\n      }\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error("Cannot unpush splat from non-last position");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n      const header = new DataView(this.reader.read(16).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error("Invalid SPZ file");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 2) {\n        throw new Error(`Unsupported SPZ version: ${this.version}`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.reserved = header.getUint8(15);\n      this.parsed = false;\n    }\n    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n      if (this.parsed) {\n        throw new Error("SPZ file already parsed");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error("Unreachable");\n      }\n      {\n        const bytes = this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      {\n        const quatBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 2;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, quatX, quatY, quatZ, quatW) {\n      const base = 16 + this.numSplats * 16 + index * 3;\n      const quatNeg = quatW < 0;\n      this.view.setUint8(\n        base,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))\n        )\n      );\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream("gzip"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        "Compressed",\n        input.length,\n        "bytes to",\n        buffer.byteLength,\n        "bytes"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos2 = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos2(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(`transcodeSpz not implemented for ${fileType}`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case "unpackPly": {\n          const { packedArray, fileBytes } = args;\n          const decoded = await unpackPly({ packedArray, fileBytes });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeSpz": {\n          const { fileBytes } = args;\n          const decoded = unpackSpz(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeAntiSplat": {\n          const { fileBytes } = args;\n          const decoded = unpackAntiSplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case "decodeKsplat": {\n          const { fileBytes } = args;\n          const decoded = unpackKsplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogs": {\n          const { fileBytes, extraFiles } = args;\n          const decoded = await unpackPcSogs(fileBytes, extraFiles);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "sortSplats": {\n          const { maxSplats, totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case "sortDoubleSplats": {\n          const { numSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ordering\n          };\n          if (WASM_SPLAT_SORT) {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "transcodeSpz": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(`Unknown name: ${name}`);\n        }\n      }\n    } catch (e) {\n      error = e;\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    const ZERO_CUTOFF = Math.exp(-20);\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleX),\n          scaleY < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleY),\n          scaleZ < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleZ),\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  function unpackSpz(fileBytes) {\n    const spz = new SpzReader({ fileBytes });\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(packedArray, index, scaleX, scaleY, scaleZ);\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY = 31744;\n  const DEPTH_SIZE = DEPTH_INFINITY + 1;\n  let depthArray = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE; ++j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          ordering[depthArray[pri]] = layerBase + i2;\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray[DEPTH_SIZE - 1] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray[DEPTH_SIZE - 1]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  function sortDoubleSplats({\n    numSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        depthArray[pri] += 1;\n      }\n    }\n    let activeSplats = 0;\n    for (let j = DEPTH_INFINITY - 1; j >= 0; --j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        ordering[depthArray[pri]] = i2;\n        depthArray[pri] += 1;\n      }\n    }\n    if (depthArray[0] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray[0]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener("message", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener("message", bufferMessage);\n    self.addEventListener("message", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-D5xlON3B.js.map\n',Va="undefined"!=typeof self&&self.Blob&&new Blob([Ka],{type:"text/javascript;charset=utf-8"});function Wa(t){let A;try{if(A=Va&&(self.URL||self.webkitURL).createObjectURL(Va),!A)throw"";const e=new Worker(A,{name:null==t?void 0:t.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(A)}),e}catch(A){return new Worker("data:text/javascript;charset=utf-8,"+encodeURIComponent(Ka),{name:null==t?void 0:t.name})}finally{A&&(self.URL||self.webkitURL).revokeObjectURL(A)}}class ja{constructor(){this.messages={},this.messageIdNext=0,this.worker=new Wa,this.worker.onmessage=t=>this.onMessage(t)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const t=this.makeMessageId(),A=new Promise((A,e)=>{this.messages[t]={resolve:A,reject:e}});return{id:t,promise:A}}onMessage(t){const{id:A,result:e,error:n}=t.data,i=this.messages[A];i&&(delete this.messages[A],n?i.reject(n):i.resolve(e))}async call(t,A){const{id:e,promise:n}=this.makeMessagePromiseId();return this.worker.postMessage({name:t,args:A,id:e},{transfer:XA(A)}),n}}let Za=4,Xa=0;const $a=[],tr=[];async function Ar(t){const A=await async function(){const t=$a.shift();if(t)return t;if(Xa<Za){const t=new ja;return Xa+=1,t}return new Promise(t=>{tr.push(t)})}();try{return await t(A)}finally{!function(t){if(Xa>Za)return void(Xa-=1);const A=tr.shift();A?A(t):$a.push(t)}(A)}}class er extends n.aHM{constructor(t){super(t),this.fileLoader=new n.Y9S(t)}load(t,A,e,n){this.fileLoader.setResponseType("arraybuffer"),this.fileLoader.setCrossOrigin(this.crossOrigin),this.fileLoader.setWithCredentials(this.withCredentials),this.fileLoader.setPath(this.path),this.fileLoader.setResourcePath(this.resourcePath),this.fileLoader.setRequestHeader(this.requestHeader),this.fileLoader.load(t,async e=>{if(A){const i=e,s={},a=[];let r=this.fileType;try{const e=rr(i);if("pcsogs"===this.fileType&&void 0===e)throw new Error("Invalid PC SOGS file");if(void 0!==e){r="pcsogs";for(const A of["means","scales","quats","sh0","shN"]){const n=e[A];if(n){const A=n.files;for(const e of A){const A=new URL(e,t).toString();this.manager.itemStart(A);const n=this.loadExtra(A).then(t=>{s[e]=t}).catch(t=>{throw this.manager.itemError(A),t}).finally(()=>{this.manager.itemEnd(A)});a.push(n)}}}}await Promise.all(a);const n=await or({input:i,extraFiles:s,fileType:r,pathOrUrl:t});this.packedSplats?(this.packedSplats.initialize(n),A(this.packedSplats)):A(new lr(n))}catch(t){null==n||n(t)}}},e,n)}async loadAsync(t,A){return new Promise((e,n)=>{this.load(t,t=>{e(t)},A,n)})}async loadExtra(t){return new Promise((A,e)=>{this.fileLoader.load(t,t=>A(t),void 0,t=>e(t))})}parse(t){return new Fa({packedSplats:t})}}var nr=(t=>(t.PLY="ply",t.SPZ="spz",t.SPLAT="splat",t.KSPLAT="ksplat",t.PCSOGS="pcsogs",t))(nr||{});function ir(t){const A=new DataView(t.buffer);if(7957616==(16777215&A.getUint32(0,!0)))return"ply";if(559903==(16777215&A.getUint32(0,!0))){const A=Qe(t,4);return 1347635022===new DataView(A.buffer).getUint32(0,!0)?"spz":void 0}}function sr(t){const A=function(t){const A=t.split(/[?#]/,1)[0],e=Math.max(A.lastIndexOf("/"),A.lastIndexOf("\\")),n=A.slice(e+1),i=n.lastIndexOf(".");return i<=0||i===n.length-1?"":n.slice(i+1).toLowerCase()}(t);return"ply"===A?"ply":"spz"===A?"spz":"splat"===A?"splat":"ksplat"===A?"ksplat":void 0}function ar(t){return void 0!==rr(t)}function rr(t){try{let A;if("string"==typeof t)A=t;else{const e=t instanceof ArrayBuffer?new Uint8Array(t):t;if(e.length>65536)return;A=(new TextDecoder).decode(e)}const e=JSON.parse(A);if(!e||"object"!=typeof e||Array.isArray(e))return;for(const t of["means","scales","quats","sh0"]){if(!e[t]||"object"!=typeof e[t]||Array.isArray(e[t]))return;if(!e[t].shape||!e[t].files)return;if(!("quats"===t||e[t].mins&&e[t].maxs))return}return e}catch{return}}async function or({input:t,extraFiles:A,fileType:e,pathOrUrl:n}){const i=t instanceof ArrayBuffer?new Uint8Array(t):t;let s=e;switch(e||(s=ir(i),!s&&n&&(s=sr(n))),s){case"ply":{const t=new Ua({fileBytes:i});await t.parseHeader();const A=ne(t.numSplats).maxSplats,e={fileBytes:i,packedArray:new Uint32Array(4*A)};return await Ar(async t=>{const{packedArray:A,numSplats:n,extra:i}=await t.call("unpackPly",e);return{packedArray:A,numSplats:n,extra:i}})}case"spz":return await Ar(async t=>{const{packedArray:A,numSplats:e,extra:n}=await t.call("decodeSpz",{fileBytes:i});return{packedArray:A,numSplats:e,extra:n}});case"splat":return await Ar(async t=>{const{packedArray:A,numSplats:e}=await t.call("decodeAntiSplat",{fileBytes:i});return{packedArray:A,numSplats:e}});case"ksplat":return await Ar(async t=>{const{packedArray:A,numSplats:e,extra:n}=await t.call("decodeKsplat",{fileBytes:i});return{packedArray:A,numSplats:e,extra:n}});case"pcsogs":return await Ar(async t=>{const{packedArray:e,numSplats:n,extra:s}=await t.call("decodePcSogs",{fileBytes:i,extraFiles:A});return{packedArray:e,numSplats:n,extra:s}});default:throw new Error(`Unknown splat file type: ${s}`)}}class gr{constructor({maxSplats:t=1}={}){this.numSplats=0,this.maxSplats=ne(t).maxSplats,this.centers=new Float32Array(3*this.maxSplats),this.scales=new Float32Array(3*this.maxSplats),this.quaternions=new Float32Array(4*this.maxSplats),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(3*this.maxSplats)}pushSplat(){const t=this.numSplats;return this.ensureIndex(t),this.numSplats+=1,t}unpushSplat(t){if(t!==this.numSplats-1)throw new Error("Cannot unpush splat from non-last position");this.numSplats-=1}ensureCapacity(t){if(t>this.maxSplats){const A=Math.max(t,2*this.maxSplats),e=new Float32Array(3*A),n=new Float32Array(3*A),i=new Float32Array(4*A),s=new Float32Array(A),a=new Float32Array(3*A);if(e.set(this.centers),n.set(this.scales),i.set(this.quaternions),s.set(this.opacities),a.set(this.colors),this.centers=e,this.scales=n,this.quaternions=i,this.opacities=s,this.colors=a,this.sh1){const t=new Float32Array(9*A);t.set(this.sh1),this.sh1=t}if(this.sh2){const t=new Float32Array(15*A);t.set(this.sh2),this.sh2=t}if(this.sh3){const t=new Float32Array(21*A);t.set(this.sh3),this.sh3=t}this.maxSplats=A}}ensureIndex(t){this.ensureCapacity(t+1)}setCenter(t,A,e,n){this.centers[3*t]=A,this.centers[3*t+1]=e,this.centers[3*t+2]=n}setScale(t,A,e,n){this.scales[3*t]=A,this.scales[3*t+1]=e,this.scales[3*t+2]=n}setQuaternion(t,A,e,n,i){this.quaternions[4*t]=A,this.quaternions[4*t+1]=e,this.quaternions[4*t+2]=n,this.quaternions[4*t+3]=i}setOpacity(t,A){this.opacities[t]=A}setColor(t,A,e,n){this.colors[3*t]=A,this.colors[3*t+1]=e,this.colors[3*t+2]=n}setSh1(t,A){this.sh1||(this.sh1=new Float32Array(9*this.maxSplats));for(let e=0;e<9;++e)this.sh1[9*t+e]=A[e]}setSh2(t,A){this.sh2||(this.sh2=new Float32Array(15*this.maxSplats));for(let e=0;e<15;++e)this.sh2[15*t+e]=A[e]}setSh3(t,A){this.sh3||(this.sh3=new Float32Array(21*this.maxSplats));for(let e=0;e<21;++e)this.sh3[21*t+e]=A[e]}}const cr=class t{constructor(t={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new Ir({packedSplats:this}),this.initialized=Promise.resolve(this),this.reinitialize(t)}reinitialize(t){this.isInitialized=!1,t.url||t.fileBytes||t.construct?this.initialized=this.asyncInitialize(t).then(()=>(this.isInitialized=!0,this)):(this.initialize(t),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(t){t.packedArray?(this.packedArray=t.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/l)*l,this.numSplats=Math.min(this.maxSplats,t.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=t.maxSplats??0,this.numSplats=0),this.extra=t.extra??{}}async asyncInitialize(t){const{url:A,fileBytes:e,construct:n}=t;if(A){const t=new er;t.packedSplats=this,await t.loadAsync(A)}else if(e){const n=await or({input:e,fileType:t.fileType,pathOrUrl:t.fileName??A});this.initialize(n)}if(n){const t=n(this);t instanceof Promise&&await t}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(t){const A=t<=this.maxSplats?this.maxSplats:Math.max(t,2*this.maxSplats),e=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||A>e){this.maxSplats=ne(A).maxSplats;const t=new Uint32Array(4*this.maxSplats);this.packedArray&&t.set(this.packedArray),this.packedArray=t}return this.packedArray}ensureSplatsSh(t,A){let e,n;if(0===t)return this.ensureSplats(A);if(1===t)e=2,n="sh1";else if(2===t)e=4,n="sh2";else{if(3!==t)throw new Error(`Invalid level: ${t}`);e=4,n="sh3"}let i=this.extra[n]?this.extra[n].length/e:0;const s=A<=i?i:Math.max(A,2*i);if(!this.extra[n]||s>i){i=ne(s).maxSplats;const t=new Uint32Array(i*e);this.extra[n]&&t.set(this.extra[n]),this.extra[n]=t}return this.extra[n]}getSplat(t){if(!this.packedArray||t>=this.numSplats)throw new Error("Invalid index");return ee(this.packedArray,t)}setSplat(t,A,e,n,i,s){te(this.ensureSplats(t+1),t,A.x,A.y,A.z,e.x,e.y,e.z,n.x,n.y,n.z,n.w,i,s.r,s.g,s.b),this.numSplats=Math.max(this.numSplats,t+1)}pushSplat(t,A,e,n,i){te(this.ensureSplats(this.numSplats+1),this.numSplats,t.x,t.y,t.z,A.x,A.y,A.z,e.x,e.y,e.z,e.w,n,i.r,i.g,i.b),++this.numSplats}forEachSplat(t){if(this.packedArray&&this.numSplats)for(let A=0;A<this.numSplats;++A){const e=ee(this.packedArray,A);t(A,e.center,e.scales,e.quaternion,e.opacity,e.color)}}ensureGenerate(t){if(this.target&&(t??1)<=this.maxSplats)return!1;this.dispose();const A=ne(t??1),{width:e,height:i,depth:s}=A;return this.maxSplats=A.maxSplats,this.target=new n.y9J(e,i,s,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:n.hxR,minFilter:n.hxR}),this.target.texture.format=n.c90,this.target.texture.type=n.bkx,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(t){let A=0;const e=t.map(t=>{const e=A,n=Math.ceil(t/l)*l;return A+=n,{base:e,count:t}});return{maxSplats:A,mapping:e}}getTexture(){return this.target?this.target.texture:this.source||this.packedArray?this.maybeUpdateSource():t.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:t,height:A,depth:e}=this.source.image;this.maxSplats!==t*A*e&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:t,height:A,depth:e}=ne(this.maxSplats);this.source=new n.rFo(this.packedArray,t,A,e),this.source.format=n.c90,this.source.type=n.bkx,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!t.emptySource){const{width:A,height:e,depth:i,maxSplats:s}=ne(1),a=new Uint32Array(4*s);t.emptySource=new n.rFo(a,A,e,i),t.emptySource.format=n.c90,t.emptySource.type=n.bkx,t.emptySource.internalFormat="RGBA32UI",t.emptySource.needsUpdate=!0}return t.emptySource}prepareProgramMaterial(A){let e=t.generatorProgram.get(A);if(!e){const n=O({index:"int"},{output:"uvec4"},({index:t})=>{A.inputs.index=t;const e=A.outputs.gsplat;return{output:Qt(e)}});t.programTemplate||(t.programTemplate=new ye("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}")),e=new me({graph:n,inputs:{index:"index"},outputs:{output:"target"},template:t.programTemplate}),Object.assign(e.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),t.generatorProgram.set(A,e)}const n=e.prepareMaterial();return t.mesh.material=n,{program:e,material:n}}saveRenderState(t){return{xrEnabled:t.xr.enabled,autoClear:t.autoClear}}resetRenderState(t,A){t.setRenderTarget(null),t.xr.enabled=A.xrEnabled,t.autoClear=A.autoClear}generate({generator:A,base:e,count:n,renderer:i}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(e+n>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:s,material:a}=this.prepareProgramMaterial(A);s.update();const r=this.saveRenderState(i),o=Math.ceil((e+n)/l)*l,g=l*I;for(a.uniforms.targetBase.value=e,a.uniforms.targetCount.value=n;e<o;){const A=Math.floor(e/g);a.uniforms.targetLayer.value=A;const n=A*g,s=Math.floor((e-n)/l),r=Math.min(I,Math.ceil((o-n)/l));this.target.scissor.set(0,s,l,r-s),i.setRenderTarget(this.target,A),i.xr.enabled=!1,i.autoClear=!1,i.render(t.scene,t.camera),e+=l*(r-s)}return this.resetRenderState(i,r),{nextBase:o}}};cr.emptySource=null,cr.programTemplate=null,cr.generatorProgram=new Map,cr.geometry=new n.bdM(2,2),cr.mesh=new n.eaF(cr.geometry,new n.D$Q({visible:!1})),cr.scene=(new n.Z58).add(cr.mesh),cr.camera=new n.i7d;let lr=cr;class Ir extends wt{constructor({packedSplats:t}={}){super({key:"packedSplats",type:At,globals:()=>[gt],value:{texture:lr.getEmpty(),numSplats:0},update:t=>{var A,e;return t.texture=(null==(A=this.packedSplats)?void 0:A.getTexture())??lr.getEmpty(),t.numSplats=(null==(e=this.packedSplats)?void 0:e.numSplats)??0,t}}),this.packedSplats=t}}class hr extends n.CmU{constructor(t,A){super(),this.ordering=t,this.setAttribute("position",new n.THS(ur,3)),this.setIndex(new n.THS(Br,1)),this._maxInstanceCount=t.length,this.instanceCount=A,this.attribute=new n.uWO(t,1,!1,1),this.attribute.setUsage(n.Vnu),this.setAttribute("splatIndex",this.attribute)}update(t,A){this.ordering=t,this.attribute.array=t,this.instanceCount=A,this.attribute.addUpdateRange(0,A),this.attribute.needsUpdate=!0}}const ur=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),Br=new Uint16Array([0,1,2,0,2,3]),dr=class t{constructor(t){if(this.lastTime=null,this.encodeLinear=!1,this.superXY=1,this.display=null,this.sorting=null,this.pending=null,this.sortingCheck=!1,this.readback=new Uint16Array(0),this.spark=t.spark,this.camera=t.camera,this.viewToWorld=t.viewToWorld??new n.kn4,t.target){const{width:A,height:e,doubleBuffer:i}=t.target,s=Math.max(1,Math.min(4,t.target.superXY??1));if(this.superXY=s,A*s>8192||e*s>8192)throw new Error("Target size too large");this.target=new n.nWS(A*s,e*s,{format:n.GWd,type:n.OUM,colorSpace:n.er$}),i&&(this.back=new n.nWS(A*s,e*s,{format:n.GWd,type:n.OUM,colorSpace:n.er$})),this.encodeLinear=!0}this.onTextureUpdated=t.onTextureUpdated,this.sortRadial=t.sortRadial??!0,this.sortDistance=t.sortDistance,this.sortCoorient=t.sortCoorient,this.depthBias=t.depthBias,this.sort360=t.sort360,this.orderingFreelist=new $A({allocate:t=>new Uint32Array(t),valid:(t,A)=>t.length===A}),this.autoUpdate=!1,this.setAutoUpdate(t.autoUpdate??!1)}dispose(){var t;this.setAutoUpdate(!1),this.target&&(this.target.dispose(),this.target=void 0),this.back&&(this.back.dispose(),this.back=void 0),this.display&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.geometry.dispose(),this.display=null),(null==(t=this.pending)?void 0:t.accumulator)&&(this.spark.releaseAccumulator(this.pending.accumulator),this.pending=null)}setAutoUpdate(t){!this.autoUpdate&&t?this.spark.autoViewpoints.push(this):this.autoUpdate&&!t&&(this.spark.autoViewpoints=this.spark.autoViewpoints.filter(t=>t!==this)),this.autoUpdate=t}async prepare({scene:t,camera:A,viewToWorld:e,update:n,forceOrigin:i}){var s;for(e?this.viewToWorld=e:(this.camera=A??this.camera,this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone()));n??1;){const A=i?this.viewToWorld:void 0;if(this.spark.updateInternal({scene:t,originToWorld:A}))break;await new Promise(t=>setTimeout(t,10))}const a=this.spark.active;a!==(null==(s=this.display)?void 0:s.accumulator)&&(this.spark.active.refCount+=1),await this.sortUpdate({accumulator:a,viewToWorld:this.viewToWorld})}renderTarget({scene:t,camera:A}){var e;const i=this.back??this.target;if(!i)throw new Error("Must initialize SparkViewpoint with target");if(!(A=A??this.camera))throw new Error("Must provide camera");if(A instanceof n.ubm){const t=(new n.ubm).copy(A,!1);t.aspect=i.width/i.height,t.updateProjectionMatrix(),A=t}this.viewToWorld=A.matrixWorld.clone();try{this.spark.renderer.setRenderTarget(i),this.spark.prepareViewpoint(this),this.spark.renderer.render(t,A)}finally{this.spark.prepareViewpoint(this.spark.defaultView),this.spark.renderer.setRenderTarget(null)}i!==this.target&&([this.target,this.back]=[this.back,this.target]),null==(e=this.onTextureUpdated)||e.call(this,i.texture)}async readTarget(){if(!this.target)throw new Error("Must initialize SparkViewpoint with target");const{width:t,height:A}=this.target,e=t*A*4;(!this.superPixels||this.superPixels.length<e)&&(this.superPixels=new Uint8Array(e)),await this.spark.renderer.readRenderTargetPixelsAsync(this.target,0,0,t,A,this.superPixels);const{superXY:n}=this;if(1===n)return this.superPixels;const i=t/n,s=A/n,a=i*s*4;(!this.pixels||this.pixels.length<a)&&(this.pixels=new Uint8Array(a));const{superPixels:r,pixels:o}=this,g=n*n;for(let t=0;t<s;t++){const A=t*i;for(let e=0;e<i;e++){const i=e*n;let s=0,a=0,c=0,l=0;for(let A=0;A<n;A++){const e=(t*n+A)*this.target.width;for(let t=0;t<n;t++){const A=4*(e+i+t);s+=r[A],a+=r[A+1],c+=r[A+2],l+=r[A+3]}}const I=4*(A+e);o[I]=s/g,o[I+1]=a/g,o[I+2]=c/g,o[I+3]=l/g}}return o}async prepareRenderPixels({scene:t,camera:A,viewToWorld:e,update:n,forceOrigin:i}){return await this.prepare({scene:t,camera:A,viewToWorld:e,update:n,forceOrigin:i}),this.renderTarget({scene:t,camera:A}),this.readTarget()}autoPoll({accumulator:t}){var A,e,n,i;this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone());let s=!1,a=!1;if(this.display){if(t){s=!0;const{mappingVersion:A}=this.display.accumulator;t.mappingVersion===A&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=t,a=!0)}}else s=!0;const r=(null==(A=this.sorting)?void 0:A.viewToWorld)??(null==(e=this.display)?void 0:e.viewToWorld);r&&!Be({matrix1:this.viewToWorld,matrix2:r,maxDistance:this.sortDistance??.01,minCoorient:this.sortCoorient??this.sortRadial?.99:.999})&&(s=!0),s&&(t&&(t.refCount+=1),t&&(null==(n=this.pending)?void 0:n.accumulator)&&this.pending.accumulator!==(null==(i=this.display)?void 0:i.accumulator)&&this.spark.releaseAccumulator(this.pending.accumulator),this.pending={accumulator:t,viewToWorld:this.viewToWorld,displayed:a},this.driveSort())}async driveSort(){for(var t;;){if(this.sorting||!this.pending)return;const{viewToWorld:A,displayed:e}=this.pending;let n=this.pending.accumulator??(null==(t=this.display)?void 0:t.accumulator);if(n||(n=this.spark.active,n.refCount+=1),this.pending=null,!n)throw new Error("No accumulator to sort");this.sorting={viewToWorld:A},await this.sortUpdate({accumulator:n,viewToWorld:A,displayed:e}),this.sorting=null}}async sortUpdate({accumulator:A,viewToWorld:e,displayed:n=!1}){if(this.sortingCheck)throw new Error("Only one sort at a time");this.sortingCheck=!0,A=A??this.spark.active;const{numSplats:i,maxSplats:s}=A.splats;let a=0,r=this.orderingFreelist.alloc(s);if(i>0){const{reader:n,doubleSortReader:o,dynoSortRadial:g,dynoOrigin:c,dynoDirection:l,dynoDepthBias:I,dynoSort360:h,dynoSplats:u}=t.makeSorter(),B=Math.ceil(s/2);this.readback=n.ensureBuffer(B,this.readback);const d=A.toWorld.clone().invert(),C=e.clone().premultiply(d);g.value=!!this.sort360||this.sortRadial,c.value.set(0,0,0).applyMatrix4(C),l.value.set(0,0,-1).applyMatrix4(C).sub(c.value).normalize(),I.value=this.depthBias??1,h.value=this.sort360??!1,u.packedSplats=A.splats,await n.renderReadback({renderer:this.spark.renderer,reader:o,count:Math.ceil(i/2),readback:this.readback});const E=await Ar(async t=>t.call("sortDoubleSplats",{numSplats:i,readback:this.readback,ordering:r}));this.readback=E.readback,r=E.ordering,a=E.activeSplats}this.updateDisplay({accumulator:A,viewToWorld:e,ordering:r,activeSplats:a,displayed:n}),this.sortingCheck=!1}updateDisplay({accumulator:t,viewToWorld:A,ordering:e,activeSplats:n,displayed:i=!1}){if(this.display){i||t===this.display.accumulator||(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=t),this.display.viewToWorld=A;const s=this.display.geometry.ordering;s.length===e.length?this.display.geometry.update(e,n):(this.display.geometry.dispose(),this.display.geometry=new hr(e,n)),this.orderingFreelist.free(s)}else this.display={accumulator:t,viewToWorld:A,geometry:new hr(e,n)};this.spark.viewpoint===this&&this.spark.prepareViewpoint(this)}static makeSorter(){if(!t.dynos){const A=new xt({value:!0}),e=new Tt({value:new n.Pq0}),i=new Tt({value:new n.Pq0}),s=new vt({value:1}),a=new xt({value:!1}),r=new Ir,o=new Ia,g=O({index:"int"},{rgba8:"vec4"},({index:t})=>{if(!t)throw new Error("No index");const n={sortRadial:A,sortOrigin:e,sortDirection:i,sortDepthBias:s,sort360:a},o=nn(t,H("int",2)),g=Qr({gsplat:et(r,o),...n}),c=Qr({gsplat:et(r,An(o,H("int",1))),...n}),l=Wi({vectorType:"vec2",x:g,y:c});return{rgba8:ui(hi(l))}});t.dynos={dynoSortRadial:A,dynoOrigin:e,dynoDirection:i,dynoDepthBias:s,dynoSort360:a,dynoSplats:r,reader:o,doubleSortReader:g}}return t.dynos}};dr.EMPTY_TEXTURE=new n.gPd,dr.dynos=null;let Cr=dr;const Er=j("\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\n    if (!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) {\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : biasedDepth;\n  }\n");function Qr({gsplat:t,sortRadial:A,sortOrigin:e,sortDirection:n,sortDepthBias:i,sort360:s}){return K({inTypes:{gsplat:tt,sortRadial:"bool",sortOrigin:"vec3",sortDirection:"vec3",sortDepthBias:"float",sort360:"bool"},outTypes:{metric:"float"},globals:()=>[ot,Er],inputs:{gsplat:t,sortRadial:A,sortOrigin:e,sortDirection:n,sortDepthBias:i,sort360:s},statements:({inputs:t,outputs:A})=>{const{gsplat:e,sortRadial:n,sortOrigin:i,sortDirection:s,sortDepthBias:a,sort360:r}=t;return W(`\n        ${A.metric} = computeSort(${e}, ${n}, ${i}, ${s}, ${a}, ${r});\n      `)}}).outputs.metric}class pr{constructor(){this.splats=new lr,this.toWorld=new n.kn4,this.mapping=[],this.refCount=0,this.splatsVersion=-1,this.mappingVersion=-1}ensureGenerate(t){this.splats.ensureGenerate(t)&&(this.mapping=[])}generateSplats({renderer:t,modifier:A,generators:e,forceUpdate:n,originToWorld:i}){const s=this.mapping.reduce((t,A)=>(t.set(A.node,A),t),new Map);let a=0,r=0;for(const{node:i,generator:o,version:g,base:c,count:l}of e){const e=s.get(i);if((n||o!==(null==e?void 0:e.generator)||g!==(null==e?void 0:e.version)||c!==(null==e?void 0:e.base)||l!==(null==e?void 0:e.count))&&o&&l>0){const e=A.apply(o);try{this.splats.generate({generator:e,base:c,count:l,renderer:t})}catch(t){i.generator=void 0,i.generatorError=t}a+=1}r=Math.max(r,c+l)}return this.splats.numSplats=r,this.toWorld=i,this.mapping=e,0!==a}hasCorrespondence(t){return this.mapping.length===t.mapping.length&&this.mapping.every(({node:A,base:e,count:n},i)=>{const{node:s,base:a,count:r}=t.mapping[i];return A===s&&e===a&&n===r})}}let fr,mr=null,yr=!1,wr=!1;const xr=n.Z58.prototype.add;n.Z58.prototype.add=function(t){return yr=yr||function(t){let A=!1;return t instanceof Fa||(t.traverse(t=>{A=A||t instanceof Fa}),A)}(t),wr=wr||t instanceof vr,xr.call(this,t),this};const Sr=n.Z58.prototype.onBeforeRender;n.Z58.prototype.onBeforeRender=function(t){if(yr){if(!wr){const A=fr||new vr({renderer:t});this.add(A)}n.Z58.prototype.onBeforeRender=Sr,n.Z58.prototype.add=xr}};const Dr=class t extends n.eaF{constructor(A){const e=t.makeUniforms(),s=(mr||(i.ShaderChunk.splatDefines="const float LN_SCALE_MIN = -9.0;\nconst float LN_SCALE_MAX = 9.0;\nconst float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; \n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nconst float MAX_PIXEL_RADIUS = 512.0;\nconst float MIN_ALPHA = 0.5 * (1.0 / 255.0); \nconst float MAX_STDDEV = sqrt(8.0);\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    rgba = vec4(uRgba) / 255.0;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),\n        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),\n        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}",mr={splatVertex:"precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float focalDistance;\nuniform float apertureAngle;\nuniform float clipXY;\nuniform float renderScale;\n\nuniform usampler2DArray packedSplats;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n    if (splatIndex == 0xffffffffu) {\n        \n        return;\n    }\n\n    ivec3 texCoord = ivec3(\n        splatIndex & SPLAT_TEX_WIDTH_MASK,\n        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n        splatIndex >> SPLAT_TEX_LAYER_BITS\n    );\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplat(packed, center, scales, quaternion, rgba);\n\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 scaledRenderSize = renderSize * renderScale;\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n    float invZ = 1.0 / viewCenter.z;\n    vec2 J1 = focal * invZ;\n    vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n    mat3 J = mat3(\n        J1.x, 0.0, J2.x,\n        0.0, J1.y, J2.y,\n        0.0, 0.0, 0.0\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    float fullBlurAmount = blurAmount;\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\n        float focusRadius = MAX_PIXEL_RADIUS;\n        if (viewCenter.z < 0.0) {\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\n            focusRadius = focusBlur * apertureRadius;\n        }\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(MAX_PIXEL_RADIUS));\n    }\n\n    \n    float detOrig = a * d - b * b;\n    a += fullBlurAmount;\n    d += fullBlurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));\n    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));\n\n    \n    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}",splatFragment:"precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform float near;\nuniform float far;\nuniform bool encodeLinear;\nuniform float maxStdDev;\nuniform bool disableFalloff;\nuniform float falloff;\n\nuniform bool splatTexEnable;\nuniform sampler3D splatTexture;\nuniform mat2 splatTexMul;\nuniform vec2 splatTexAdd;\nuniform float splatTexNear;\nuniform float splatTexFar;\nuniform float splatTexMid;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\n\nvoid main() {\n    vec4 rgba = vRgba;\n\n    float z = dot(vSplatUv, vSplatUv);\n    if (!splatTexEnable) {\n        if (z > (maxStdDev * maxStdDev)) {\n            discard;\n        }\n    } else {\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\n        float ndcZ = vNdc.z;\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\n        float clampedFar = max(splatTexFar, splatTexNear);\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\n        float logDepth = log2(clampedDepth + 1.0);\n        float logNear = log2(splatTexNear + 1.0);\n        float logFar = log2(clampedFar + 1.0);\n\n        float texZ;\n        if (splatTexMid > 0.0) {\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\n            float logMid = log2(clampedMid + 1.0);\n            texZ = (clampedDepth <= clampedMid) ?\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\n        } else {\n            texZ = (logDepth - logNear) / (logFar - logNear);\n        }\n\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\n        rgba *= modulate;\n    }\n\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\n\n    if (rgba.a < MIN_ALPHA) {\n        discard;\n    }\n    if (encodeLinear) {\n        rgba.rgb = srgbToLinear(rgba.rgb);\n    }\n    fragColor = rgba;\n}"}),mr),a=new n.BKk({glslVersion:n.Wdf,vertexShader:s.splatVertex,fragmentShader:s.splatFragment,uniforms:e,transparent:!0,blending:n.NTi,depthTest:!0,depthWrite:!1,side:n.$EB});super(Mr,a),this.renderScale=1,this.splatTexture=null,this.autoViewpoints=[],this.rotateToAccumulator=new Ht({value:new n.PTz}),this.translateToAccumulator=new Tt({value:new n.Pq0}),this.lastFrame=-1,this.lastUpdateTime=null,this.defaultCameras=[],this.pendingUpdate=null,this.envViewpoint=null,this.frustumCulled=!1,this.renderer=A.renderer,this.material=a,this.uniforms=e;const r=O({gsplat:tt},{gsplat:tt},({gsplat:t})=>{if(!t)throw new Error("gsplat not defined");return{gsplat:t=rt(t,{rotate:this.rotateToAccumulator,translate:this.translateToAccumulator})}});this.modifier=new Ma(r),this.autoUpdate=A.autoUpdate??!0,this.preUpdate=A.preUpdate??!1,this.originDistance=A.originDistance??1,this.maxStdDev=A.maxStdDev??Math.sqrt(8),this.enable2DGS=A.enable2DGS??!1,this.preBlurAmount=A.preBlurAmount??0,this.blurAmount=A.blurAmount??.3,this.focalDistance=A.focalDistance??0,this.apertureAngle=A.apertureAngle??0,this.falloff=A.falloff??1,this.clipXY=A.clipXY??1.4,this.active=new pr,this.accumulatorCount=1,this.freeAccumulators=[];for(let t=0;t<1;++t)this.freeAccumulators.push(new pr),this.accumulatorCount+=1;this.defaultView=new Cr({...A.view,autoUpdate:!0,spark:this}),this.viewpoint=this.defaultView,this.prepareViewpoint(this.viewpoint),this.clock=A.clock?ge(A.clock):new n.zD7,fr=this}static makeUniforms(){return{renderSize:{value:new n.I9Y},near:{value:.1},far:{value:1e3},numSplats:{value:0},renderToViewQuat:{value:new n.PTz},renderToViewPos:{value:new n.Pq0},maxStdDev:{value:1},enable2DGS:{value:!1},preBlurAmount:{value:0},blurAmount:{value:.3},focalDistance:{value:0},apertureAngle:{value:0},falloff:{value:1},clipXY:{value:1.4},renderScale:{value:1},splatTexEnable:{value:!1},splatTexture:{type:"t",value:t.EMPTY_SPLAT_TEXTURE},splatTexMul:{value:new n.k_V},splatTexAdd:{value:new n.I9Y},splatTexNear:{value:.1},splatTexFar:{value:1e3},splatTexMid:{value:0},packedSplats:{type:"t",value:lr.getEmpty()},time:{value:0},deltaTime:{value:0},encodeLinear:{value:!1},debugFlag:{value:!1}}}canAllocAccumulator(){return this.freeAccumulators.length>0||this.accumulatorCount<5}maybeAllocAccumulator(){let t=this.freeAccumulators.pop();if(void 0===t){if(this.accumulatorCount>=5)return null;t=new pr,this.accumulatorCount+=1}return t.refCount=1,t}releaseAccumulator(t){t.refCount-=1,0===t.refCount&&this.freeAccumulators.push(t)}newViewpoint(t){return new Cr({...t,spark:this})}onBeforeRender(A,e,i){var s,a;const r=this.time??this.clock.getElapsedTime(),o=r-(this.viewpoint.lastTime??r);this.viewpoint.lastTime=r;const g=A.info.render.frame,c=g!==this.lastFrame;this.lastFrame=g;const l=this.viewpoint;if(l===this.defaultView){if(c)if(A.xr.isPresenting){const t=A.xr.getCamera().cameras;this.defaultCameras=t.map(t=>t.matrixWorld),this.defaultView.viewToWorld=function(t){if(0===t.length)return null;const A=new n.Pq0,e=new n.PTz,i=new n.Pq0,s=[],a=[];for(const n of t)n.decompose(A,e,i),s.push(A),a.push(e);return(new n.kn4).compose(le(s),Ie(a),new n.Pq0(1,1,1))}(this.defaultCameras)??new n.kn4}else this.defaultView.viewToWorld=i.matrixWorld.clone(),this.defaultCameras=[this.defaultView.viewToWorld];this.autoUpdate&&this.update({scene:e,viewToWorld:this.defaultView.viewToWorld})}if(c&&(this.uniforms.time.value=r,this.uniforms.deltaTime.value=o,this.uniforms.debugFlag.value=performance.now()/1e3%2<1),l.target)this.uniforms.renderSize.value.set(l.target.width,l.target.height);else{const t=A.getDrawingBufferSize(this.uniforms.renderSize.value);if(1===t.x&&1===t.y){const e=null==(s=A.xr.getSession())?void 0:s.renderState.baseLayer;e&&(t.x=e.framebufferWidth,t.y=e.framebufferHeight)}}const I=i;if(this.uniforms.near.value=I.near,this.uniforms.far.value=I.far,this.uniforms.encodeLinear.value=l.encodeLinear,this.uniforms.maxStdDev.value=this.maxStdDev,this.uniforms.enable2DGS.value=this.enable2DGS,this.uniforms.preBlurAmount.value=this.preBlurAmount,this.uniforms.blurAmount.value=this.blurAmount,this.uniforms.focalDistance.value=this.focalDistance,this.uniforms.apertureAngle.value=this.apertureAngle,this.uniforms.falloff.value=this.falloff,this.uniforms.clipXY.value=this.clipXY,this.uniforms.renderScale.value=this.renderScale,this.splatTexture){const{enable:A,texture:e,multiply:n,add:i,near:s,far:a,mid:r}=this.splatTexture;A&&e?(this.uniforms.splatTexEnable.value=!0,this.uniforms.splatTexture.value=e,n?this.uniforms.splatTexMul.value.fromArray(n.elements):this.uniforms.splatTexMul.value.set(.5/this.maxStdDev,0,0,.5/this.maxStdDev),this.uniforms.splatTexAdd.value.set((null==i?void 0:i.x)??.5,(null==i?void 0:i.y)??.5),this.uniforms.splatTexNear.value=s??this.uniforms.near.value,this.uniforms.splatTexFar.value=a??this.uniforms.far.value,this.uniforms.splatTexMid.value=r??0):(this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=t.EMPTY_SPLAT_TEXTURE)}else this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=t.EMPTY_SPLAT_TEXTURE;const h=(null==(a=l.display)?void 0:a.accumulator.toWorld)??new n.kn4,u=i.matrixWorld.clone().invert();h.clone().premultiply(u).decompose(this.uniforms.renderToViewPos.value,this.uniforms.renderToViewQuat.value,new n.Pq0)}prepareViewpoint(t){if(this.viewpoint=t??this.viewpoint,this.viewpoint.display){const{accumulator:t,geometry:A}=this.viewpoint.display;this.uniforms.numSplats.value=t.splats.numSplats,this.uniforms.packedSplats.value=t.splats.getTexture(),this.geometry=A}else this.uniforms.numSplats.value=0,this.uniforms.packedSplats.value=lr.getEmpty(),this.geometry=Mr}update({scene:t,viewToWorld:A}){const e=this.matrixWorld.clone();this.preUpdate?this.updateInternal({scene:t,originToWorld:e,viewToWorld:A}):(this.pendingUpdate={scene:t,originToWorld:e},setTimeout(()=>{if(this.pendingUpdate){const{scene:t,originToWorld:e}=this.pendingUpdate;this.pendingUpdate=null,this.updateInternal({scene:t,originToWorld:e,viewToWorld:A})}},1))}updateInternal({scene:t,originToWorld:A,viewToWorld:e}){var i;if(!this.canAllocAccumulator())return!1;A||(A=this.active.toWorld),e=e??A.clone();const s=this.time??this.clock.getElapsedTime(),a=s-(this.lastUpdateTime??s);this.lastUpdateTime=s;const r=this.active.mapping.reduce((t,A)=>(t.set(A.node,A),t),new Map),{generators:o,globalEdits:g}=this.compileScene(t);for(const t of o)null==(i=t.frameUpdate)||i.call(t,{object:t,time:s,deltaTime:a,viewToWorld:e,globalEdits:g});for(const t of o){const A=r.get(t),e=t.generator?t.numSplats:0;t.generator===(null==A?void 0:A.generator)&&e===(null==A?void 0:A.count)||t.updateVersion()}const c=!Be({matrix1:A,matrix2:this.active.toWorld,maxDistance:this.originDistance})||o.length!==r.size||o.some(t=>{var A;return t.version!==(null==(A=r.get(t))?void 0:A.version)});let l=null;if(c){if(l=this.maybeAllocAccumulator(),!l)throw new Error("Unreachable");const t=!Be({matrix1:A,matrix2:this.active.toWorld,maxDistance:1e-5,minCoorient:.99999}),e=o.map((t,A)=>{const e=r.get(t);return e?[t.version-e.version,e.base,t]:[Number.POSITIVE_INFINITY,t.version,t]}).sort((t,A)=>t[0]!==A[0]?t[0]-A[0]:t[1]-A[1]).map(([t,A,e])=>e),i=e.map(t=>t.numSplats),{maxSplats:s,mapping:a}=l.splats.generateMapping(i),g=e.map((t,A)=>{const{base:e,count:n}=a[A];return{node:t,generator:t.generator,version:t.version,base:e,count:n}});A.clone().invert().decompose(this.translateToAccumulator.value,this.rotateToAccumulator.value,new n.Pq0),l.ensureGenerate(s),l.generateSplats({renderer:this.renderer,modifier:this.modifier,generators:g,forceUpdate:t,originToWorld:A}),l.splatsVersion=this.active.splatsVersion+1;const c=l.hasCorrespondence(this.active);l.mappingVersion=this.active.mappingVersion+(c?0:1),this.releaseAccumulator(this.active),this.active=l,this.prepareViewpoint()}return setTimeout(()=>{for(const t of this.autoViewpoints)t.autoPoll({accumulator:l??void 0})},1),!0}compileScene(t){const A=[];t.traverse(t=>{t instanceof _a&&A.push(t)});const e=new Set;return t.traverseVisible(t=>{if(t instanceof ya){let A=t.parent;for(;null!=A&&!(A instanceof Fa);)A=A.parent;null==A&&e.add(t)}}),{generators:A,globalEdits:Array.from(e)}}async renderEnvMap({renderer:A,scene:e,worldCenter:s,size:a=256,near:r=.1,far:o=1e3,hideObjects:g=[],update:c=!1}){var l,I;if(this.envViewpoint||(this.envViewpoint=this.newViewpoint({sort360:!0})),!t.cubeRender||t.cubeRender.target.width!==a||t.cubeRender.near!==r||t.cubeRender.far!==o){t.cubeRender&&t.cubeRender.target.dispose();const A=new n.o6l(a,{format:n.GWd,generateMipmaps:!0,minFilter:n.NZq}),e=new n.F1T(r,o,A);t.cubeRender={target:A,camera:e,near:r,far:o}}t.pmrem||(t.pmrem=new i.PMREMGenerator(A??this.renderer));const h=(new n.kn4).setPosition(s);await(null==(l=this.envViewpoint)?void 0:l.prepare({scene:e,viewToWorld:h,update:c}));const{target:u,camera:B}=t.cubeRender;B.position.copy(s);const d=new Map;for(const t of g)d.set(t,t.visible),t.visible=!1;this.prepareViewpoint(this.envViewpoint),B.update(A??this.renderer,e),this.prepareViewpoint(this.defaultView);for(const[t,A]of d.entries())t.visible=A;return null==(I=t.pmrem)?void 0:I.fromCubemap(u.texture).texture}recurseSetEnvMap(t,A){t.traverse(t=>{if(t instanceof n.eaF)if(Array.isArray(t.material))for(const e of t.material)e instanceof n._4j&&(e.envMap=A);else t.material instanceof n._4j&&(t.material.envMap=A)})}getRgba({generator:t,rgba:A}){const e=this.active.mapping.find(({node:A})=>A===t);if(!e)throw new Error("Generator not found");return(A=A??new ua).fromPackedSplats({packedSplats:this.active.splats,base:e.base,count:e.count,renderer:this.renderer}),A}async readRgba({generator:t,rgba:A}){return(A=this.getRgba({generator:t,rgba:A})).read()}};Dr.cubeRender=null,Dr.pmrem=null,Dr.EMPTY_SPLAT_TEXTURE=new n.dYF;let vr=Dr;const Mr=new hr(new Uint32Array(1),0);function br(t,A,e){const n=Math.floor(t.length/32);if(32*n!==t.length)throw new Error("Invalid .splat file size");const i=new Float32Array(t.buffer);for(let A=0;A<n;++A){const n=32*A,s=8*A,a=i[s+0],r=i[s+1],o=i[s+2],g=i[s+3],c=i[s+4],l=i[s+5],I=t[n+24]/255,h=t[n+25]/255,u=t[n+26]/255,B=t[n+27]/255,d=(t[n+28]-128)/128;e(A,a,r,o,g,c,l,(t[n+29]-128)/128,(t[n+30]-128)/128,(t[n+31]-128)/128,d,B,I,h,u)}}O({packedSplats:At,index:"int"},{gsplat:tt},({packedSplats:t,index:A})=>{if(!t||!A)throw new Error("Invalid input");return{gsplat:et(t,A)}});const _r={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},Rr={0:0,1:9,2:24,3:45};function Fr(t,A,e,n){var i;const s=4096,a=1024;let r=0;const o=new DataView(t.buffer,r,s);r+=s;const g=o.getUint8(0),c=o.getUint8(1);if(0!==g||c<1)throw new Error(`Unsupported .ksplat version: ${g}.${c}`);const l=o.getUint32(4,!0);o.getUint32(16,!0);const I=o.getUint16(20,!0);if(I<0||I>2)throw new Error(`Invalid .ksplat compression level: ${I}`);const h=o.getFloat32(36,!0)||-1.5,u=o.getFloat32(40,!0)||1.5;let B=s+l*a;for(let A=0;A<l;++A){let A=function(t,A){if(0===I)return K.getFloat32(t+N+4*A,!0);if(1===I)return KA(K.getUint16(t+N+2*A,!0));const e=K.getUint8(t+N+A)/255;return h+e*(u-h)};const s=new DataView(t.buffer,r,a);r+=a;const o=s.getUint32(0,!0),g=s.getUint32(4,!0),c=s.getUint32(8,!0),l=s.getUint32(12,!0),d=s.getFloat32(16,!0),C=s.getUint16(20,!0),E=(s.getUint32(24,!0)||(null==(i=_r[I])?void 0:i.scaleRange))??1,Q=s.getUint32(32,!0),p=Q*c,f=s.getUint32(36,!0),m=4*f,y=C*l+m,w=s.getUint16(40,!0),x=Rr[w],{bytesPerCenter:S,bytesPerScale:D,bytesPerRotation:v,bytesPerColor:M,bytesPerSphericalHarmonicsComponent:b,scaleOffsetBytes:_,rotationOffsetBytes:R,colorOffsetBytes:F,sphericalHarmonicsOffsetBytes:N}=_r[I],k=S+D+v+M+x*b,T=k*g,G=T+y,U=[0,3,6,1,4,7,2,5,8],L=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],H=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],Y=w>=1?new Float32Array(9):void 0,P=w>=2?new Float32Array(15):void 0,J=w>=3?new Float32Array(21):void 0,q=d/2/E,z=B+m,O=B+y,K=new DataView(t.buffer,O,T),V=new Float32Array(t.buffer,z,3*l),W=new Uint32Array(t.buffer,B,f);let j=Q,Z=p;for(let t=0;t<o;++t){const i=t*k;let s;if(t<p)s=Math.floor(t/c);else{const A=W[j-Q];t>=Z+A&&(j+=1,Z+=A),s=j}const a=0===I?K.getFloat32(i+0,!0):(K.getUint16(i+0,!0)-E)*q+V[3*s+0],r=0===I?K.getFloat32(i+4,!0):(K.getUint16(i+2,!0)-E)*q+V[3*s+1],o=0===I?K.getFloat32(i+8,!0):(K.getUint16(i+4,!0)-E)*q+V[3*s+2],g=0===I?K.getFloat32(i+_+0,!0):KA(K.getUint16(i+_+0,!0)),l=0===I?K.getFloat32(i+_+4,!0):KA(K.getUint16(i+_+2,!0)),h=0===I?K.getFloat32(i+_+8,!0):KA(K.getUint16(i+_+4,!0)),u=0===I?K.getFloat32(i+R+0,!0):KA(K.getUint16(i+R+0,!0)),B=0===I?K.getFloat32(i+R+4,!0):KA(K.getUint16(i+R+2,!0)),d=0===I?K.getFloat32(i+R+8,!0):KA(K.getUint16(i+R+4,!0)),C=0===I?K.getFloat32(i+R+12,!0):KA(K.getUint16(i+R+6,!0)),f=K.getUint8(i+F+0)/255,m=K.getUint8(i+F+1)/255,y=K.getUint8(i+F+2)/255;if(e(t,a,r,o,g,l,h,B,d,C,u,K.getUint8(i+F+3)/255,f,m,y),w>=1&&Y){for(const[t,e]of U.entries())Y[t]=A(i,e);if(P)for(const[t,e]of L.entries())P[t]=A(i,e);if(J)for(const[t,e]of H.entries())J[t]=A(i,e);null==n||n(t,Y,P,J)}}B+=G}}class Nr{constructor({fileBytes:t}){this.fileBytes=t instanceof ArrayBuffer?new Uint8Array(t):t,this.reader=new pe({fileBytes:this.fileBytes});const A=new DataView(this.reader.read(16).buffer);if(1347635022!==A.getUint32(0,!0))throw new Error("Invalid SPZ file");if(this.version=A.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=A.getUint32(8,!0),this.shDegree=A.getUint8(12),this.fractionalBits=A.getUint8(13),this.flags=A.getUint8(14),this.flagAntiAlias=!!(1&this.flags),this.reserved=A.getUint8(15),this.parsed=!1}parseSplats(t,A,e,n,i,s){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,1===this.version){const A=this.reader.read(3*this.numSplats*2),e=new Uint16Array(A.buffer);for(let A=0;A<this.numSplats;A++){const n=3*A,i=KA(e[n]),s=KA(e[n+1]),a=KA(e[n+2]);null==t||t(A,i,s,a)}}else{if(2!==this.version)throw new Error("Unreachable");{const A=1<<this.fractionalBits,e=this.reader.read(3*this.numSplats*3);for(let n=0;n<this.numSplats;n++){const i=9*n,s=((e[i+2]<<24|e[i+1]<<16|e[i]<<8)>>8)/A,a=((e[i+5]<<24|e[i+4]<<16|e[i+3]<<8)>>8)/A,r=((e[i+8]<<24|e[i+7]<<16|e[i+6]<<8)>>8)/A;null==t||t(n,s,a,r)}}}{const t=this.reader.read(this.numSplats);for(let e=0;e<this.numSplats;e++)null==A||A(e,t[e]/255)}{const t=this.reader.read(3*this.numSplats),A=Tr/.15;for(let n=0;n<this.numSplats;n++){const i=3*n,s=(t[i]/255-.5)*A+.5,a=(t[i+1]/255-.5)*A+.5,r=(t[i+2]/255-.5)*A+.5;null==e||e(n,s,a,r)}}{const t=this.reader.read(3*this.numSplats);for(let A=0;A<this.numSplats;A++){const e=3*A,i=Math.exp(t[e]/16-10),s=Math.exp(t[e+1]/16-10),a=Math.exp(t[e+2]/16-10);null==n||n(A,i,s,a)}}{const t=this.reader.read(3*this.numSplats);for(let A=0;A<this.numSplats;A++){const e=3*A,n=t[e]/127.5-1,s=t[e+1]/127.5-1,a=t[e+2]/127.5-1,r=Math.sqrt(Math.max(0,1-n*n-s*s-a*a));null==i||i(A,n,s,a,r)}}if(s&&this.shDegree>=1){const t=new Float32Array(9),A=this.shDegree>=2?new Float32Array(15):void 0,e=this.shDegree>=3?new Float32Array(21):void 0,n=this.reader.read(this.numSplats*kr[this.shDegree]*3);let i=0;for(let a=0;a<this.numSplats;a++){for(let A=0;A<9;++A)t[A]=(n[i+A]-128)/128;if(i+=9,A){for(let t=0;t<15;++t)A[t]=(n[i+t]-128)/128;i+=15}if(e){for(let t=0;t<21;++t)e[t]=(n[i+t]-128)/128;i+=21}null==s||s(a,t,A,e)}}}}const kr={1:3,2:8,3:15},Tr=.28209479177387814;class Gr{constructor({numSplats:t,shDegree:A,fractionalBits:e=12,flagAntiAlias:n=!0}){this.clippedCount=0;const i=16+t*(19+(A>=1?9:0)+(A>=2?15:0)+(A>=3?21:0));this.buffer=new ArrayBuffer(i),this.view=new DataView(this.buffer),this.view.setUint32(0,1347635022,!0),this.view.setUint32(4,2,!0),this.view.setUint32(8,t,!0),this.view.setUint8(12,A),this.view.setUint8(13,e),this.view.setUint8(14,n?1:0),this.view.setUint8(15,0),this.numSplats=t,this.shDegree=A,this.fractionalBits=e,this.fraction=1<<e,this.flagAntiAlias=n}setCenter(t,A,e,n){const i=Math.round(A*this.fraction),s=Math.max(-8388607,Math.min(8388607,i)),a=Math.round(e*this.fraction),r=Math.max(-8388607,Math.min(8388607,a)),o=Math.round(n*this.fraction),g=Math.max(-8388607,Math.min(8388607,o));(i!==s||a!==r||o!==g)&&(this.clippedCount+=1);const c=16+9*t;this.view.setUint8(c,255&s),this.view.setUint8(c+1,s>>8&255),this.view.setUint8(c+2,s>>16&255),this.view.setUint8(c+3,255&r),this.view.setUint8(c+4,r>>8&255),this.view.setUint8(c+5,r>>16&255),this.view.setUint8(c+6,255&g),this.view.setUint8(c+7,g>>8&255),this.view.setUint8(c+8,g>>16&255)}setAlpha(t,A){const e=16+9*this.numSplats+t;this.view.setUint8(e,Math.max(0,Math.min(255,Math.round(255*A))))}static scaleRgb(t){const A=255*((t-.5)/(Tr/.15)+.5);return Math.max(0,Math.min(255,Math.round(A)))}setRgb(t,A,e,n){const i=16+10*this.numSplats+3*t;this.view.setUint8(i,Gr.scaleRgb(A)),this.view.setUint8(i+1,Gr.scaleRgb(e)),this.view.setUint8(i+2,Gr.scaleRgb(n))}setScale(t,A,e,n){const i=16+13*this.numSplats+3*t;this.view.setUint8(i,Math.max(0,Math.min(255,Math.round(16*(Math.log(A)+10))))),this.view.setUint8(i+1,Math.max(0,Math.min(255,Math.round(16*(Math.log(e)+10))))),this.view.setUint8(i+2,Math.max(0,Math.min(255,Math.round(16*(Math.log(n)+10)))))}setQuat(t,A,e,n,i){const s=16+16*this.numSplats+3*t,a=i<0;this.view.setUint8(s,Math.max(0,Math.min(255,Math.round(127.5*((a?-A:A)+1))))),this.view.setUint8(s+1,Math.max(0,Math.min(255,Math.round(127.5*((a?-e:e)+1))))),this.view.setUint8(s+2,Math.max(0,Math.min(255,Math.round(127.5*((a?-n:n)+1)))))}static quantizeSh(t,A){const e=Math.round(128*t)+128,n=1<<8-A,i=Math.floor((e+n/2)/n)*n;return Math.max(0,Math.min(255,i))}setSh(t,A,e,n){const i=kr[this.shDegree]||0,s=16+19*this.numSplats+t*i*3;for(let t=0;t<9;++t)this.view.setUint8(s+t,Gr.quantizeSh(A[t],5));if(e){const t=s+9;for(let A=0;A<15;++A)this.view.setUint8(t+A,Gr.quantizeSh(e[A],4));if(n){const A=t+15;for(let t=0;t<21;++t)this.view.setUint8(A+t,Gr.quantizeSh(n[t],4))}}}async finalize(){const t=new Uint8Array(this.buffer),A=new ReadableStream({async start(A){A.enqueue(t),A.close()}}).pipeThrough(new CompressionStream("gzip")),e=new Response(A),n=await e.arrayBuffer();return console.log("Compressed",t.length,"bytes to",n.byteLength,"bytes"),new Uint8Array(n)}}async function Ur(t){var A,e,i;const s=new gr,{inputs:a,clipXyz:r,maxSh:o,fractionalBits:g=12,opacityThreshold:c}=t;for(const t of a){let a=function(t){return t.multiplyScalar(h),t.applyQuaternion(u),t.add(B),t},o=function(t){return t.multiplyScalar(h),t},g=function(t){return t.premultiply(u),t},l=function(t){return!d||d.containsPoint(t)},I=function(t){return void 0===c||t>=c};const h=(null==(A=t.transform)?void 0:A.scale)??1,u=(new n.PTz).fromArray((null==(e=t.transform)?void 0:e.quaternion)??[0,0,0,1]),B=(new n.Pq0).fromArray((null==(i=t.transform)?void 0:i.translate)??[0,0,0]),d=r?new n.NRn((new n.Pq0).fromArray(r.min),(new n.Pq0).fromArray(r.max)):void 0;let C=t.fileType;switch(C||(C=ir(t.fileBytes),!C&&t.pathOrUrl&&(C=sr(t.pathOrUrl))),C){case nr.PLY:{const A=new Ua({fileBytes:t.fileBytes});await A.parseHeader();let e=null;A.parseSplats((t,A,i,r,c,h,u,B,d,C,E,Q,p,f,m)=>{const y=a(new n.Pq0(A,i,r));if(l(y)&&I(Q)){e=s.pushSplat(),s.setCenter(e,y.x,y.y,y.z);const t=o(new n.Pq0(c,h,u));s.setScale(e,t.x,t.y,t.z);const A=g(new n.PTz(B,d,C,E));s.setQuaternion(e,A.x,A.y,A.z,A.w),s.setOpacity(e,Q),s.setColor(e,p,f,m)}else e=null},(t,A,n,i)=>{A&&null!==e&&s.setSh1(e,A),n&&null!==e&&s.setSh2(e,n),i&&null!==e&&s.setSh3(e,i)});break}case nr.SPZ:{const A=new Nr({fileBytes:t.fileBytes}),e=new Int32Array(A.numSplats);e.fill(-1);const i=new Float32Array(3*A.numSplats),r=new n.Pq0;A.parseSplats((t,A,e,s)=>{const r=a(new n.Pq0(A,e,s));i[3*t]=r.x,i[3*t+1]=r.y,i[3*t+2]=r.z},(t,A)=>{r.fromArray(i,3*t),l(r)&&I(A)&&(e[t]=s.pushSplat(),s.setCenter(e[t],r.x,r.y,r.z),s.setOpacity(e[t],A))},(t,A,n,i)=>{e[t]>=0&&s.setColor(e[t],A,n,i)},(t,A,i,a)=>{if(e[t]>=0){const r=o(new n.Pq0(A,i,a));s.setScale(e[t],r.x,r.y,r.z)}},(t,A,i,a,r)=>{if(e[t]>=0){const o=g(new n.PTz(A,i,a,r));s.setQuaternion(e[t],o.x,o.y,o.z,o.w)}},(t,A,n,i)=>{e[t]>=0&&(s.setSh1(e[t],A),n&&s.setSh2(e[t],n),i&&s.setSh3(e[t],i))});break}case nr.SPLAT:br(t.fileBytes,0,(t,A,e,i,r,c,h,u,B,d,C,E,Q,p,f)=>{const m=a(new n.Pq0(A,e,i));if(l(m)&&I(E)){const t=s.pushSplat();s.setCenter(t,m.x,m.y,m.z);const A=o(new n.Pq0(r,c,h));s.setScale(t,A.x,A.y,A.z);const e=g(new n.PTz(u,B,d,C));s.setQuaternion(t,e.x,e.y,e.z,e.w),s.setOpacity(t,E),s.setColor(t,Q,p,f)}});break;case nr.KSPLAT:{let A=null;Fr(t.fileBytes,0,(t,e,i,r,c,h,u,B,d,C,E,Q,p,f,m)=>{const y=a(new n.Pq0(e,i,r));if(l(y)&&I(Q)){A=s.pushSplat(),s.setCenter(A,y.x,y.y,y.z);const t=o(new n.Pq0(c,h,u));s.setScale(A,t.x,t.y,t.z);const e=g(new n.PTz(B,d,C,E));s.setQuaternion(A,e.x,e.y,e.z,e.w),s.setOpacity(A,Q),s.setColor(A,p,f,m)}else A=null},(t,e,n,i)=>{null!==A&&(s.setSh1(A,e),n&&s.setSh2(A,n),i&&s.setSh3(A,i))});break}default:throw new Error(`transcodeSpz not implemented for ${C}`)}}const l=Math.min(o??3,s.sh3?3:s.sh2?2:s.sh1?1:0),I=new Gr({numSplats:s.numSplats,shDegree:l,fractionalBits:g,flagAntiAlias:!0});for(let t=0;t<s.numSplats;++t){const A=3*t,e=4*t;I.setCenter(t,s.centers[A],s.centers[A+1],s.centers[A+2]),I.setScale(t,s.scales[A],s.scales[A+1],s.scales[A+2]),I.setQuat(t,s.quaternions[e],s.quaternions[e+1],s.quaternions[e+2],s.quaternions[e+3]),I.setAlpha(t,s.opacities[t]),I.setRgb(t,s.colors[A],s.colors[A+1],s.colors[A+2]),s.sh1&&l>=1&&I.setSh(t,s.sh1.slice(9*t,9*(t+1)),l>=2&&s.sh2?s.sh2.slice(15*t,15*(t+1)):void 0,l>=3&&s.sh3?s.sh3.slice(21*t,21*(t+1)):void 0)}return{fileBytes:await I.finalize(),clippedCount:I.clippedCount}}class Lr{constructor(t){this.mesh=t.mesh,this.numSplats=t.numSplats??this.mesh.numSplats;const{width:A,height:e,depth:i,maxSplats:s}=ne(this.numSplats);this.skinData=new Uint16Array(4*s),this.skinTexture=new n.rFo(this.skinData,A,e,i),this.skinTexture.format=n.c90,this.skinTexture.type=n.cHt,this.skinTexture.internalFormat="RGBA16UI",this.skinTexture.needsUpdate=!0,this.numBones=t.numBones??256,this.boneData=new Float32Array(16*this.numBones),this.boneTexture=new n.GYF(this.boneData,4,this.numBones,n.GWd,n.RQf),this.boneTexture.internalFormat="RGBA32F",this.boneTexture.needsUpdate=!0,this.uniform=new wt({key:"skinning",type:Hr,globals:()=>[Yr],value:{numSplats:this.numSplats,numBones:this.numBones,skinTexture:this.skinTexture,boneTexture:this.boneTexture}})}modify(t){return function(t,A){return new q({inTypes:{gsplat:tt,skinning:Hr},outTypes:{gsplat:tt},globals:()=>[Yr,Pr],inputs:{gsplat:t,skinning:A},statements:({inputs:t,outputs:A})=>{const{skinning:e}=t,{gsplat:n}=A;return W(`\n        ${n} = ${t.gsplat};\n        if (isGsplatActive(${n}.flags)) {\n          applyGsplatSkinning(\n            ${e}.numSplats, ${e}.numBones,\n            ${e}.skinTexture, ${e}.boneTexture,\n            ${n}.index, ${n}.center, ${n}.quaternion\n          );\n        }\n      `)}}).outputs.gsplat}(t,this.uniform)}setRestQuatPos(t,A,e){const n=16*t;this.boneData[n+0]=A.x,this.boneData[n+1]=A.y,this.boneData[n+2]=A.z,this.boneData[n+3]=A.w,this.boneData[n+4]=e.x,this.boneData[n+5]=e.y,this.boneData[n+6]=e.z,this.boneData[n+7]=0,this.boneData[n+8]=0,this.boneData[n+9]=0,this.boneData[n+10]=0,this.boneData[n+11]=1,this.boneData[n+12]=0,this.boneData[n+13]=0,this.boneData[n+14]=0,this.boneData[n+15]=0}setBoneQuatPos(t,A,e){const i=16*t,s=new n.PTz(this.boneData[i+0],this.boneData[i+1],this.boneData[i+2],this.boneData[i+3]),a=new n.Pq0(this.boneData[i+4],this.boneData[i+5],this.boneData[i+6]),r=s.clone().invert(),o=e.clone().sub(a);o.applyQuaternion(r),r.multiply(A);const g=new n.PTz(o.x,o.y,o.z,0).multiply(s);this.boneData[i+8]=r.x,this.boneData[i+9]=r.y,this.boneData[i+10]=r.z,this.boneData[i+11]=r.w,this.boneData[i+12]=.5*g.x,this.boneData[i+13]=.5*g.y,this.boneData[i+14]=.5*g.z,this.boneData[i+15]=.5*g.w}setSplatBones(t,A,e){const n=4*t;this.skinData[n+0]=Math.min(255,Math.max(0,Math.round(255*e.x)))+(A.x<<8),this.skinData[n+1]=Math.min(255,Math.max(0,Math.round(255*e.y)))+(A.y<<8),this.skinData[n+2]=Math.min(255,Math.max(0,Math.round(255*e.z)))+(A.z<<8),this.skinData[n+3]=Math.min(255,Math.max(0,Math.round(255*e.w)))+(A.w<<8)}updateBones(){this.boneTexture.needsUpdate=!0,this.mesh.needsUpdate=!0}}const Hr={type:"GsplatSkinning"},Yr=j("\n  struct GsplatSkinning {\n    int numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    sampler2D boneTexture;\n  };\n"),Pr=j("\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n    usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) {\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if (boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the opposite direction\n          boneQuat = -boneQuat;\n          boneDual = -boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual += weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, quaternion);\n  }\n");function Jr({splats:t,extents:A,stepSize:e=1,pointRadius:i=.01,pointShadowScale:s=2,opacity:a=1,color:r}){const o=1e-6,g=new n.Pq0,c=new n.Pq0,l=new n.PTz(0,0,0,1);null==r&&(r=(t,A)=>t.set(.55+.45*Math.cos(1*A.x),.55+.45*Math.cos(1*A.y),.55+.45*Math.cos(1*A.z)));const I=new n.Q1f;for(let n=A.min.z;n<A.max.z+o;n+=e)for(let h=A.min.y;h<A.max.y+o;h+=e)for(let u=A.min.x;u<A.max.x+o;u+=e){g.set(u,h,n);for(let A=0;A<2;++A)c.setScalar(i*(A?1:s)),A?"function"==typeof r?r(I,g):I.copy(r):I.setScalar(0),t.pushSplat(g,c,l,a,I)}}function qr({splats:t,scale:A=.25,axisRadius:e=.0075,axisShadowScale:i=2,origins:s=[new n.Pq0]}){const a=new n.Pq0,r=new n.Pq0,o=new n.PTz(0,0,0,1),g=new n.Q1f;for(const n of s)for(let s=0;s<3;++s){a.set(n.x+(0===s?A:0),n.y+(1===s?A:0),n.z+(2===s?A:0));for(let n=0;n<2;++n)r.set((0===s?A:e)*(n?1:i),(1===s?A:e)*(n?1:i),(2===s?A:e)*(n?1:i)),g.setRGB(0===n?0:0===s?1:0,0===n?0:1===s?1:0,0===n?0:2===s?1:0),t.pushSplat(a,r,o,1,g)}}function zr({splats:t,origin:A=new n.Pq0,radius:e=1,maxDepth:i=3,filter:s=null,pointRadius:a=.02,pointThickness:r=.001,color:o=new n.Q1f(1,1,1)}){const g={};function c(t){if(s&&!s(t))return;const A=`${t.x},${t.y},${t.z}`;g[A]||(g[A]=t)}function l(t,A,e,s){if(c(A),c(e),c(s),t>=i)return;const a=(new n.Pq0).addVectors(A,e).normalize(),r=(new n.Pq0).addVectors(e,s).normalize(),o=(new n.Pq0).addVectors(s,A).normalize();l(t+1,A,a,o),l(t+1,a,e,r),l(t+1,o,r,s),l(t+1,a,r,o)}for(const t of[-1,1])for(const A of[-1,1])for(const e of[-1,1])l(0,new n.Pq0(t,0,0),new n.Pq0(0,A,0),new n.Pq0(0,0,e));const I=Object.values(g),h=new n.Pq0(a,a,r),u=new n.PTz,B="function"==typeof o?new n.Q1f:o;for(const i of I)u.setFromUnitVectors(new n.Pq0(0,0,-1),i),"function"==typeof o&&o(B,i),i.multiplyScalar(e),i.add(A),t.pushSplat(i,h,u,1,B)}function Or({text:t,font:A,fontSize:e,color:i,rgb:s,dotRadius:a,textAlign:r,lineHeight:o,objectScale:g}){A=A??"Arial",e=e??32,i=i??new n.Q1f(1,1,1),a=a??.8,r=r??"start",o=o??1,g=g??1;const c=t.split("\n"),l=document.createElement("canvas"),I=l.getContext("2d");if(!I)throw new Error("Failed to create canvas context");I.font=`${e}px ${A}`,I.textAlign=r;const h=I.measureText(""),u=h.fontBoundingBoxAscent+h.fontBoundingBoxDescent;let B=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,C=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY;for(let t=0;t<c.length;++t){const A=I.measureText(c[t]),e=u*o*t;B=Math.min(B,-A.actualBoundingBoxLeft),d=Math.max(d,A.actualBoundingBoxRight),C=Math.min(C,e-A.actualBoundingBoxAscent),E=Math.max(E,e+A.actualBoundingBoxDescent)}const Q=Math.floor(B),p=Math.floor(C),f=Math.ceil(d)-Q,m=Math.ceil(E)-p;l.width=f,l.height=m,I.font=`${e}px ${A}`,I.textAlign=r,I.textBaseline="alphabetic",I.fillStyle="#FFFFFF";for(let t=0;t<c.length;++t){const A=u*o*t-p;I.fillText(c[t],-Q,A)}const y=I.getImageData(0,0,f,m),w=new Uint8Array(y.data.buffer),x=new lr,S=new n.Pq0,D=(new n.Pq0).setScalar(a*g),v=new n.PTz(0,0,0,1);s=s??new n.Q1f(1,1,1);let M=0;for(let t=0;t<m;++t)for(let A=0;A<f;++A){const e=w[M+3];if(e>0){const n=e/255;S.set(A-.5*(f-1),.5*(m-1)-t,0),S.multiplyScalar(g),x.pushSplat(S,D,v,n,s)}M+=4}const b=new Fa({packedSplats:x});return b.recolor=i,b}function Kr({url:t,dotRadius:A,subXY:e,forEachSplat:i}){return A=A??.8,e=Math.max(1,Math.floor(e??1)),new Fa({constructSplats:async s=>new Promise((a,r)=>{const o=new Image;o.crossOrigin="anonymous",o.onerror=r,o.onload=()=>{const{width:t,height:g}=o,c=document.createElement("canvas");c.width=t,c.height=g;const l=c.getContext("2d");if(!l)return void r(new Error("Failed to create canvas context"));l.imageSmoothingEnabled=!0,l.imageSmoothingQuality="high";const I=Math.round(t/e),h=Math.round(g/e);l.drawImage(o,0,0,I,h);try{const t=l.getImageData(0,0,I,h),e=new Uint8Array(t.data.buffer),r=new n.Pq0,o=(new n.Pq0).setScalar(A),g=new n.PTz(0,0,0,1),c=new n.Q1f;let u=0;for(let t=0;t<h;++t)for(let n=0;n<I;++n){const a=4*u,l=e[a+3];if(l>0){let B=l/255;c.set(e[a+0]/255,e[a+1]/255,e[a+2]/255),r.set(n-.5*(I-1),.5*(h-1)-t,0),o.setScalar(A),g.set(0,0,0,1);let d=!0;if(i){const t=i(I,h,u,r,o,g,B,c);B=t??B,d=null!==t}d&&s.pushSplat(r,o,g,B,c)}u+=1}a()}catch(t){r(t)}},o.src=t})})}const Vr={box:new n.NRn(new n.Pq0(-1,-1,-1),new n.Pq0(1,1,1)),density:100,fallDirection:new n.Pq0(-1,-3,1).normalize(),fallVelocity:.02,wanderScale:.04,wanderVariance:2,color1:new n.Q1f(1,1,1),color2:new n.Q1f(.5,.5,1),minScale:.001,maxScale:.005,anisoScale:new n.Pq0(1,1,1)},Wr={box:new n.NRn(new n.Pq0(-2,-1,-2),new n.Pq0(2,5,2)),density:10,fallDirection:new n.Pq0(0,-1,0),fallVelocity:2,wanderScale:.1,wanderVariance:1,color1:new n.Q1f(1,1,1),color2:new n.Q1f(.25,.25,.5),minScale:.005,maxScale:.01,anisoScale:new n.Pq0(.1,1,.1)},jr=Object.freeze(Object.defineProperty({__proto__:null,DEFAULT_RAIN:Wr,DEFAULT_SNOW:Vr,snowBox:function({box:t,minY:A,numSplats:e,density:i,anisoScale:s,minScale:a,maxScale:r,fallDirection:o,fallVelocity:g,wanderScale:c,wanderVariance:l,color1:I,color2:h,opacity:u,onFrame:B}){const d=((t=t??new n.NRn(new n.Pq0(-1,-1,-1),new n.Pq0(1,1,1))).max.x-t.min.x)*(t.max.y-t.min.y)*(t.max.z-t.min.z);i=i??100,e=e??Math.max(1,Math.min(1e6,Math.round(d*i)));const C=mt(a??.001),E=mt(r??.005),Q=yt(((null==s?void 0:s.clone())??new n.Pq0(1,1,1)).normalize()),p=yt((o??new n.Pq0(0,-1,0)).normalize()),f=mt(g??.02),m=mt(c??.01),y=mt(l??2),w=yt(I??new n.Q1f(1,1,1)),x=yt(h??new n.Q1f(.5,.5,1)),S=mt(u??1),D=mt(0),v=yt(new n.Pq0(0,0,0)),M=yt(t.min),b=yt(t.max),_=mt(A??Number.NEGATIVE_INFINITY),R=en(b,M),F=new _a({numSplats:e,generator:O({index:"int"},{gsplat:tt},({index:t})=>{if(!t)throw new Error("index not defined");const A=ms(t),e=Vi(A).outputs.w;let i=ci(A),s=gn(nn(e,H("float",100)));s=Vs(nn(U("float","PI"),s)),s=An(C,nn(s,en(E,C)));const a=nn(s,Q),r=gn(nn(e,H("float",10))),o=gn(e),g=ln(w,x,o),c=nn(g,r),l=ms(Wi({vectorType:"ivec2",x:t,y:H("int",6837)}));let I=ci(l),h=nn(Vi(l).outputs.w,y);h=An(D,h),i=An(i,v);const u=rn(i,H("vec3",new n.Pq0(1,1,1)));i=An(M,nn(R,u));const B=H("vec4",new n.PTz(0,0,0,1));I=Vs(An(ci(h),I)),I=nn(I,m);let d=An(i,I),p=Vi(d).outputs.y;p=cn(_,p),d=Wi({vector:d,y:p});let f=st({flags:U("uint","GSPLAT_FLAG_ACTIVE"),index:t,center:d,scales:a,quaternion:B,rgb:c,opacity:S});return f=N.applyGsplat(f),{gsplat:f}},{globals:()=>[ot]}),update:({object:t,time:A,deltaTime:e})=>{D.value=A,N.update(F);const n=p.value.clone().multiplyScalar(f.value*e);v.value.add(n),t.visible=S.value>0,null==B||B({object:t,time:A,deltaTime:e}),F.updateVersion()}}),N=new ba;return{snow:F,min:M,max:b,minY:_,color1:w,color2:x,opacity:S,fallVelocity:f,wanderVariance:y,wanderScale:m,fallDirection:p,minScale:C,maxScale:E,anisoScale:Q}},staticBox:function({box:t,cells:A,dotScale:e,color:i,opacity:s}){A.x=Math.max(1,Math.round(A.x)),A.y=Math.max(1,Math.round(A.y)),A.z=Math.max(1,Math.round(A.z)),s=s??1;const a=A.x*A.y*A.z,r=H("int",A.x),o=H("int",A.y);H("int",A.z);const g=mt(0),c=new _a({numSplats:a,generator:O({index:"int"},{gsplat:tt},({index:a})=>{if(!a)throw new Error("index is undefined");const c=an(a,r),I=sn(a,r),h=an(I,o),u=sn(I,o),B=Wi({vectorType:"ivec3",x:c,y:h,z:u}),d=Ii(g),C=Wi({vectorType:"ivec2",x:a,y:d}),E=fs(C),Q=H("vec3",t.min),p=H("vec3",t.max),f=en(p,Q),m=sn(An(ci(B),E),H("vec3",A));let y,w,x;i?(y=H("float",i.r),w=H("float",i.g),x=H("float",i.b)):({r:y,g:w,b:x}=Vi(m).outputs);const S=Wi({vectorType:"vec4",r:y,g:w,b:x,a:H("float",s)}),D=An(Q,nn(f,m)),v=ci(H("float",e)),M=H("vec4",new n.PTz(0,0,0,1));let b=st({flags:U("uint","GSPLAT_FLAG_ACTIVE"),index:a,center:D,scales:v,quaternion:M,rgba:S});return b=l.applyGsplat(b),{gsplat:b}},{globals:()=>[ot]}),update:({time:t})=>{g.value=t,l.update(c),c.updateVersion()}}),l=new ba;return c}},Symbol.toStringTag,{value:"Module"}));function Zr(t){return O({gsplat:tt},{gsplat:tt},({gsplat:A})=>{if(!A)throw new Error("No gsplat input");let e=at(A);const n=t.applyGsplat(A),i=it(n).outputs.center,s=at(n),a=Oi(i,s),r=Jn(a,H("float",0));e=qn(r,on(e),e);const o=An(nn(e,H("float",.5)),H("float",.5));return{gsplat:A=st({gsplat:A,rgb:o})}})}function Xr(t,A,e,n){return O({gsplat:tt},{gsplat:tt},({gsplat:i})=>{if(!i)throw new Error("No gsplat input");let{center:s}=it(i).outputs;s=t.apply(s);const{z:a}=Vi(s).outputs;let r=ys(on(a),A,e);return r=qn(n,en(H("float",1),r),r),{gsplat:i=st({gsplat:i,r,g:r,b:r})}})}const $r=Object.freeze(Object.defineProperty({__proto__:null,makeDepthColorModifier:Xr,makeNormalColorModifier:Zr,setDepthColor:function(t,A,e,n){t.enableWorldToView=!0;const i=H("float",A),s=H("float",e),a=H("bool",n??!1);return t.worldModifier=Xr(t.context.worldToView,i,s,a),t.updateGenerator(),{minDepth:i,maxDepth:s,reverse:a}},setWorldNormalColor:function(t){t.enableWorldToView=!0,t.worldModifier=Zr(t.context.worldToView),t.updateGenerator()}},Symbol.toStringTag,{value:"Module"})),to=class t{static createButton(A,e={}){const n=navigator.xr;if(!n)return null;const i=n,s=document.createElement("button");function a(){s.style.display="none",s.style.cursor="auto",s.style.left="calc(50% - 75px)",s.style.width="150px",s.onmouseenter=null,s.onmouseleave=null,s.onclick=null}var r;return A.xr.enabled=!0,A.xr.setReferenceSpaceType("local"),s.id="VRButton",s.style.display="none",(r=s).style.position="absolute",r.style.bottom="20px",r.style.padding="12px 6px",r.style.border="1px solid #fff",r.style.borderRadius="4px",r.style.background="rgba(0,0,0,0.1)",r.style.color="#fff",r.style.font="normal 13px sans-serif",r.style.textAlign="center",r.style.opacity="0.5",r.style.outline="none",r.style.zIndex="999",i.isSessionSupported("immersive-vr").then(n=>{n?function(){let t=null;async function n(e){console.log("onSessionStarted"),e.addEventListener("end",a),await A.xr.setSession(e),s.textContent="EXIT VR",t=e}function a(){console.log("onSessionEnded"),null==t||t.removeEventListener("end",a),s.textContent="ENTER VR",t=null}s.style.display="",s.style.cursor="pointer",s.style.left="calc(50% - 100px)",s.style.width="200px",s.style.height="100px",s.textContent="ENTER VR";const r={...e,optionalFeatures:[...e.optionalFeatures||[]]};s.onmouseenter=()=>{s.style.opacity="1.0"},s.onmouseleave=()=>{s.style.opacity="0.5"},s.onclick=()=>{null===t?(console.log("requesting session"),i.requestSession("immersive-vr",r).then(n)):(console.log("ending session"),t.end())}}():(a(),s.textContent="VR NOT SUPPORTED"),n&&t.xrSessionIsGranted&&s.click()}).catch(function(t){a(),console.warn("Exception when trying to call xr.isSessionSupported",t),s.textContent="VR NOT ALLOWED"}),s}static registerSessionGrantedListener(){const A=navigator.xr;if(!A)return null;const e=A;/WebXRViewer\//i.test(navigator.userAgent)||e.addEventListener("sessiongranted",()=>{t.xrSessionIsGranted=!0})}};to.xrSessionIsGranted=!1;let Ao=to;Ao.registerSessionGrantedListener();var eo=(t=>(t.w="wrist",t.t0="thumb-metacarpal",t.t1="thumb-phalanx-proximal",t.t2="thumb-phalanx-distal",t.t3="thumb-tip",t.i0="index-finger-metacarpal",t.i1="index-finger-phalanx-proximal",t.i2="index-finger-phalanx-intermediate",t.i3="index-finger-phalanx-distal",t.i4="index-finger-tip",t.m0="middle-finger-metacarpal",t.m1="middle-finger-phalanx-proximal",t.m2="middle-finger-phalanx-intermediate",t.m3="middle-finger-phalanx-distal",t.m4="middle-finger-tip",t.r0="ring-finger-metacarpal",t.r1="ring-finger-phalanx-proximal",t.r2="ring-finger-phalanx-intermediate",t.r3="ring-finger-phalanx-distal",t.r4="ring-finger-tip",t.p0="pinky-finger-metacarpal",t.p1="pinky-finger-phalanx-proximal",t.p2="pinky-finger-phalanx-intermediate",t.p3="pinky-finger-phalanx-distal",t.p4="pinky-finger-tip",t))(eo||{});const no=Object.keys(eo),io=no.length,so={w:0,t0:1,t1:2,t2:3,t3:4,i0:5,i1:6,i2:7,i3:8,i4:9,m0:10,m1:11,m2:12,m3:13,m4:14,r0:15,r1:16,r2:17,r3:18,r4:19,p0:20,p1:21,p2:22,p3:23,p4:24},ao={w:.02,t0:.02,t1:.014,t2:.0115,t3:.0085,i0:.022,i1:.012,i2:.0085,i3:.0075,i4:.0065,m0:.021,m1:.012,m2:.008,m3:.0075,m4:.0065,r0:.019,r1:.011,r2:.0075,r3:.007,r4:.006,p0:.012,p1:.01,p2:.007,p3:.0065,p4:.0055},ro=[["w","t0","t1","t2","t3"],["w","i0","i1","i2","i3","i4"],["w","m0","m1","m2","m3","m4"],["w","r0","r1","r2","r3","r4"],["w","p0","p1","p2","p3","p4"]],oo=[[8,10,8,6],[8,19,14,8,6],[8,19,14,8,6],[8,19,14,8,6],[8,19,14,8,6]],go=["t3","i4","m4","r4","p4"],co=["i4","m4","r4","p4"];var lo=(t=>(t.left="left",t.right="right",t))(lo||{});const Io=Object.keys(lo);class ho{constructor(){this.hands={},this.last={},this.values={},this.tests={},this.lastTests={},this.updated=!1}update({xr:t,xrFrame:A}){const e=t.getSession();if(!e)return;const i=t.getReferenceSpace();if(i&&A.getJointPose){this.last=this.hands,this.lastTests=this.tests,this.hands={},this.values={},this.tests={};for(const t of e.inputSources){if(!t.hand)continue;const e=t.handedness;this.hands[e]={};for(const s of no){const a=t.hand.get(eo[s]);if(a){const t=A.getJointPose(a,i);if(t){const{position:A,orientation:i}=t.transform;this.hands[e][s]={position:new n.Pq0(A.x,A.y,A.z),quaternion:new n.PTz(i.x,i.y,i.z,i.w),radius:t.radius||.001}}}}}for(const t of Io)for(const{key:A,value:e}of[{key:`${t}AllTips`,value:this.allTipsTouching(t)},{key:`${t}IndexThumb`,value:this.touching(t,"i4",t,"t3")},{key:`${t}MiddleThumb`,value:this.touching(t,"m4",t,"t3")},{key:`${t}RingThumb`,value:this.touching(t,"r4",t,"t3")},{key:`${t}PinkyThumb`,value:this.touching(t,"p4",t,"t3")},{key:`${t}TriTips`,value:this.triTipsTouching(t)}])this.values[A]=e,this.tests[A]=1===e||0!==e&&(this.lastTests[A]??!1)}}makeGhostMesh(){const t=new n.Pq0,A=new n.Pq0(.01,.01,.01),e=new n.PTz(0,0,0,1),i=new n.Q1f(1,1,1),s=3*Math.PI;new n.Q1f(1,1,1);let a=1;const r=new Fa({onFrame:()=>{let n=0;for(const o of Io){const g=this.hands[o];for(const[c,l]of ro.entries())for(let I=1;I<l.length;++I){const h=2*oo[c][I-1],u=I+1===l.length,B=null==g?void 0:g[l[I-1]],d=null==g?void 0:g[l[I]];for(let g=0;g<h;++g){const c=(g+.5)/h;if(a=0,B&&d){t.copy(B.position).lerp(d.position,c),e.copy(B.quaternion).slerp(d.quaternion,c);let n=(1-c)*ao[l[I-1]]+c*ao[l[I]];u&&c>.8&&(n*=Math.sqrt(1-((c-.8)/.2)**2)),A.set(.65*n,.5*n,.003),i.set(.55+.45*Math.sin(t.x*s),.55+.45*Math.sin(t.y*s),.55+.45*Math.sin(t.z*s)),"right"===o&&i.set(1-i.r,1-i.g,1-i.b),a=.75}r.packedSplats.setSplat(n,t,A,e,a,i),n+=1}}}r.packedSplats.numSplats=n,r.packedSplats.needsUpdate=!0,r.numSplats=n,r.updateVersion()}});return r}distance(t,A,e,n,i=!1){const s=i?this.last[t]:this.hands[t],a=i?this.last[e]:this.hands[e],r=null==s?void 0:s[A],o=null==a?void 0:a[n];return r&&o?r.position.distanceTo(o.position):Number.POSITIVE_INFINITY}separation(t,A,e,n,i=!1){const s=this.distance(t,A,e,n,i);return s===Number.POSITIVE_INFINITY?Number.POSITIVE_INFINITY:s-ao[A]-ao[n]}touching(t,A,e,n,i=!1){const s=this.separation(t,A,e,n,i);return s===Number.POSITIVE_INFINITY?Number.POSITIVE_INFINITY:1-Math.max(0,Math.min(1,s/.01-0))}allTipsTouching(t,A=!1){return Math.min(this.touching(t,"t3",t,"i4",A),this.touching(t,"i4",t,"m4",A),this.touching(t,"m4",t,"r4",A),this.touching(t,"r4",t,"p4",A))}triTipsTouching(t,A=!1){return Math.min(this.touching(t,"t3",t,"i4",A),this.touching(t,"i4",t,"m4",A),this.touching(t,"m4",t,"t3",A))}}class uo{constructor({xrHands:t,control:A,moveInertia:e,rotateInertia:i}){this.lastGrip={},this.lastPivot=new n.Pq0,this.rotateVelocity=0,this.velocity=new n.Pq0,this.xrHands=t,this.control=A,this.moveInertia=e??.5,this.rotateInertia=i??.5}update(t){var A,e,i,s,a;const r={};for(const t of Io){const o=this.xrHands.hands[t];o&&this.xrHands.tests[`${t}MiddleThumb`]&&(r[t]=(new n.Pq0).add((null==(A=o.t3)?void 0:A.position)??new n.Pq0).add((null==(e=o.i4)?void 0:e.position)??new n.Pq0).add((null==(i=o.m4)?void 0:i.position)??new n.Pq0).add((null==(s=o.r4)?void 0:s.position)??new n.Pq0).add((null==(a=o.p4)?void 0:a.position)??new n.Pq0).multiplyScalar(.2))}if(r.left&&r.right&&this.lastGrip.left&&this.lastGrip.right){const A=r.left.clone().add(r.right).multiplyScalar(.5),e=this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(.5);this.lastPivot=A;const n=A.clone().applyMatrix4(this.control.matrix);n.sub(e.clone().applyMatrix4(this.control.matrix)),n.multiplyScalar(1/t),this.velocity.lerp(n,1-Math.exp(-20*t));let i=Math.atan2(r.left.z-A.z,r.left.x-A.x)-Math.atan2(this.lastGrip.left.z-e.z,this.lastGrip.left.x-e.x);i>Math.PI?i-=2*Math.PI:i<-Math.PI&&(i+=2*Math.PI);const s=i/t,a=Math.exp(-20*t);this.rotateVelocity=this.rotateVelocity*a+s*(1-a)}else if(this.rotateVelocity*=Math.exp(-t/this.rotateInertia),r.left&&this.lastGrip.left){const A=r.left.clone().applyMatrix4(this.control.matrix);A.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)),A.multiplyScalar(1/t),this.velocity.lerp(A,1-Math.exp(-20*t))}else if(r.right&&this.lastGrip.right){const A=r.right.clone().applyMatrix4(this.control.matrix);A.sub(this.lastGrip.right.clone().applyMatrix4(this.control.matrix)),A.multiplyScalar(1/t),this.velocity.lerp(A,1-Math.exp(-20*t))}else this.velocity.multiplyScalar(Math.exp(-t/this.moveInertia));const o=this.lastPivot.clone().negate(),g=(new n.kn4).makeTranslation(o).premultiply((new n.kn4).makeRotationY(this.rotateVelocity*t)).premultiply((new n.kn4).makeTranslation(this.lastPivot));this.control.matrix.multiply(g),this.control.matrix.decompose(this.control.position,this.control.quaternion,this.control.scale),this.control.updateMatrixWorld(!0),this.control.position.sub(this.velocity.clone().multiplyScalar(t)),this.lastGrip=r}}const Bo={KeyW:new n.Pq0(0,0,-1),KeyS:new n.Pq0(0,0,1),KeyA:new n.Pq0(-1,0,0),KeyD:new n.Pq0(1,0,0),KeyR:new n.Pq0(0,1,0),KeyF:new n.Pq0(0,-1,0)},Co={ArrowUp:new n.Pq0(0,0,-1),ArrowDown:new n.Pq0(0,0,1),ArrowLeft:new n.Pq0(-1,0,0),ArrowRight:new n.Pq0(1,0,0),PageUp:new n.Pq0(0,1,0),PageDown:new n.Pq0(0,-1,0)},Eo={KeyQ:new n.Pq0(0,0,1),KeyE:new n.Pq0(0,0,-1)},Qo={Home:new n.Pq0(0,-1,0),End:new n.Pq0(0,1,0),Insert:new n.Pq0(-1,0,0),Delete:new n.Pq0(1,0,0)};class po{constructor({canvas:t}){this.lastTime=0,this.fpsMovement=new fo({}),this.pointerControls=new mo({canvas:t})}update(t){const A=performance.now(),e=(A-(this.lastTime||A))/1e3;this.lastTime=A,this.fpsMovement.update(e,t),this.pointerControls.update(e,t)}}class fo{constructor({moveSpeed:t,rollSpeed:A,stickThreshold:e,rotateSpeed:n,keycodeMoveMapping:i,keycodeRotateMapping:s,gamepadMapping:a,capsMultiplier:r,shiftMultiplier:o,ctrlMultiplier:g,xr:c}={}){this.enable=!0,this.moveSpeed=t??1,this.rollSpeed=A??2,this.stickThreshold=e??.1,this.rotateSpeed=n??2,this.keycodeMoveMapping=i??{...Bo,...Co},this.keycodeRotateMapping=s??{...Eo,...Qo},this.gamepadMapping=a??{4:"rollLeft",5:"rollRight",6:"ctrl",7:"shift"},this.capsMultiplier=r??10,this.shiftMultiplier=o??5,this.ctrlMultiplier=g??.2,this.xr=c,this.keydown={},this.keycode={},document.addEventListener("keydown",t=>{this.keydown[t.key]=!0,this.keycode[t.code]=!0}),document.addEventListener("keyup",t=>{this.keydown[t.key]=!1,this.keycode[t.code]=!1}),window.addEventListener("blur",()=>{this.keydown={},this.keycode={}})}update(t,A){var e,i;if(!this.enable)return;const s=[new n.I9Y,new n.I9Y],a=navigator.getGamepads()[0];a&&(s[0].set(a.axes[0],a.axes[1]),s[1].set(a.axes[2],a.axes[3]));const r=(null==a?void 0:a.buttons.map(t=>t.pressed))||[],o=Array.from((null==(i=null==(e=this.xr)?void 0:e.getSession())?void 0:i.inputSources)??[]);for(const t of o){const A=t.gamepad;if(A)switch(t.handedness){case"none":s[0].x+=A.axes[0],s[0].y+=A.axes[1],s[1].x+=A.axes[2],s[1].y+=A.axes[3];break;case"left":s[0].x+=A.axes[2],s[0].y+=A.axes[3];break;case"right":s[1].x+=A.axes[2],s[1].y+=A.axes[3]}}for(const t of s)t.x=Math.abs(t.x)>=this.stickThreshold?t.x:0,t.y=Math.abs(t.y)>=this.stickThreshold?t.y:0;const g=new n.Pq0(s[1].x,s[1].y,0).multiplyScalar(this.rotateSpeed);for(const[t,A]of Object.entries(this.keycodeRotateMapping))this.keycode[t]&&g.add(A);for(const t in this.gamepadMapping)if(r[Number.parseInt(t)])switch(this.gamepadMapping[t]){case"rollLeft":g.z+=1;break;case"rollRight":g.z-=1}if(g.multiply(new n.Pq0(this.rotateSpeed,this.rotateSpeed,this.rollSpeed)),g.manhattanLength()>0){g.multiplyScalar(t);const e=(new n.O9p).setFromQuaternion(A.quaternion,"YXZ");e.y-=g.x,e.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,e.x-g.y)),e.z=Math.max(-Math.PI,Math.min(Math.PI,e.z+g.z)),A.quaternion.setFromEuler(e)}const c=new n.Pq0(s[0].x,0,s[0].y);for(const[t,A]of Object.entries(this.keycodeMoveMapping))this.keycode[t]&&c.add(A);let l=1;this.keydown.CapsLock&&(l*=this.capsMultiplier),(this.keycode.ShiftLeft||this.keycode.ShiftRight)&&(l*=this.shiftMultiplier),(this.keycode.ControlLeft||this.keycode.ControlRight)&&(l*=this.ctrlMultiplier);for(const t in this.gamepadMapping)if(r[Number.parseInt(t)])switch(this.gamepadMapping[t]){case"shift":l*=this.shiftMultiplier;break;case"ctrl":l*=this.ctrlMultiplier}c.applyQuaternion(A.quaternion),A.position.add(c.multiplyScalar(this.moveSpeed*l*t))}}class mo{constructor({canvas:t,rotateSpeed:A,slideSpeed:e,scrollSpeed:i,swapRotateSlide:s,reverseRotate:a,reverseSlide:r,reverseSwipe:o,reverseScroll:g,moveInertia:c,rotateInertia:l,pointerRollScale:I,doublePress:h}){this.enable=!0,this.canvas=t,this.rotateSpeed=A??.002,this.slideSpeed=e??.006,this.scrollSpeed=i??.0015,this.swapRotateSlide=s??!1,this.reverseRotate=a??!1,this.reverseSlide=r??!1,this.reverseSwipe=o??!1,this.reverseScroll=g??!1,this.moveInertia=c??.15,this.rotateInertia=l??.15,this.pointerRollScale=I??1,this.doublePress=h??(()=>{}),this.doublePressLimitMs=400,this.doublePressDistance=50,this.lastUp=null,this.rotating=null,this.sliding=null,this.dualPress=!1,this.scroll=new n.Pq0,this.rotateVelocity=new n.Pq0,this.moveVelocity=new n.Pq0,t.addEventListener("pointerdown",A=>{const e=this.getPointerPosition(A),n=e.clone(),i=e.clone(),s=!this.swapRotateSlide&&!this.rotating&&("mouse"!==A.pointerType||0===A.button)||this.swapRotateSlide&&this.sliding&&!this.rotating&&("mouse"!==A.pointerType||1===A.button),{pointerId:a,timeStamp:r}=A;if(s)this.rotating={initial:n,last:i,position:e,pointerId:a,timeStamp:r},t.setPointerCapture(A.pointerId),this.dualPress=!1;else if(!this.sliding){const s="mouse"===A.pointerType?A.button:void 0;this.sliding={initial:n,last:i,position:e,pointerId:a,button:s,timeStamp:r},t.setPointerCapture(A.pointerId),this.dualPress=null!=this.rotating&&r-this.rotating.timeStamp<200}});const u=A=>{var e,n;(null==(e=this.rotating)?void 0:e.pointerId)===A.pointerId?(this.rotating=null,t.releasePointerCapture(A.pointerId),this.dualPress&&this.sliding&&(t.releasePointerCapture(this.sliding.pointerId),this.sliding=null)):(null==(n=this.sliding)?void 0:n.pointerId)===A.pointerId&&(this.sliding=null,t.releasePointerCapture(A.pointerId),this.dualPress&&this.rotating&&(t.releasePointerCapture(this.rotating.pointerId),this.rotating=null));const i=this.getPointerPosition(A),s=this.lastUp;if(this.lastUp={position:i,time:A.timeStamp},s&&s.position.distanceTo(i)<this.doublePressDistance){const t=A.timeStamp-s.time;t<this.doublePressLimitMs&&(this.lastUp=null,this.doublePress({position:i,intervalMs:t}))}};document.addEventListener("pointerup",u),document.addEventListener("pointercancel",u),document.addEventListener("pointermove",t=>{var A,e;(null==(A=this.rotating)?void 0:A.pointerId)===t.pointerId?this.rotating.position=this.getPointerPosition(t):(null==(e=this.sliding)?void 0:e.pointerId)===t.pointerId&&(this.sliding.position=this.getPointerPosition(t))}),t.addEventListener("contextmenu",t=>{t.preventDefault()}),t.addEventListener("wheel",t=>{this.scroll.add(new n.Pq0(t.deltaX,t.deltaY,t.deltaZ)),t.preventDefault()})}getPointerPosition(t){const A=this.canvas.getBoundingClientRect();return new n.I9Y(t.clientX-A.left,t.clientY-A.top)}update(t,A){if(!this.enable)return;if(this.dualPress&&this.rotating&&this.sliding){const e=[this.rotating.position.clone().sub(this.rotating.last),this.sliding.position.clone().sub(this.sliding.last)],i=e[0].dot(e[1]);if(i>=.2){const i=e[0].clone().add(e[1]),s=new n.Pq0(i.x,-i.y,0);s.multiplyScalar(this.slideSpeed*(this.reverseSwipe?1:-1)),s.applyQuaternion(A.quaternion),A.position.add(s),this.moveVelocity=s.clone().multiplyScalar(1/t)}else if(i<=-.2){const i=this.sliding.last.clone().sub(this.rotating.last),s=i.length();i.multiplyScalar(1/s).normalize();const a=new n.I9Y(-i.y,i.x),r=[e[0].dot(i),e[1].dot(i)],o=[e[0].dot(a),e[1].dot(a)],g=this.rotating.last.clone().add(this.sliding.last).multiplyScalar(.5);let c=new n.Pq0;if(A instanceof n.i7d){const t=new n.I9Y(g.x/this.canvas.clientWidth*2-1,-g.y/this.canvas.clientHeight*2+1),e=new n.tBo;e.setFromCamera(t,A),c=e.ray.direction}const l=r[1]-r[0],I=c.multiplyScalar(l*this.slideSpeed);A.position.add(I),this.moveVelocity=I.clone().multiplyScalar(1/t);const h=[Math.atan(o[0]/(-.5*s)),Math.atan(o[1]/(.5*s))],u=.5*(h[0]+h[1])*this.pointerRollScale,B=(new n.O9p).setFromQuaternion(A.quaternion,"YXZ");B.z=Math.max(-Math.PI,Math.min(Math.PI,B.z+.5*u)),A.quaternion.setFromEuler(B)}this.rotating.last.copy(this.rotating.position),this.sliding.last.copy(this.sliding.position)}else{const e=new n.Pq0;if(this.rotating&&!this.dualPress){const A=this.rotating.position.clone().sub(this.rotating.last);this.rotating.last.copy(this.rotating.position),e.set(A.x,A.y,0),e.multiplyScalar(this.rotateSpeed*(this.reverseRotate?-1:1)),this.rotateVelocity=e.clone().multiplyScalar(1/t)}else this.rotateVelocity.multiplyScalar(Math.exp(-t/this.rotateInertia)),e.addScaledVector(this.rotateVelocity,t);const i=(new n.O9p).setFromQuaternion(A.quaternion,"YXZ");if(i.y-=e.x,i.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,i.x-e.y)),i.z*=Math.exp(-0*t),A.quaternion.setFromEuler(i),this.sliding&&!this.dualPress){const e=this.sliding.position.clone().sub(this.sliding.last);this.sliding.last.copy(this.sliding.position);const i=2!==this.sliding.button?new n.Pq0(e.x,0,e.y):new n.Pq0(e.x,-e.y,0);i.multiplyScalar(this.slideSpeed*(this.reverseSlide?-1:1)),i.applyQuaternion(A.quaternion),A.position.add(i),this.moveVelocity=i.clone().multiplyScalar(1/t)}else this.moveVelocity.multiplyScalar(Math.exp(-t/this.moveInertia)),A.position.addScaledVector(this.moveVelocity,t)}const e=this.scroll.multiplyScalar(this.scrollSpeed);e.set(e.x,e.z,e.y),this.reverseScroll&&e.multiplyScalar(-1),e.applyQuaternion(A.quaternion),A.position.add(e),this.scroll.set(0,0,0)}}},339:function(t,A,e){function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}function i(){var t,A,e="function"==typeof Symbol?Symbol:{},n=e.iterator||"@@iterator",a=e.toStringTag||"@@toStringTag";function r(e,n,i,a){var r=n&&n.prototype instanceof g?n:g,c=Object.create(r.prototype);return s(c,"_invoke",function(e,n,i){var s,a,r,g=0,c=i||[],l=!1,I={p:0,n:0,v:t,a:h,f:h.bind(t,4),d:function(A,e){return s=A,a=0,r=t,I.n=e,o}};function h(e,n){for(a=e,r=n,A=0;!l&&g&&!i&&A<c.length;A++){var i,s=c[A],h=I.p,u=s[2];e>3?(i=u===n)&&(r=s[(a=s[4])?5:(a=3,3)],s[4]=s[5]=t):s[0]<=h&&((i=e<2&&h<s[1])?(a=0,I.v=n,I.n=s[1]):h<u&&(i=e<3||s[0]>n||n>u)&&(s[4]=e,s[5]=n,I.n=u,a=0))}if(i||e>1)return o;throw l=!0,n}return function(i,c,u){if(g>1)throw TypeError("Generator is already running");for(l&&1===c&&h(c,u),a=c,r=u;(A=a<2?t:r)||!l;){s||(a?a<3?(a>1&&(I.n=-1),h(a,r)):I.n=r:I.v=r);try{if(g=2,s){if(a||(i="next"),A=s[i]){if(!(A=A.call(s,r)))throw TypeError("iterator result is not an object");if(!A.done)return A;r=A.value,a<2&&(a=0)}else 1===a&&(A=s.return)&&A.call(s),a<2&&(r=TypeError("The iterator does not provide a '"+i+"' method"),a=1);s=t}else if((A=(l=I.n<0)?r:e.call(n,I))!==o)break}catch(A){s=t,a=1,r=A}finally{g=1}}return{value:A,done:l}}}(e,i,a),!0),c}var o={};function g(){}function c(){}function l(){}A=Object.getPrototypeOf;var I=[][n]?A(A([][n]())):(s(A={},n,function(){return this}),A),h=l.prototype=g.prototype=Object.create(I);function u(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,l):(t.__proto__=l,s(t,a,"GeneratorFunction")),t.prototype=Object.create(h),t}return c.prototype=l,s(h,"constructor",l),s(l,"constructor",c),c.displayName="GeneratorFunction",s(l,a,"GeneratorFunction"),s(h),s(h,a,"Generator"),s(h,n,function(){return this}),s(h,"toString",function(){return"[object Generator]"}),(i=function(){return{w:r,m:u}})()}function s(t,A,e,n){var i=Object.defineProperty;try{i({},"",{})}catch(t){i=0}s=function(t,A,e,n){function a(A,e){s(t,A,function(t){return this._invoke(A,e,t)})}A?i?i(t,A,{value:e,enumerable:!n,configurable:!n,writable:!n}):t[A]=e:(a("next",0),a("throw",1),a("return",2))},s(t,A,e,n)}function a(t,A){var e="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!e){if(Array.isArray(t)||(e=r(t))||A&&t&&"number"==typeof t.length){e&&(t=e);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,a=!0,o=!1;return{s:function(){e=e.call(t)},n:function(){var t=e.next();return a=t.done,t},e:function(t){o=!0,s=t},f:function(){try{a||null==e.return||e.return()}finally{if(o)throw s}}}}function r(t,A){if(t){if("string"==typeof t)return o(t,A);var e={}.toString.call(t).slice(8,-1);return"Object"===e&&t.constructor&&(e=t.constructor.name),"Map"===e||"Set"===e?Array.from(t):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?o(t,A):void 0}}function o(t,A){(null==A||A>t.length)&&(A=t.length);for(var e=0,n=Array(A);e<A;e++)n[e]=t[e];return n}function g(t,A){for(var e=0;e<A.length;e++){var n=A[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,c(n.key),n)}}function c(t){var A=function(t){if("object"!=n(t)||!t)return t;var A=t[Symbol.toPrimitive];if(void 0!==A){var e=A.call(t,"string");if("object"!=n(e))return e;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==n(A)?A:A+""}var l,I=this&&this.__createBinding||(Object.create?function(t,A,e,n){void 0===n&&(n=e);var i=Object.getOwnPropertyDescriptor(A,e);i&&!("get"in i?!A.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return A[e]}}),Object.defineProperty(t,n,i)}:function(t,A,e,n){void 0===n&&(n=e),t[n]=A[e]}),h=this&&this.__setModuleDefault||(Object.create?function(t,A){Object.defineProperty(t,"default",{enumerable:!0,value:A})}:function(t,A){t.default=A}),u=this&&this.__importStar||(l=function(t){return l=Object.getOwnPropertyNames||function(t){var A=[];for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(A[A.length]=e);return A},l(t)},function(t){if(t&&t.__esModule)return t;var A={};if(null!=t)for(var e=l(t),n=0;n<e.length;n++)"default"!==e[n]&&I(A,t,e[n]);return h(A,t),A}),B=this&&this.__awaiter||function(t,A,e,n){return new(e||(e=Promise))(function(i,s){function a(t){try{o(n.next(t))}catch(t){s(t)}}function r(t){try{o(n.throw(t))}catch(t){s(t)}}function o(t){var A;t.done?i(t.value):(A=t.value,A instanceof e?A:new e(function(t){t(A)})).then(a,r)}o((n=n.apply(t,A||[])).next())})};Object.defineProperty(A,"__esModule",{value:!0}),A.SplatsState=A.managedSplats=void 0;var d=u(e(451)),C=e(337),E=e(294),Q=e(430);A.managedSplats={};var p={v:new d.Vector3,m:new d.Matrix4,from:new d.Vector3,to:new d.Vector3},f=function(){return t=function t(A){!function(t,A){if(!(t instanceof A))throw new TypeError("Cannot call a class as a function")}(this,t),this.service=A,this.onProgress=new Set,this.onTransitionEvent=new Set,this.transitionDuration=1e3,this.dissolveEffect=!1,this._maxStdDevBaseline=0,this._transitionToSplatId="",this._transitionStartTimestamp=0,this._transitionFromSplatId="",this._transitionCenterXZ=new d.Vector3},e=[{key:"configureRenderer",value:function(t){this._renderer=new C.SparkRenderer(t),this._maxStdDevBaseline=this._renderer.maxStdDev}},{key:"renderer",get:function(){if(void 0===this._renderer)throw new Error("renderer not configured");return this._renderer}},{key:"transitionToSplatId",get:function(){return this._transitionToSplatId},set:function(t){if(!this._transitionFromSplatId&&!this._transitionToSplatId){if(console.log("transitionToSplatId",t),this._transitionFromSplatId=E.struct.APP.activeSplatId,this._transitionToSplatId=t,this._transitionStartTimestamp=performance.now(),this._transitionToConfig=E.slideshowConfig.SPLATS[this._transitionToSplatId]){var A=this.service.orbit;this._transitionFromConfig={environment:"",environmentRotation:0,environmentHeight:0,minCameraDistance:A.minDistance,maxCameraDistance:A.maxDistance,initialCameraPosition:{x:A.object.position.x,y:A.object.position.y,z:A.object.position.z},initialCameraTarget:{x:A.target.x,y:A.target.y,z:A.target.z}}}var e=this.getOrCreate(this._transitionToSplatId).loading.value;void 0!==e?this._transitionCenterXZ.set(e.position.x,0,e.position.z):this._transitionCenterXZ.setScalar(0);var n,i=a(this.onTransitionEvent);try{for(i.s();!(n=i.n()).done;)(0,n.value)("start",this._transitionFromSplatId,this._transitionToSplatId)}catch(t){i.e(t)}finally{i.f()}}}},{key:"getOrCreate",value:function(t){var e=A.managedSplats[t];if(void 0===e){var n=E.struct.SPLATS[t];if(void 0===n)throw new Error("splat '".concat(t,"' not found"));var i=E.struct.SPLAT_SOURCES[n.source];if(void 0===i)throw new Error("splat source '".concat(n.source,"' not found"));e=A.managedSplats[t]={store:n,source:i,loading:(0,Q.future)()}}return e}},{key:"loadMesh",value:function(t){return B(this,void 0,void 0,i().m(function A(){var e,n;return i().w(function(A){for(;;)switch(A.n){case 0:if("idle"!==(e=this.getOrCreate(t)).loading.state){A.n=1;break}return e.loading.state="pending",(n=new C.SplatMesh({url:e.source.url})).matrixWorld.fromArray(e.store.matrix).decompose(n.position,n.quaternion,n.scale),e.loading.value=n,A.n=1,n.initialized.then(function(){return e.loading.state="resolved"}).catch(function(t){return e.loading.state="failed",e.loading.error=t});case 1:return A.a(2)}},A,this)}))}},{key:"loadMeshWithProgress",value:function(t){return B(this,void 0,void 0,i().m(function A(){var e,n,s,r,o,g,c,l=this;return i().w(function(A){for(;;)switch(A.p=A.n){case 0:if("idle"!==(e=this.getOrCreate(t)).loading.state){A.n=4;break}return e.loading.state="pending",n=new C.SplatLoader,A.p=1,A.n=2,n.loadAsync(e.source.url,function(A){if("progress"===A.type){var e,n=A.lengthComputable?A.loaded/A.total:.5,i=a(l.onProgress);try{for(i.s();!(e=i.n()).done;)(0,e.value)(t,n)}catch(t){i.e(t)}finally{i.f()}}});case 2:s=A.v,r=a(this.onProgress);try{for(r.s();!(o=r.n()).done;)(0,o.value)(t,1)}catch(t){r.e(t)}finally{r.f()}(g=new C.SplatMesh({packedSplats:s})).matrixWorld.fromArray(e.store.matrix).decompose(g.position,g.quaternion,g.scale),e.loading.value=g,e.loading.state="resolved",A.n=4;break;case 3:A.p=3,c=A.v,e.loading.state="failed",e.loading.error=c;case 4:return A.a(2)}},A,this,[[1,3]])}))}},{key:"getSortedSplats",value:function(){return Object.entries(E.struct.SPLATS).map(function(t){var A=function(t,A){return function(t){if(Array.isArray(t))return t}(t)||function(t,A){var e=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=e){var n,i,s,a,r=[],o=!0,g=!1;try{if(s=(e=e.call(t)).next,0===A){if(Object(e)!==e)return;o=!1}else for(;!(o=(n=s.call(e)).done)&&(r.push(n.value),r.length!==A);o=!0);}catch(t){g=!0,i=t}finally{try{if(!o&&null!=e.return&&(a=e.return(),Object(a)!==a))return}finally{if(g)throw i}}return r}}(t,A)||r(t,A)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}(t,2),e=A[0],n=A[1];return{id:e,distanceSquared:p.v.setFromMatrixPosition(p.m.fromArray(n.matrix)).lengthSq()}}).sort(function(t,A){return t.distanceSquared-A.distanceSquared}).map(function(t){return t.id})}},{key:"updateTransitions",value:function(){if(this._transitionFromSplatId||this._transitionToSplatId){var t=performance.now()-this._transitionStartTimestamp,A=Math.min(1,t/this.transitionDuration);if(this.dissolveEffect&&(this.renderer.maxStdDev=this._maxStdDevBaseline*Math.abs(.5-A)),1===A){var e=this._transitionFromSplatId;this.renderer.maxStdDev=this._maxStdDevBaseline,this._transitionFromSplatId="";var n,i=a(this.onTransitionEvent);try{for(i.s();!(n=i.n()).done;)(0,n.value)("end",e,E.struct.APP.activeSplatId)}catch(t){i.e(t)}finally{i.f()}}else if(A>=.5&&this._transitionToSplatId){E.struct.APP.activeSplatId=this._transitionToSplatId,this._transitionToSplatId="";var s,r=a(this.onTransitionEvent);try{for(r.s();!(s=r.n()).done;)(0,s.value)("switch",this._transitionFromSplatId,E.struct.APP.activeSplatId)}catch(t){r.e(t)}finally{r.f()}}if(this._transitionToConfig&&this._transitionFromConfig){var o=this._transitionFromConfig,g=this._transitionToConfig,c=this.service.orbit;c.minDistance=d.MathUtils.lerp(o.minCameraDistance,g.minCameraDistance,A),c.maxDistance=d.MathUtils.lerp(o.maxCameraDistance,g.maxCameraDistance,A);var l=p.from.copy(o.initialCameraPosition),I=p.to.copy(g.initialCameraPosition).add(this._transitionCenterXZ);c.object.position.lerpVectors(l,I,A),l.copy(o.initialCameraTarget),I.copy(g.initialCameraTarget).add(this._transitionCenterXZ),c.target.lerpVectors(l,I,A)}}}}],e&&g(t.prototype,e),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,e}();A.SplatsState=f},371:function(t,A,e){function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}function i(t,A){(null==A||A>t.length)&&(A=t.length);for(var e=0,n=Array(A);e<A;e++)n[e]=t[e];return n}function s(t,A){if(!(t instanceof A))throw new TypeError("Cannot call a class as a function")}function a(t,A){for(var e=0;e<A.length;e++){var n=A[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,o(n.key),n)}}function r(t,A,e){return A&&a(t.prototype,A),e&&a(t,e),Object.defineProperty(t,"prototype",{writable:!1}),t}function o(t){var A=function(t){if("object"!=n(t)||!t)return t;var A=t[Symbol.toPrimitive];if(void 0!==A){var e=A.call(t,"string");if("object"!=n(e))return e;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==n(A)?A:A+""}function g(){var t,A,e="function"==typeof Symbol?Symbol:{},n=e.iterator||"@@iterator",i=e.toStringTag||"@@toStringTag";function s(e,n,i,s){var o=n&&n.prototype instanceof r?n:r,g=Object.create(o.prototype);return c(g,"_invoke",function(e,n,i){var s,r,o,g=0,c=i||[],l=!1,I={p:0,n:0,v:t,a:h,f:h.bind(t,4),d:function(A,e){return s=A,r=0,o=t,I.n=e,a}};function h(e,n){for(r=e,o=n,A=0;!l&&g&&!i&&A<c.length;A++){var i,s=c[A],h=I.p,u=s[2];e>3?(i=u===n)&&(o=s[(r=s[4])?5:(r=3,3)],s[4]=s[5]=t):s[0]<=h&&((i=e<2&&h<s[1])?(r=0,I.v=n,I.n=s[1]):h<u&&(i=e<3||s[0]>n||n>u)&&(s[4]=e,s[5]=n,I.n=u,r=0))}if(i||e>1)return a;throw l=!0,n}return function(i,c,u){if(g>1)throw TypeError("Generator is already running");for(l&&1===c&&h(c,u),r=c,o=u;(A=r<2?t:o)||!l;){s||(r?r<3?(r>1&&(I.n=-1),h(r,o)):I.n=o:I.v=o);try{if(g=2,s){if(r||(i="next"),A=s[i]){if(!(A=A.call(s,o)))throw TypeError("iterator result is not an object");if(!A.done)return A;o=A.value,r<2&&(r=0)}else 1===r&&(A=s.return)&&A.call(s),r<2&&(o=TypeError("The iterator does not provide a '"+i+"' method"),r=1);s=t}else if((A=(l=I.n<0)?o:e.call(n,I))!==a)break}catch(A){s=t,r=1,o=A}finally{g=1}}return{value:A,done:l}}}(e,i,s),!0),g}var a={};function r(){}function o(){}function l(){}A=Object.getPrototypeOf;var I=[][n]?A(A([][n]())):(c(A={},n,function(){return this}),A),h=l.prototype=r.prototype=Object.create(I);function u(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,l):(t.__proto__=l,c(t,i,"GeneratorFunction")),t.prototype=Object.create(h),t}return o.prototype=l,c(h,"constructor",l),c(l,"constructor",o),o.displayName="GeneratorFunction",c(l,i,"GeneratorFunction"),c(h),c(h,i,"Generator"),c(h,n,function(){return this}),c(h,"toString",function(){return"[object Generator]"}),(g=function(){return{w:s,m:u}})()}function c(t,A,e,n){var i=Object.defineProperty;try{i({},"",{})}catch(t){i=0}c=function(t,A,e,n){function s(A,e){c(t,A,function(t){return this._invoke(A,e,t)})}A?i?i(t,A,{value:e,enumerable:!n,configurable:!n,writable:!n}):t[A]=e:(s("next",0),s("throw",1),s("return",2))},c(t,A,e,n)}var l=this&&this.__awaiter||function(t,A,e,n){return new(e||(e=Promise))(function(i,s){function a(t){try{o(n.next(t))}catch(t){s(t)}}function r(t){try{o(n.throw(t))}catch(t){s(t)}}function o(t){var A;t.done?i(t.value):(A=t.value,A instanceof e?A:new e(function(t){t(A)})).then(a,r)}o((n=n.apply(t,A||[])).next())})};Object.defineProperty(A,"__esModule",{value:!0}),A.create=function(){return l(this,void 0,void 0,g().m(function t(){var A,e,n,i,s,a,r,o,c,l,C,E,y,w,x,S,D,v,M,b,_;return g().w(function(t){for(;;)switch(t.n){case 0:if(_=function(){if(b=new m,s.renderSize.set(.9*window.innerWidth,.9*window.innerHeight),s.update(),s.domElement.style.position="absolute",s.domElement.style.left="50%",s.domElement.style.top="50%",s.domElement.style.transform="translate(-50%, -50%)",document.body.appendChild(s.domElement),n){var t=s.domElement.getBoundingClientRect();(x=(0,p.navigationButtonsOverlay)(t)).setCallbacks(function(){return S(-1)},function(){return S(1)}),x.show(!0)}requestAnimationFrame(M)},M=function(t){v(),requestAnimationFrame(M)},v=function(){if(b&&b.isFrameKeyDown){var t="ArrowRight"===b.key,A="ArrowLeft"===b.key;(t||A)&&n&&S(t?1:-1)}var e=(0,d.changed)(function(){return D?"":c.activeSplatId},null,"on active splat change");if(!c.activeSplatId||!l[c.activeSplatId]){var o=Object.values(l);o.length>0&&(c.activeSplatId=o[0].id)}var g=function(){var t=l[I],A=C[t.source],i=a.getOrCreate(I);"idle"===i.loading.state&&(n&&c.activeSplatId!==I||a.loadMeshWithProgress(I));var o=i.loading.value;n&&(0,d.changed)(function(){return i.loading.state},function(t,A){return"resolved"===A},"on splat '".concat(I,"' load"))&&void 0!==o&&(o.position.x=o.position.z=0),void 0!==o&&(n||null!==o.parent||(s.setSceneObject(I,o),s.fitToScene(1.5)),!e&&null!=r.activeSplat.intake||c.activeSplatId!==I||(r.activeSplat.intake={name:A.name,url:A.url,splatMesh:o}),c.activeSplatId===I?s.setSceneObject(I,o):n&&null!==o.parent&&s.setSceneObject(I,null)),1===t.deletionStage&&(t.deletionStage=2,A.deletionStage=2,void 0!==o&&s.setSceneObject(I,null),delete l[I],delete C[I],c.activeSplatId===I&&(c.activeSplatId=""))};for(var I in l)g();if(r.slideshowSplat.isEditing?c.activeSplatId&&r.slideshowSplat.intakeId!==c.activeSplatId&&(r.slideshowSplat.intakeId=c.activeSplatId,r.slideshowSplat.intake=r.slideshowSplat.getOrCreateIntake(r.slideshowSplat.intakeId)):r.slideshowSplat.intake=void 0,a.updateTransitions(),s.update(),c.activeSplatId&&(0,d.changed)(function(){return r.activeSplat.version},null,"on active splat version change")){var h=a.getOrCreate(c.activeSplatId).loading.value;void 0!==h&&(l[c.activeSplatId].matrix=h.matrixWorld.toArray())}(0,d.changed)(function(){return s.cameraVersion},null,"on camera version change")&&(E.initialCameraPosition=s.cameraPosition.toArray(),E.initialCameraTarget=s.cameraTarget.toArray()),(0,Q.elapsed)(10)&&(0,d.changed)(function(){return r.io.serialize()},null,"on struct change")&&(console.log("struct changed"),i&&r.io.saveToLocalStorage(),p.splatSourcesList.update&&p.splatSourcesList.update()),void 0!==b&&b.consumeFrame(void 0),D=!1},S=function(t){if(n&&0!==y.length){var A=y,e=A.findIndex(function(t){return t===c.activeSplatId});e=(e+t+A.length)%A.length,a.transitionToSplatId=A[e]}},A=new URLSearchParams(window.location.search),e=A.get("config"),n=A.has("slideshow"),i=A.has("editor")||!e,s=new I.Viewer({isEditor:i}),a=new B.SplatsState({orbit:s.orbitControls}),r=new h.Controls(s),new f(a,r,{isEditor:i,isSlideshow:n}),!e){t.n=1;break}return t.n=1,fetch(e).then(function(t){return t.json()}).then(function(t){return r.io.merge(t)});case 1:i&&!e&&r.io.loadFromLocalStorage(),console.log("init with",{isEditor:i,configUrl:e,isSlideshow:n}),console.log("struct =",window.struct=u.struct),n&&console.log("slideshowConfig =",window.slideshowConfig=u.slideshowConfig),o=u.struct,c=o.APP,l=o.SPLATS,C=o.SPLAT_SOURCES,E=o.SCENE,s.cameraPosition.fromArray(E.initialCameraPosition),s.cameraTarget.fromArray(E.initialCameraTarget),p.splatSourcesList.update&&p.splatSourcesList.update(),y=[],n&&(y=a.getSortedSplats(),c.activeSplatId=y[0],a.dissolveEffect=!0),a.configureRenderer({renderer:s.rendererRef}),s.setSceneObject("splat-renderer",a.renderer),console.log("renderer =",window.renderer=a.renderer),w=(0,p.progressIndicatorOverlay)(),a.onProgress.add(function(t,A){c.activeSplatId===t&&(1===A?w.active(!1):w.update(100*A))}),x=null,a.onTransitionEvent.add(function(t,A,e){if(console.log("transition",t,A,e),"switch"===t){var n=u.slideshowConfig.SPLATS[e];if(!n)return;s.transitionToEnvironment(n.environment,n.environmentRotation)}}),c.activeSplatId&&(a.transitionToSplatId=c.activeSplatId),r.slideshowSplat.isEditing=n&&i,D=!0,"complete"===document.readyState?_():window.addEventListener("load",_,{once:!0});case 2:return t.a(2)}},t)}))};var I=e(641),h=e(493),u=e(294),B=e(339),d=e(413),C=e(509),E=e(279),Q=e(961),p=e(195),f=function(){return r(function t(A,e,n){var i=this;s(this,t),this.state=A,this.ctrl=e,this.config=n,(0,C.load)();var a=function(){return(0,C.load)().then(i.init.bind(i))};"complete"===document.readyState?a():window.addEventListener("load",a,{once:!0})},[{key:"init",value:function(){var t,A=this;if(this.config.isEditor){var e=this._gui=(0,C.init)({title:"Splat Gallery"}),n=this.ctrl,i=n.activeSplat,s=n.io;e.add(s,"saveToLocalStorage").name("Save"),e.add(s,"loadFromLocalStorage").name("Load"),e.add(s,"generateDownload").name("Download");var a=e.addFolder("Sources"),r=document.createElement("div");r.style.cssText="position: relative; width: 100%;",null===(t=p.splatSourcesList.setup)||void 0===t||t.call(p.splatSourcesList,r,{on:function(t,e){switch(console.log("on '".concat(t,"'"),e),t){case"select":u.struct.APP.useTransitions?A.state.transitionToSplatId=e:u.struct.APP.activeSplatId=e;break;case"delete":u.struct.SPLATS[e].deletionStage=1}}}),(0,C.addCustomController)(a,r,"id","Sources"),a.add(s,"splatName").name("Name"),a.add(s,"splatUrl").name("URL"),a.add(s,"addSplatSource").name("Add");var o=e.addFolder("Editor");o.addFolder("Settings").add(u.struct.APP,"useTransitions").name("Animate camera");var g=o.addFolder("Splat");g.add(i,"name").name("Name").listen().disable();var c=g.addFolder("Position");c.add(i.x,"value",void 0,void 0,.02).name("X").listen().$name.appendChild((0,E.inlineButton)("0",function(){return i.x.value=0})),c.add(i.y,"value",void 0,void 0,.02).name("Y").listen().$name.appendChild((0,E.inlineButton)("0",function(){return i.y.value=0})),c.add(i.z,"value",void 0,void 0,.02).name("Z").listen().$name.appendChild((0,E.inlineButton)("0",function(){return i.z.value=0}));var l=g.addFolder("Rotation");if(l.add(i.rx,"value",-180,180,1).name("X").listen().$name.appendChild((0,E.inlineButton)("0",function(){return i.rx.value=0})),l.add(i.ry,"value",-180,180,1).name("Y").listen().$name.appendChild((0,E.inlineButton)("0",function(){return i.ry.value=0})),l.add(i.rz,"value",-180,180,1).name("Z").listen().$name.appendChild((0,E.inlineButton)("0",function(){return i.rz.value=0})),this.config.isSlideshow){var I=this.ctrl.slideshowSplat,h=o.addFolder("Slideshow");h.addFolder("Item config").add(u.struct.APP,"activeSplatId").name("Active splat").listen().disable();var B=h.addFolder("Environment");B.add(I.environment,"value").name("Environment").listen(),B.add(I.environmentRotation,"value",0,3.1415,.02).name("Rotation").listen(),B.add(I.environmentHeight,"value",0,200,1).name("Height").listen();var d=h.addFolder("Camera setup");d.close(),d.add(I.minCameraDistance,"value",void 0,void 0,.1).name("Min distance").listen().$name.appendChild((0,E.inlineButton)("#",I.useMinCameraDistance)),d.add(I.maxCameraDistance,"value",void 0,void 0,.1).name("Max distance").listen().$name.appendChild((0,E.inlineButton)("#",I.useMaxCameraDistance));var Q=d.addFolder("Initial camera position");Q.add(I,"useCameraPosition").name("Use current"),Q.add(I.initialCameraPosition.x,"value",-10,10,.1).name("X").listen(),Q.add(I.initialCameraPosition.y,"value",-10,10,.1).name("Y").listen(),Q.add(I.initialCameraPosition.z,"value",-10,10,.1).name("Z").listen();var f=d.addFolder("Initial camera target");f.add(I,"useCameraTarget").name("Use current"),f.add(I.initialCameraTarget.x,"value",-10,10,.1).name("X").listen(),f.add(I.initialCameraTarget.y,"value",-10,10,.1).name("Y").listen(),f.add(I.initialCameraTarget.z,"value",-10,10,.1).name("Z").listen()}}}}])}(),m=function(){return r(function t(){var A=this;s(this,t),this._events=new Map,this.key="",this.isFrameKeyDown=!1,this.isKeyDown=!1,this.consumeFrame=this.exec.bind(this,"frameconsumed"),this.onFrameConsumed=this.register.bind(this,"frameconsumed"),this.onKeyDown=this.register.bind(this,"keydown"),this.onKeyUp=this.register.bind(this,"keyup"),this.onPointerMove=this.register.bind(this,"pointermove"),this.onPointerDown=this.register.bind(this,"pointerdown"),this.onPointerUp=this.register.bind(this,"pointerup"),window.addEventListener("keydown",this.exec.bind(this,"keydown")),window.addEventListener("keyup",this.exec.bind(this,"keyup")),document.body.addEventListener("pointermove",this.exec.bind(this,"pointermove")),document.body.addEventListener("pointerdown",this.exec.bind(this,"pointerdown")),document.body.addEventListener("pointerup",this.exec.bind(this,"pointerup")),this.onKeyDown(function(t){A.isKeyDown=!0,A.isFrameKeyDown=!0,A.key=t.key}),this.onKeyUp(function(t){A.isKeyDown=!1,A.key=t.key}),this.onFrameConsumed(function(){A.isFrameKeyDown=!1})},[{key:"exec",value:function(t,A){var e=this._events.get(t);if(void 0!==e){var n,s=function(t,A){var e="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!e){if(Array.isArray(t)||(e=function(t,A){if(t){if("string"==typeof t)return i(t,A);var e={}.toString.call(t).slice(8,-1);return"Object"===e&&t.constructor&&(e=t.constructor.name),"Map"===e||"Set"===e?Array.from(t):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?i(t,A):void 0}}(t))||A&&t&&"number"==typeof t.length){e&&(t=e);var n=0,s=function(){};return{s,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,r=!0,o=!1;return{s:function(){e=e.call(t)},n:function(){var t=e.next();return r=t.done,t},e:function(t){o=!0,a=t},f:function(){try{r||null==e.return||e.return()}finally{if(o)throw a}}}}(e);try{for(s.s();!(n=s.n()).done;)(0,n.value)(A)}catch(t){s.e(t)}finally{s.f()}}}},{key:"register",value:function(t,A){var e=this._events.get(t);void 0===e&&this._events.set(t,e=[]),e.push(A)}}])}()},413:(t,A)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.changed=function(t,A,n){if(void 0===n&&(n=new Error("changed").stack),void 0===n)throw new Error("auto uid featured not available (missing stack)");var i=e.get(n);if(void 0===i){var s=t();i=function(){var e=t();if(s!==e){var n=null===A||A(s,e);return s=e,n}return!1},e.set(n,i)}return i()};var e=new Map},430:(t,A)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.future=function(){return{state:"idle"}}},451:(t,A,e)=>{e.r(A),e.d(A,{ACESFilmicToneMapping:()=>n.FV,AddEquation:()=>n.gO9,AddOperation:()=>n.XrR,AdditiveAnimationBlendMode:()=>n.DAe,AdditiveBlending:()=>n.EZo,AgXToneMapping:()=>n.LAk,AlphaFormat:()=>n.wrO,AlwaysCompare:()=>n.FFZ,AlwaysDepth:()=>n.lGu,AlwaysStencilFunc:()=>n.sKt,AmbientLight:()=>n.$p8,AnimationAction:()=>n.pPE,AnimationClip:()=>n.tz3,AnimationLoader:()=>n.kEx,AnimationMixer:()=>n.Iw4,AnimationObjectGroup:()=>n.P5j,AnimationUtils:()=>n.AKb,ArcCurve:()=>n.ibB,ArrayCamera:()=>n.nZQ,ArrowHelper:()=>n.E0M,AttachedBindMode:()=>n.BER,Audio:()=>n.fP5,AudioAnalyser:()=>n.CwR,AudioContext:()=>n.UtX,AudioListener:()=>n.Pf$,AudioLoader:()=>n.Am1,AxesHelper:()=>n.IzY,BackSide:()=>n.hsX,BasicDepthPacking:()=>n.Rkk,BasicShadowMap:()=>n.bTm,BatchedMesh:()=>n.$Ed,Bone:()=>n.$Kf,BooleanKeyframeTrack:()=>n.YOZ,Box2:()=>n.UtB,Box3:()=>n.NRn,Box3Helper:()=>n.BND,BoxGeometry:()=>n.iNn,BoxHelper:()=>n.IWo,BufferAttribute:()=>n.THS,BufferGeometry:()=>n.LoY,BufferGeometryLoader:()=>n.SUR,ByteType:()=>n.tJf,Cache:()=>n.l2R,Camera:()=>n.i7d,CameraHelper:()=>n.WTh,CanvasTexture:()=>n.GOR,CapsuleGeometry:()=>n.qU7,CatmullRomCurve3:()=>n.B6O,CineonToneMapping:()=>n.nNL,CircleGeometry:()=>n.tcD,ClampToEdgeWrapping:()=>n.ghU,Clock:()=>n.zD7,Color:()=>n.Q1f,ColorKeyframeTrack:()=>n.T6I,ColorManagement:()=>n.ppV,CompressedArrayTexture:()=>n.iOZ,CompressedCubeTexture:()=>n.c5h,CompressedTexture:()=>n.FvD,CompressedTextureLoader:()=>n.YRT,ConeGeometry:()=>n.qFE,ConstantAlphaFactor:()=>n.e0p,ConstantColorFactor:()=>n.RrE,Controls:()=>n.H2z,CubeCamera:()=>n.F1T,CubeReflectionMapping:()=>n.hy7,CubeRefractionMapping:()=>n.xFO,CubeTexture:()=>n.b4q,CubeTextureLoader:()=>n.ScU,CubeUVReflectionMapping:()=>n.Om,CubicBezierCurve:()=>n.Z0B,CubicBezierCurve3:()=>n.s0K,CubicInterpolant:()=>n.Pdi,CullFaceBack:()=>n.Vb5,CullFaceFront:()=>n.Jnc,CullFaceFrontBack:()=>n.ywQ,CullFaceNone:()=>n.WNZ,Curve:()=>n.Ipv,CurvePath:()=>n.jGm,CustomBlending:()=>n.bCz,CustomToneMapping:()=>n.g7M,CylinderGeometry:()=>n.Ho_,Cylindrical:()=>n.hjs,Data3DTexture:()=>n.dYF,DataArrayTexture:()=>n.rFo,DataTexture:()=>n.GYF,DataTextureLoader:()=>n.BRH,DataUtils:()=>n.GxU,DecrementStencilOp:()=>n.ROr,DecrementWrapStencilOp:()=>n.fJr,DefaultLoadingManager:()=>n.h_9,DepthFormat:()=>n.zdS,DepthStencilFormat:()=>n.dcC,DepthTexture:()=>n.VCu,DetachedBindMode:()=>n.Fvi,DirectionalLight:()=>n.ZyN,DirectionalLightHelper:()=>n.PFK,DiscreteInterpolant:()=>n.Yhb,DodecahedronGeometry:()=>n.nEu,DoubleSide:()=>n.$EB,DstAlphaFactor:()=>n.hdd,DstColorFactor:()=>n.wn6,DynamicCopyUsage:()=>n.MOq,DynamicDrawUsage:()=>n.Vnu,DynamicReadUsage:()=>n.hIf,EdgesGeometry:()=>n.TDQ,EllipseCurve:()=>n.S20,EqualCompare:()=>n.kO0,EqualDepth:()=>n.U3G,EqualStencilFunc:()=>n.jsO,EquirectangularReflectionMapping:()=>n.wfO,EquirectangularRefractionMapping:()=>n.uV5,Euler:()=>n.O9p,EventDispatcher:()=>n.Qev,ExtrudeGeometry:()=>n.QCA,FileLoader:()=>n.Y9S,Float16BufferAttribute:()=>n.Oax,Float32BufferAttribute:()=>n.qtW,FloatType:()=>n.RQf,Fog:()=>n.jUj,FogExp2:()=>n.cRK,FramebufferTexture:()=>n.Pem,FrontSide:()=>n.hB5,Frustum:()=>n.PPD,FrustumArray:()=>n.uf3,GLBufferAttribute:()=>n.oh6,GLSL1:()=>n.Wyr,GLSL3:()=>n.Wdf,GreaterCompare:()=>n.eoi,GreaterDepth:()=>n.K52,GreaterEqualCompare:()=>n.gWB,GreaterEqualDepth:()=>n.Gwm,GreaterEqualStencilFunc:()=>n.TMh,GreaterStencilFunc:()=>n.RcT,GridHelper:()=>n.fTw,Group:()=>n.YJl,HalfFloatType:()=>n.ix0,HemisphereLight:()=>n.dth,HemisphereLightHelper:()=>n.R1W,IcosahedronGeometry:()=>n.WBB,ImageBitmapLoader:()=>n.Kzg,ImageLoader:()=>n.$NF,ImageUtils:()=>n.HgN,IncrementStencilOp:()=>n.HLH,IncrementWrapStencilOp:()=>n.Ru$,InstancedBufferAttribute:()=>n.uWO,InstancedBufferGeometry:()=>n.CmU,InstancedInterleavedBuffer:()=>n.LuO,InstancedMesh:()=>n.ZLX,Int16BufferAttribute:()=>n.Hrb,Int32BufferAttribute:()=>n.vmz,Int8BufferAttribute:()=>n.wvS,IntType:()=>n.Yuy,InterleavedBuffer:()=>n.eB$,InterleavedBufferAttribute:()=>n.eHs,Interpolant:()=>n.lGw,InterpolateDiscrete:()=>n.ljd,InterpolateLinear:()=>n.PJ3,InterpolateSmooth:()=>n.EQC,InterpolationSamplingMode:()=>n.TM5,InterpolationSamplingType:()=>n.G4u,InvertStencilOp:()=>n.oVO,KeepStencilOp:()=>n.VVr,KeyframeTrack:()=>n.UJ6,LOD:()=>n.UpK,LatheGeometry:()=>n.nzx,Layers:()=>n.zgK,LessCompare:()=>n.vim,LessDepth:()=>n.brA,LessEqualCompare:()=>n.TiK,LessEqualDepth:()=>n.xSv,LessEqualStencilFunc:()=>n.CR7,LessStencilFunc:()=>n.kYr,Light:()=>n.veJ,LightProbe:()=>n.FZo,Line:()=>n.N1A,Line3:()=>n.cZY,LineBasicMaterial:()=>n.mrM,LineCurve:()=>n.GZZ,LineCurve3:()=>n.VnP,LineDashedMaterial:()=>n.Fvt,LineLoop:()=>n.FCc,LineSegments:()=>n.DXC,LinearFilter:()=>n.k6q,LinearInterpolant:()=>n.ezk,LinearMipMapLinearFilter:()=>n.NZq,LinearMipMapNearestFilter:()=>n.iUH,LinearMipmapLinearFilter:()=>n.$_I,LinearMipmapNearestFilter:()=>n.kRr,LinearSRGBColorSpace:()=>n.Zr2,LinearToneMapping:()=>n.kyO,LinearTransfer:()=>n.VxR,Loader:()=>n.aHM,LoaderUtils:()=>n.r6x,LoadingManager:()=>n.KPJ,LoopOnce:()=>n.G3T,LoopPingPong:()=>n.lc7,LoopRepeat:()=>n.aMy,MOUSE:()=>n.kBv,Material:()=>n.imn,MaterialLoader:()=>n.jut,MathUtils:()=>n.cj9,Matrix2:()=>n.k_V,Matrix3:()=>n.dwI,Matrix4:()=>n.kn4,MaxEquation:()=>n.$ei,Mesh:()=>n.eaF,MeshBasicMaterial:()=>n.V9B,MeshDepthMaterial:()=>n.CSG,MeshDistanceMaterial:()=>n.aVO,MeshLambertMaterial:()=>n.G_z,MeshMatcapMaterial:()=>n.FNr,MeshNormalMaterial:()=>n.qBx,MeshPhongMaterial:()=>n.tXL,MeshPhysicalMaterial:()=>n.uSd,MeshStandardMaterial:()=>n._4j,MeshToonMaterial:()=>n.Df,MinEquation:()=>n.znC,MirroredRepeatWrapping:()=>n.kTW,MixOperation:()=>n.KRh,MultiplyBlending:()=>n.EdD,MultiplyOperation:()=>n.caT,NearestFilter:()=>n.hxR,NearestMipMapLinearFilter:()=>n.a$r,NearestMipMapNearestFilter:()=>n.$O9,NearestMipmapLinearFilter:()=>n.Cfg,NearestMipmapNearestFilter:()=>n.pHI,NeutralToneMapping:()=>n.aJ8,NeverCompare:()=>n.amv,NeverDepth:()=>n.eHc,NeverStencilFunc:()=>n.HPb,NoBlending:()=>n.XIg,NoColorSpace:()=>n.jf0,NoToneMapping:()=>n.y_p,NormalAnimationBlendMode:()=>n.Ke9,NormalBlending:()=>n.NTi,NotEqualCompare:()=>n.jzd,NotEqualDepth:()=>n.bw0,NotEqualStencilFunc:()=>n.klZ,NumberKeyframeTrack:()=>n.Hit,Object3D:()=>n.B69,ObjectLoader:()=>n.XTe,ObjectSpaceNormalMap:()=>n.vyJ,OctahedronGeometry:()=>n.Ufg,OneFactor:()=>n.qad,OneMinusConstantAlphaFactor:()=>n.ov9,OneMinusConstantColorFactor:()=>n.$Yl,OneMinusDstAlphaFactor:()=>n.Nt7,OneMinusDstColorFactor:()=>n.aEY,OneMinusSrcAlphaFactor:()=>n.OuU,OneMinusSrcColorFactor:()=>n.LiQ,OrthographicCamera:()=>n.qUd,PCFShadowMap:()=>n.QP0,PCFSoftShadowMap:()=>n.Wk7,PMREMGenerator:()=>M,Path:()=>n.wAk,PerspectiveCamera:()=>n.ubm,Plane:()=>n.Zcv,PlaneGeometry:()=>n.bdM,PlaneHelper:()=>n.ZM4,PointLight:()=>n.HiM,PointLightHelper:()=>n.F1l,Points:()=>n.ONl,PointsMaterial:()=>n.BH$,PolarGridHelper:()=>n.hzE,PolyhedronGeometry:()=>n.pFK,PositionalAudio:()=>n.xZx,PropertyBinding:()=>n.Nwf,PropertyMixer:()=>n.N2s,QuadraticBezierCurve:()=>n.dAo,QuadraticBezierCurve3:()=>n.CV9,Quaternion:()=>n.PTz,QuaternionKeyframeTrack:()=>n.MBL,QuaternionLinearInterpolant:()=>n.GBG,RED_GREEN_RGTC2_Format:()=>n.HO_,RED_RGTC1_Format:()=>n.Kef,REVISION:()=>n.sPf,RGBADepthPacking:()=>n.N5j,RGBAFormat:()=>n.GWd,RGBAIntegerFormat:()=>n.c90,RGBA_ASTC_10x10_Format:()=>n.y3Z,RGBA_ASTC_10x5_Format:()=>n.uB5,RGBA_ASTC_10x6_Format:()=>n.lyL,RGBA_ASTC_10x8_Format:()=>n.bC7,RGBA_ASTC_12x10_Format:()=>n.ojs,RGBA_ASTC_12x12_Format:()=>n.S$4,RGBA_ASTC_4x4_Format:()=>n.qa3,RGBA_ASTC_5x4_Format:()=>n.B_h,RGBA_ASTC_5x5_Format:()=>n.czI,RGBA_ASTC_6x5_Format:()=>n.rSH,RGBA_ASTC_6x6_Format:()=>n.Qrf,RGBA_ASTC_8x5_Format:()=>n.psI,RGBA_ASTC_8x6_Format:()=>n.a5J,RGBA_ASTC_8x8_Format:()=>n._QJ,RGBA_BPTC_Format:()=>n.Fn,RGBA_ETC2_EAC_Format:()=>n.KDk,RGBA_PVRTC_2BPPV1_Format:()=>n.pBf,RGBA_PVRTC_4BPPV1_Format:()=>n.HXV,RGBA_S3TC_DXT1_Format:()=>n.Nz6,RGBA_S3TC_DXT3_Format:()=>n.jR7,RGBA_S3TC_DXT5_Format:()=>n.BXX,RGBDepthPacking:()=>n.wTz,RGBFormat:()=>n.HIg,RGBIntegerFormat:()=>n.VGF,RGB_BPTC_SIGNED_Format:()=>n.H23,RGB_BPTC_UNSIGNED_Format:()=>n.W9U,RGB_ETC1_Format:()=>n.CVz,RGB_ETC2_Format:()=>n.Riy,RGB_PVRTC_2BPPV1_Format:()=>n.kTp,RGB_PVRTC_4BPPV1_Format:()=>n.k6Q,RGB_S3TC_DXT1_Format:()=>n.IE4,RGDepthPacking:()=>n.k8v,RGFormat:()=>n.paN,RGIntegerFormat:()=>n.TkQ,RawShaderMaterial:()=>n.D$Q,Ray:()=>n.RlV,Raycaster:()=>n.tBo,RectAreaLight:()=>n.ure,RedFormat:()=>n.VT0,RedIntegerFormat:()=>n.ZQM,ReinhardToneMapping:()=>n.Mjd,RenderTarget:()=>n.O0B,RenderTarget3D:()=>n.XMJ,RepeatWrapping:()=>n.GJx,ReplaceStencilOp:()=>n.kG0,ReverseSubtractEquation:()=>n.nST,RingGeometry:()=>n.rKP,SIGNED_RED_GREEN_RGTC2_Format:()=>n.CWW,SIGNED_RED_RGTC1_Format:()=>n.XG_,SRGBColorSpace:()=>n.er$,SRGBTransfer:()=>n.KLL,Scene:()=>n.Z58,ShaderChunk:()=>a,ShaderLib:()=>o,ShaderMaterial:()=>n.BKk,ShadowMaterial:()=>n.q2,Shape:()=>n.ypk,ShapeGeometry:()=>n.MSw,ShapePath:()=>n.Ld9,ShapeUtils:()=>n.xJ6,ShortType:()=>n.fBL,Skeleton:()=>n.EAD,SkeletonHelper:()=>n._xc,SkinnedMesh:()=>n.I46,Source:()=>n.kLi,Sphere:()=>n.iyt,SphereGeometry:()=>n.Gu$,Spherical:()=>n.YHV,SphericalHarmonics3:()=>n.xOk,SplineCurve:()=>n.xfg,SpotLight:()=>n.nCl,SpotLightHelper:()=>n.Fpm,Sprite:()=>n.kxk,SpriteMaterial:()=>n.RoJ,SrcAlphaFactor:()=>n.ie2,SrcAlphaSaturateFactor:()=>n.hgQ,SrcColorFactor:()=>n.f4X,StaticCopyUsage:()=>n.Hrq,StaticDrawUsage:()=>n.agE,StaticReadUsage:()=>n.uXQ,StereoCamera:()=>n.keZ,StreamCopyUsage:()=>n.rOG,StreamDrawUsage:()=>n.Ktl,StreamReadUsage:()=>n.uov,StringKeyframeTrack:()=>n.hZF,SubtractEquation:()=>n.FXf,SubtractiveBlending:()=>n.Kwu,TOUCH:()=>n.wtR,TangentSpaceNormalMap:()=>n.bI3,TetrahedronGeometry:()=>n.Zpd,Texture:()=>n.gPd,TextureLoader:()=>n.Tap,TextureUtils:()=>n.Vwu,TimestampQuery:()=>n.v9J,TorusGeometry:()=>n.O3Y,TorusKnotGeometry:()=>n.UPV,Triangle:()=>n.lMl,TriangleFanDrawMode:()=>n.rYR,TriangleStripDrawMode:()=>n.O49,TrianglesDrawMode:()=>n.RJ4,TubeGeometry:()=>n.j6,UVMapping:()=>n.UTZ,Uint16BufferAttribute:()=>n.A$4,Uint32BufferAttribute:()=>n.MW4,Uint8BufferAttribute:()=>n.baL,Uint8ClampedBufferAttribute:()=>n.fc6,Uniform:()=>n.nc$,UniformsGroup:()=>n.dzP,UniformsLib:()=>r,UniformsUtils:()=>n.LlO,UnsignedByteType:()=>n.OUM,UnsignedInt248Type:()=>n.V3x,UnsignedInt5999Type:()=>n.Dmk,UnsignedIntType:()=>n.bkx,UnsignedShort4444Type:()=>n.Wew,UnsignedShort5551Type:()=>n.gJ2,UnsignedShortType:()=>n.cHt,VSMShadowMap:()=>n.RyA,Vector2:()=>n.I9Y,Vector3:()=>n.Pq0,Vector4:()=>n.IUQ,VectorKeyframeTrack:()=>n.RiT,VideoFrameTexture:()=>n.SYV,VideoTexture:()=>n.Nv2,WebGL3DRenderTarget:()=>n.ALV,WebGLArrayRenderTarget:()=>n.y9J,WebGLCoordinateSystem:()=>n.TdN,WebGLCubeRenderTarget:()=>n.o6l,WebGLRenderTarget:()=>n.nWS,WebGLRenderer:()=>GA,WebGLUtils:()=>bA,WebGPUCoordinateSystem:()=>n.i7u,WebXRController:()=>n.R3r,WireframeGeometry:()=>n.XJ7,WrapAroundEnding:()=>n.dhZ,ZeroCurvatureEnding:()=>n.rQf,ZeroFactor:()=>n.ojh,ZeroSlopeEnding:()=>n.h2z,ZeroStencilOp:()=>n.kqe,createCanvasElement:()=>n.lPF});var n=e(184);function i(){let t=null,A=!1,e=null,n=null;function i(A,s){e(A,s),n=t.requestAnimationFrame(i)}return{start:function(){!0!==A&&null!==e&&(n=t.requestAnimationFrame(i),A=!0)},stop:function(){t.cancelAnimationFrame(n),A=!1},setAnimationLoop:function(t){e=t},setContext:function(A){t=A}}}function s(t){const A=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),A.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=A.get(e);n&&(t.deleteBuffer(n.buffer),A.delete(e))},update:function(e,n){if(e.isInterleavedBufferAttribute&&(e=e.data),e.isGLBufferAttribute){const t=A.get(e);return void((!t||t.version<e.version)&&A.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}const i=A.get(e);if(void 0===i)A.set(e,function(A,e){const n=A.array,i=A.usage,s=n.byteLength,a=t.createBuffer();let r;if(t.bindBuffer(e,a),t.bufferData(e,n,i),A.onUploadCallback(),n instanceof Float32Array)r=t.FLOAT;else if("undefined"!=typeof Float16Array&&n instanceof Float16Array)r=t.HALF_FLOAT;else if(n instanceof Uint16Array)r=A.isFloat16BufferAttribute?t.HALF_FLOAT:t.UNSIGNED_SHORT;else if(n instanceof Int16Array)r=t.SHORT;else if(n instanceof Uint32Array)r=t.UNSIGNED_INT;else if(n instanceof Int32Array)r=t.INT;else if(n instanceof Int8Array)r=t.BYTE;else if(n instanceof Uint8Array)r=t.UNSIGNED_BYTE;else{if(!(n instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+n);r=t.UNSIGNED_BYTE}return{buffer:a,type:r,bytesPerElement:n.BYTES_PER_ELEMENT,version:A.version,size:s}}(e,n));else if(i.version<e.version){if(i.size!==e.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(A,e,n){const i=e.array,s=e.updateRanges;if(t.bindBuffer(n,A),0===s.length)t.bufferSubData(n,0,i);else{s.sort((t,A)=>t.start-A.start);let A=0;for(let t=1;t<s.length;t++){const e=s[A],n=s[t];n.start<=e.start+e.count+1?e.count=Math.max(e.count,n.start+n.count-e.start):(++A,s[A]=n)}s.length=A+1;for(let A=0,e=s.length;A<e;A++){const e=s[A];t.bufferSubData(n,e.start*i.BYTES_PER_ELEMENT,i,e.start,e.count)}e.clearUpdateRanges()}e.onUploadCallback()}(i.buffer,e,n),i.version=e.version}}}}const a={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphinstance_vertex:"#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},r={common:{diffuse:{value:new n.Q1f(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new n.dwI},alphaMap:{value:null},alphaMapTransform:{value:new n.dwI},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new n.dwI}},envmap:{envMap:{value:null},envMapRotation:{value:new n.dwI},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new n.dwI}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new n.dwI}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new n.dwI},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new n.dwI},normalScale:{value:new n.I9Y(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new n.dwI},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new n.dwI}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new n.dwI}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new n.dwI}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new n.Q1f(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new n.Q1f(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new n.dwI},alphaTest:{value:0},uvTransform:{value:new n.dwI}},sprite:{diffuse:{value:new n.Q1f(16777215)},opacity:{value:1},center:{value:new n.I9Y(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new n.dwI},alphaMap:{value:null},alphaMapTransform:{value:new n.dwI},alphaTest:{value:0}}},o={basic:{uniforms:(0,n.Iit)([r.common,r.specularmap,r.envmap,r.aomap,r.lightmap,r.fog]),vertexShader:a.meshbasic_vert,fragmentShader:a.meshbasic_frag},lambert:{uniforms:(0,n.Iit)([r.common,r.specularmap,r.envmap,r.aomap,r.lightmap,r.emissivemap,r.bumpmap,r.normalmap,r.displacementmap,r.fog,r.lights,{emissive:{value:new n.Q1f(0)}}]),vertexShader:a.meshlambert_vert,fragmentShader:a.meshlambert_frag},phong:{uniforms:(0,n.Iit)([r.common,r.specularmap,r.envmap,r.aomap,r.lightmap,r.emissivemap,r.bumpmap,r.normalmap,r.displacementmap,r.fog,r.lights,{emissive:{value:new n.Q1f(0)},specular:{value:new n.Q1f(1118481)},shininess:{value:30}}]),vertexShader:a.meshphong_vert,fragmentShader:a.meshphong_frag},standard:{uniforms:(0,n.Iit)([r.common,r.envmap,r.aomap,r.lightmap,r.emissivemap,r.bumpmap,r.normalmap,r.displacementmap,r.roughnessmap,r.metalnessmap,r.fog,r.lights,{emissive:{value:new n.Q1f(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:a.meshphysical_vert,fragmentShader:a.meshphysical_frag},toon:{uniforms:(0,n.Iit)([r.common,r.aomap,r.lightmap,r.emissivemap,r.bumpmap,r.normalmap,r.displacementmap,r.gradientmap,r.fog,r.lights,{emissive:{value:new n.Q1f(0)}}]),vertexShader:a.meshtoon_vert,fragmentShader:a.meshtoon_frag},matcap:{uniforms:(0,n.Iit)([r.common,r.bumpmap,r.normalmap,r.displacementmap,r.fog,{matcap:{value:null}}]),vertexShader:a.meshmatcap_vert,fragmentShader:a.meshmatcap_frag},points:{uniforms:(0,n.Iit)([r.points,r.fog]),vertexShader:a.points_vert,fragmentShader:a.points_frag},dashed:{uniforms:(0,n.Iit)([r.common,r.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:a.linedashed_vert,fragmentShader:a.linedashed_frag},depth:{uniforms:(0,n.Iit)([r.common,r.displacementmap]),vertexShader:a.depth_vert,fragmentShader:a.depth_frag},normal:{uniforms:(0,n.Iit)([r.common,r.bumpmap,r.normalmap,r.displacementmap,{opacity:{value:1}}]),vertexShader:a.meshnormal_vert,fragmentShader:a.meshnormal_frag},sprite:{uniforms:(0,n.Iit)([r.sprite,r.fog]),vertexShader:a.sprite_vert,fragmentShader:a.sprite_frag},background:{uniforms:{uvTransform:{value:new n.dwI},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:a.background_vert,fragmentShader:a.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new n.dwI}},vertexShader:a.backgroundCube_vert,fragmentShader:a.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:a.cube_vert,fragmentShader:a.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:a.equirect_vert,fragmentShader:a.equirect_frag},distanceRGBA:{uniforms:(0,n.Iit)([r.common,r.displacementmap,{referencePosition:{value:new n.Pq0},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:a.distanceRGBA_vert,fragmentShader:a.distanceRGBA_frag},shadow:{uniforms:(0,n.Iit)([r.lights,r.fog,{color:{value:new n.Q1f(0)},opacity:{value:1}}]),vertexShader:a.shadow_vert,fragmentShader:a.shadow_frag}};o.physical={uniforms:(0,n.Iit)([o.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new n.dwI},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new n.dwI},clearcoatNormalScale:{value:new n.I9Y(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new n.dwI},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new n.dwI},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new n.dwI},sheen:{value:0},sheenColor:{value:new n.Q1f(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new n.dwI},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new n.dwI},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new n.dwI},transmissionSamplerSize:{value:new n.I9Y},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new n.dwI},attenuationDistance:{value:0},attenuationColor:{value:new n.Q1f(0)},specularColor:{value:new n.Q1f(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new n.dwI},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new n.dwI},anisotropyVector:{value:new n.I9Y},anisotropyMap:{value:null},anisotropyMapTransform:{value:new n.dwI}}]),vertexShader:a.meshphysical_vert,fragmentShader:a.meshphysical_frag};const g={r:0,b:0,g:0},c=new n.O9p,l=new n.kn4;function I(t,A,e,i,s,a,r){const I=new n.Q1f(0);let h,u,B=!0===a?0:1,d=null,C=0,E=null;function Q(t){let n=!0===t.isScene?t.background:null;return n&&n.isTexture&&(n=(t.backgroundBlurriness>0?e:A).get(n)),n}function p(A,e){A.getRGB(g,(0,n._Ut)(t)),i.buffers.color.setClear(g.r,g.g,g.b,e,r)}return{getClearColor:function(){return I},setClearColor:function(t,A=1){I.set(t),B=A,p(I,B)},getClearAlpha:function(){return B},setClearAlpha:function(t){B=t,p(I,B)},render:function(A){let e=!1;const n=Q(A);null===n?p(I,B):n&&n.isColor&&(p(n,1),e=!0);const s=t.xr.getEnvironmentBlendMode();"additive"===s?i.buffers.color.setClear(0,0,0,1,r):"alpha-blend"===s&&i.buffers.color.setClear(0,0,0,0,r),(t.autoClear||e)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil))},addToRenderList:function(A,e){const i=Q(e);i&&(i.isCubeTexture||i.mapping===n.Om)?(void 0===u&&(u=new n.eaF(new n.iNn(1,1,1),new n.BKk({name:"BackgroundCubeMaterial",uniforms:(0,n.lxW)(o.backgroundCube.uniforms),vertexShader:o.backgroundCube.vertexShader,fragmentShader:o.backgroundCube.fragmentShader,side:n.hsX,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(t,A,e){this.matrixWorld.copyPosition(e.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(u)),c.copy(e.backgroundRotation),c.x*=-1,c.y*=-1,c.z*=-1,i.isCubeTexture&&!1===i.isRenderTargetTexture&&(c.y*=-1,c.z*=-1),u.material.uniforms.envMap.value=i,u.material.uniforms.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,u.material.uniforms.backgroundBlurriness.value=e.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=e.backgroundIntensity,u.material.uniforms.backgroundRotation.value.setFromMatrix4(l.makeRotationFromEuler(c)),u.material.toneMapped=n.ppV.getTransfer(i.colorSpace)!==n.KLL,d===i&&C===i.version&&E===t.toneMapping||(u.material.needsUpdate=!0,d=i,C=i.version,E=t.toneMapping),u.layers.enableAll(),A.unshift(u,u.geometry,u.material,0,0,null)):i&&i.isTexture&&(void 0===h&&(h=new n.eaF(new n.bdM(2,2),new n.BKk({name:"BackgroundMaterial",uniforms:(0,n.lxW)(o.background.uniforms),vertexShader:o.background.vertexShader,fragmentShader:o.background.fragmentShader,side:n.hB5,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),h.geometry.deleteAttribute("normal"),Object.defineProperty(h.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(h)),h.material.uniforms.t2D.value=i,h.material.uniforms.backgroundIntensity.value=e.backgroundIntensity,h.material.toneMapped=n.ppV.getTransfer(i.colorSpace)!==n.KLL,!0===i.matrixAutoUpdate&&i.updateMatrix(),h.material.uniforms.uvTransform.value.copy(i.matrix),d===i&&C===i.version&&E===t.toneMapping||(h.material.needsUpdate=!0,d=i,C=i.version,E=t.toneMapping),h.layers.enableAll(),A.unshift(h,h.geometry,h.material,0,0,null))},dispose:function(){void 0!==u&&(u.geometry.dispose(),u.material.dispose(),u=void 0),void 0!==h&&(h.geometry.dispose(),h.material.dispose(),h=void 0)}}}function h(t,A){const e=t.getParameter(t.MAX_VERTEX_ATTRIBS),i={},s=c(null);let a=s,r=!1;function o(A){return t.bindVertexArray(A)}function g(A){return t.deleteVertexArray(A)}function c(t){const A=[],n=[],i=[];for(let t=0;t<e;t++)A[t]=0,n[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:A,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function l(){const t=a.newAttributes;for(let A=0,e=t.length;A<e;A++)t[A]=0}function I(t){h(t,0)}function h(A,e){const n=a.newAttributes,i=a.enabledAttributes,s=a.attributeDivisors;n[A]=1,0===i[A]&&(t.enableVertexAttribArray(A),i[A]=1),s[A]!==e&&(t.vertexAttribDivisor(A,e),s[A]=e)}function u(){const A=a.newAttributes,e=a.enabledAttributes;for(let n=0,i=e.length;n<i;n++)e[n]!==A[n]&&(t.disableVertexAttribArray(n),e[n]=0)}function B(A,e,n,i,s,a,r){!0===r?t.vertexAttribIPointer(A,e,n,s,a):t.vertexAttribPointer(A,e,n,i,s,a)}function d(){C(),r=!0,a!==s&&(a=s,o(a.object))}function C(){s.geometry=null,s.program=null,s.wireframe=!1}return{setup:function(e,s,g,d,C){let E=!1;const Q=function(A,e,n){const s=!0===n.wireframe;let a=i[A.id];void 0===a&&(a={},i[A.id]=a);let r=a[e.id];void 0===r&&(r={},a[e.id]=r);let o=r[s];return void 0===o&&(o=c(t.createVertexArray()),r[s]=o),o}(d,g,s);a!==Q&&(a=Q,o(a.object)),E=function(t,A,e,n){const i=a.attributes,s=A.attributes;let r=0;const o=e.getAttributes();for(const A in o)if(o[A].location>=0){const e=i[A];let n=s[A];if(void 0===n&&("instanceMatrix"===A&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===A&&t.instanceColor&&(n=t.instanceColor)),void 0===e)return!0;if(e.attribute!==n)return!0;if(n&&e.data!==n.data)return!0;r++}return a.attributesNum!==r||a.index!==n}(e,d,g,C),E&&function(t,A,e,n){const i={},s=A.attributes;let r=0;const o=e.getAttributes();for(const A in o)if(o[A].location>=0){let e=s[A];void 0===e&&("instanceMatrix"===A&&t.instanceMatrix&&(e=t.instanceMatrix),"instanceColor"===A&&t.instanceColor&&(e=t.instanceColor));const n={};n.attribute=e,e&&e.data&&(n.data=e.data),i[A]=n,r++}a.attributes=i,a.attributesNum=r,a.index=n}(e,d,g,C),null!==C&&A.update(C,t.ELEMENT_ARRAY_BUFFER),(E||r)&&(r=!1,function(e,i,s,a){l();const r=a.attributes,o=s.getAttributes(),g=i.defaultAttributeValues;for(const i in o){const s=o[i];if(s.location>=0){let o=r[i];if(void 0===o&&("instanceMatrix"===i&&e.instanceMatrix&&(o=e.instanceMatrix),"instanceColor"===i&&e.instanceColor&&(o=e.instanceColor)),void 0!==o){const i=o.normalized,r=o.itemSize,g=A.get(o);if(void 0===g)continue;const c=g.buffer,l=g.type,u=g.bytesPerElement,d=l===t.INT||l===t.UNSIGNED_INT||o.gpuType===n.Yuy;if(o.isInterleavedBufferAttribute){const A=o.data,n=A.stride,g=o.offset;if(A.isInstancedInterleavedBuffer){for(let t=0;t<s.locationSize;t++)h(s.location+t,A.meshPerAttribute);!0!==e.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=A.meshPerAttribute*A.count)}else for(let t=0;t<s.locationSize;t++)I(s.location+t);t.bindBuffer(t.ARRAY_BUFFER,c);for(let t=0;t<s.locationSize;t++)B(s.location+t,r/s.locationSize,l,i,n*u,(g+r/s.locationSize*t)*u,d)}else{if(o.isInstancedBufferAttribute){for(let t=0;t<s.locationSize;t++)h(s.location+t,o.meshPerAttribute);!0!==e.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=o.meshPerAttribute*o.count)}else for(let t=0;t<s.locationSize;t++)I(s.location+t);t.bindBuffer(t.ARRAY_BUFFER,c);for(let t=0;t<s.locationSize;t++)B(s.location+t,r/s.locationSize,l,i,r*u,r/s.locationSize*t*u,d)}}else if(void 0!==g){const A=g[i];if(void 0!==A)switch(A.length){case 2:t.vertexAttrib2fv(s.location,A);break;case 3:t.vertexAttrib3fv(s.location,A);break;case 4:t.vertexAttrib4fv(s.location,A);break;default:t.vertexAttrib1fv(s.location,A)}}}}u()}(e,s,g,d),null!==C&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,A.get(C).buffer))},reset:d,resetDefaultState:C,dispose:function(){d();for(const t in i){const A=i[t];for(const t in A){const e=A[t];for(const t in e)g(e[t].object),delete e[t];delete A[t]}delete i[t]}},releaseStatesOfGeometry:function(t){if(void 0===i[t.id])return;const A=i[t.id];for(const t in A){const e=A[t];for(const t in e)g(e[t].object),delete e[t];delete A[t]}delete i[t.id]},releaseStatesOfProgram:function(t){for(const A in i){const e=i[A];if(void 0===e[t.id])continue;const n=e[t.id];for(const t in n)g(n[t].object),delete n[t];delete e[t.id]}},initAttributes:l,enableAttribute:I,disableUnusedAttributes:u}}function u(t,A,e){let n;function i(A,i,s){0!==s&&(t.drawArraysInstanced(n,A,i,s),e.update(i,n,s))}this.setMode=function(t){n=t},this.render=function(A,i){t.drawArrays(n,A,i),e.update(i,n,1)},this.renderInstances=i,this.renderMultiDraw=function(t,i,s){if(0===s)return;A.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,t,0,i,0,s);let a=0;for(let t=0;t<s;t++)a+=i[t];e.update(a,n,1)},this.renderMultiDrawInstances=function(t,s,a,r){if(0===a)return;const o=A.get("WEBGL_multi_draw");if(null===o)for(let A=0;A<t.length;A++)i(t[A],s[A],r[A]);else{o.multiDrawArraysInstancedWEBGL(n,t,0,s,0,r,0,a);let A=0;for(let t=0;t<a;t++)A+=s[t]*r[t];e.update(A,n,1)}}}function B(t,A,e,i){let s;function a(A){if("highp"===A){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";A="mediump"}return"mediump"===A&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let r=void 0!==e.precision?e.precision:"highp";const o=a(r);o!==r&&(console.warn("THREE.WebGLRenderer:",r,"not supported, using",o,"instead."),r=o);const g=!0===e.logarithmicDepthBuffer,c=!0===e.reverseDepthBuffer&&A.has("EXT_clip_control"),l=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),I=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==s)return s;if(!0===A.has("EXT_texture_filter_anisotropic")){const e=A.get("EXT_texture_filter_anisotropic");s=t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s},getMaxPrecision:a,textureFormatReadable:function(A){return A===n.GWd||i.convert(A)===t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(e){const s=e===n.ix0&&(A.has("EXT_color_buffer_half_float")||A.has("EXT_color_buffer_float"));return!(e!==n.OUM&&i.convert(e)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE)&&e!==n.RQf&&!s)},precision:r,logarithmicDepthBuffer:g,reverseDepthBuffer:c,maxTextures:l,maxVertexTextures:I,maxTextureSize:t.getParameter(t.MAX_TEXTURE_SIZE),maxCubemapSize:t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:t.getParameter(t.MAX_VERTEX_ATTRIBS),maxVertexUniforms:t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:t.getParameter(t.MAX_VARYING_VECTORS),maxFragmentUniforms:t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:I>0,maxSamples:t.getParameter(t.MAX_SAMPLES)}}function d(t){const A=this;let e=null,i=0,s=!1,a=!1;const r=new n.Zcv,o=new n.dwI,g={value:null,needsUpdate:!1};function c(t,e,n,i){const s=null!==t?t.length:0;let a=null;if(0!==s){if(a=g.value,!0!==i||null===a){const A=n+4*s,i=e.matrixWorldInverse;o.getNormalMatrix(i),(null===a||a.length<A)&&(a=new Float32Array(A));for(let A=0,e=n;A!==s;++A,e+=4)r.copy(t[A]).applyMatrix4(i,o),r.normal.toArray(a,e),a[e+3]=r.constant}g.value=a,g.needsUpdate=!0}return A.numPlanes=s,A.numIntersection=0,a}this.uniform=g,this.numPlanes=0,this.numIntersection=0,this.init=function(t,A){const e=0!==t.length||A||0!==i||s;return s=A,i=t.length,e},this.beginShadows=function(){a=!0,c(null)},this.endShadows=function(){a=!1},this.setGlobalState=function(t,A){e=c(t,A,0)},this.setState=function(n,r,o){const l=n.clippingPlanes,I=n.clipIntersection,h=n.clipShadows,u=t.get(n);if(!s||null===l||0===l.length||a&&!h)a?c(null):(g.value!==e&&(g.value=e,g.needsUpdate=i>0),A.numPlanes=i,A.numIntersection=0);else{const t=a?0:i,A=4*t;let n=u.clippingState||null;g.value=n,n=c(l,r,A,o);for(let t=0;t!==A;++t)n[t]=e[t];u.clippingState=n,this.numIntersection=I?this.numPlanes:0,this.numPlanes+=t}}}function C(t){let A=new WeakMap;function e(t,A){return A===n.wfO?t.mapping=n.hy7:A===n.uV5&&(t.mapping=n.xFO),t}function i(t){const e=t.target;e.removeEventListener("dispose",i);const n=A.get(e);void 0!==n&&(A.delete(e),n.dispose())}return{get:function(s){if(s&&s.isTexture){const a=s.mapping;if(a===n.wfO||a===n.uV5){if(A.has(s))return e(A.get(s).texture,s.mapping);{const a=s.image;if(a&&a.height>0){const r=new n.o6l(a.height);return r.fromEquirectangularTexture(t,s),A.set(s,r),s.addEventListener("dispose",i),e(r.texture,s.mapping)}return null}}}return s},dispose:function(){A=new WeakMap}}}const E=[.125,.215,.35,.446,.526,.582],Q=new n.qUd,p=new n.Q1f;let f=null,m=0,y=0,w=!1;const x=(1+Math.sqrt(5))/2,S=1/x,D=[new n.Pq0(-x,S,0),new n.Pq0(x,S,0),new n.Pq0(-S,0,x),new n.Pq0(S,0,x),new n.Pq0(0,x,-S),new n.Pq0(0,x,S),new n.Pq0(-1,1,-1),new n.Pq0(1,1,-1),new n.Pq0(-1,1,1),new n.Pq0(1,1,1)],v=new n.Pq0;class M{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,A=0,e=.1,n=100,i={}){const{size:s=256,position:a=v}=i;f=this._renderer.getRenderTarget(),m=this._renderer.getActiveCubeFace(),y=this._renderer.getActiveMipmapLevel(),w=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(s);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(t,e,n,r,a),A>0&&this._blur(r,0,0,A),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t,A=null){return this._fromTexture(t,A)}fromCubemap(t,A=null){return this._fromTexture(t,A)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=F(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=R(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(f,m,y),this._renderer.xr.enabled=w,t.scissorTest=!1,_(t,0,0,t.width,t.height)}_fromTexture(t,A){t.mapping===n.hy7||t.mapping===n.xFO?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),f=this._renderer.getRenderTarget(),m=this._renderer.getActiveCubeFace(),y=this._renderer.getActiveMipmapLevel(),w=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const e=A||this._allocateTargets();return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),A=4*this._cubeSize,e={magFilter:n.k6q,minFilter:n.k6q,generateMipmaps:!1,type:n.ix0,format:n.GWd,colorSpace:n.Zr2,depthBuffer:!1},i=b(t,A,e);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==A){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=b(t,A,e);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const A=[],e=[],i=[];let s=t;const a=t-4+1+E.length;for(let r=0;r<a;r++){const a=Math.pow(2,s);e.push(a);let o=1/a;r>t-4?o=E[r-t+4-1]:0===r&&(o=0),i.push(o);const g=1/(a-2),c=-g,l=1+g,I=[c,c,l,c,l,l,c,c,l,l,c,l],h=6,u=6,B=3,d=2,C=1,Q=new Float32Array(B*u*h),p=new Float32Array(d*u*h),f=new Float32Array(C*u*h);for(let t=0;t<h;t++){const A=t%3*2/3-1,e=t>2?0:-1,n=[A,e,0,A+2/3,e,0,A+2/3,e+1,0,A,e,0,A+2/3,e+1,0,A,e+1,0];Q.set(n,B*u*t),p.set(I,d*u*t);const i=[t,t,t,t,t,t];f.set(i,C*u*t)}const m=new n.LoY;m.setAttribute("position",new n.THS(Q,B)),m.setAttribute("uv",new n.THS(p,d)),m.setAttribute("faceIndex",new n.THS(f,C)),A.push(m),s>4&&s--}return{lodPlanes:A,sizeLods:e,sigmas:i}}(i)),this._blurMaterial=function(t,A,e){const i=new Float32Array(20),s=new n.Pq0(0,1,0);return new n.BKk({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/A,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:n.XIg,depthTest:!1,depthWrite:!1})}(i,t,A)}return i}_compileMaterial(t){const A=new n.eaF(this._lodPlanes[0],t);this._renderer.compile(A,Q)}_sceneToCubeUV(t,A,e,i,s){const a=new n.ubm(90,1,A,e),r=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],g=this._renderer,c=g.autoClear,l=g.toneMapping;g.getClearColor(p),g.toneMapping=n.y_p,g.autoClear=!1;const I=new n.V9B({name:"PMREM.Background",side:n.hsX,depthWrite:!1,depthTest:!1}),h=new n.eaF(new n.iNn,I);let u=!1;const B=t.background;B?B.isColor&&(I.color.copy(B),t.background=null,u=!0):(I.color.copy(p),u=!0);for(let A=0;A<6;A++){const e=A%3;0===e?(a.up.set(0,r[A],0),a.position.set(s.x,s.y,s.z),a.lookAt(s.x+o[A],s.y,s.z)):1===e?(a.up.set(0,0,r[A]),a.position.set(s.x,s.y,s.z),a.lookAt(s.x,s.y+o[A],s.z)):(a.up.set(0,r[A],0),a.position.set(s.x,s.y,s.z),a.lookAt(s.x,s.y,s.z+o[A]));const n=this._cubeSize;_(i,e*n,A>2?n:0,n,n),g.setRenderTarget(i),u&&g.render(h,a),g.render(t,a)}h.geometry.dispose(),h.material.dispose(),g.toneMapping=l,g.autoClear=c,t.background=B}_textureToCubeUV(t,A){const e=this._renderer,i=t.mapping===n.hy7||t.mapping===n.xFO;i?(null===this._cubemapMaterial&&(this._cubemapMaterial=F()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=R());const s=i?this._cubemapMaterial:this._equirectMaterial,a=new n.eaF(this._lodPlanes[0],s);s.uniforms.envMap.value=t;const r=this._cubeSize;_(A,0,0,3*r,2*r),e.setRenderTarget(A),e.render(a,Q)}_applyPMREM(t){const A=this._renderer,e=A.autoClear;A.autoClear=!1;const n=this._lodPlanes.length;for(let A=1;A<n;A++){const e=Math.sqrt(this._sigmas[A]*this._sigmas[A]-this._sigmas[A-1]*this._sigmas[A-1]),i=D[(n-A-1)%D.length];this._blur(t,A-1,A,e,i)}A.autoClear=e}_blur(t,A,e,n,i){const s=this._pingPongRenderTarget;this._halfBlur(t,s,A,e,n,"latitudinal",i),this._halfBlur(s,t,e,e,n,"longitudinal",i)}_halfBlur(t,A,e,i,s,a,r){const o=this._renderer,g=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new n.eaF(this._lodPlanes[i],g),l=g.uniforms,I=this._sizeLods[e]-1,h=isFinite(s)?Math.PI/(2*I):2*Math.PI/39,u=s/h,B=isFinite(s)?1+Math.floor(3*u):20;B>20&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${B} samples when the maximum is set to 20`);const d=[];let C=0;for(let t=0;t<20;++t){const A=t/u,e=Math.exp(-A*A/2);d.push(e),0===t?C+=e:t<B&&(C+=2*e)}for(let t=0;t<d.length;t++)d[t]=d[t]/C;l.envMap.value=t.texture,l.samples.value=B,l.weights.value=d,l.latitudinal.value="latitudinal"===a,r&&(l.poleAxis.value=r);const{_lodMax:E}=this;l.dTheta.value=h,l.mipInt.value=E-e;const p=this._sizeLods[i];_(A,3*p*(i>E-4?i-E+4:0),4*(this._cubeSize-p),3*p,2*p),o.setRenderTarget(A),o.render(c,Q)}}function b(t,A,e){const i=new n.nWS(t,A,e);return i.texture.mapping=n.Om,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function _(t,A,e,n,i){t.viewport.set(A,e,n,i),t.scissor.set(A,e,n,i)}function R(){return new n.BKk({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:n.XIg,depthTest:!1,depthWrite:!1})}function F(){return new n.BKk({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:n.XIg,depthTest:!1,depthWrite:!1})}function N(t){let A=new WeakMap,e=null;function i(t){const e=t.target;e.removeEventListener("dispose",i);const n=A.get(e);void 0!==n&&(A.delete(e),n.dispose())}return{get:function(s){if(s&&s.isTexture){const a=s.mapping,r=a===n.wfO||a===n.uV5,o=a===n.hy7||a===n.xFO;if(r||o){let n=A.get(s);const a=void 0!==n?n.texture.pmremVersion:0;if(s.isRenderTargetTexture&&s.pmremVersion!==a)return null===e&&(e=new M(t)),n=r?e.fromEquirectangular(s,n):e.fromCubemap(s,n),n.texture.pmremVersion=s.pmremVersion,A.set(s,n),n.texture;if(void 0!==n)return n.texture;{const a=s.image;return r&&a&&a.height>0||o&&a&&function(t){let A=0;for(let e=0;e<6;e++)void 0!==t[e]&&A++;return 6===A}(a)?(null===e&&(e=new M(t)),n=r?e.fromEquirectangular(s):e.fromCubemap(s),n.texture.pmremVersion=s.pmremVersion,A.set(s,n),s.addEventListener("dispose",i),n.texture):null}}}return s},dispose:function(){A=new WeakMap,null!==e&&(e.dispose(),e=null)}}}function k(t){const A={};function e(e){if(void 0!==A[e])return A[e];let n;switch(e){case"WEBGL_depth_texture":n=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=t.getExtension(e)}return A[e]=n,n}return{has:function(t){return null!==e(t)},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(t){const A=e(t);return null===A&&(0,n.mcG)("THREE.WebGLRenderer: "+t+" extension not supported."),A}}}function T(t,A,e,i){const s={},a=new WeakMap;function r(t){const n=t.target;null!==n.index&&A.remove(n.index);for(const t in n.attributes)A.remove(n.attributes[t]);n.removeEventListener("dispose",r),delete s[n.id];const o=a.get(n);o&&(A.remove(o),a.delete(n)),i.releaseStatesOfGeometry(n),!0===n.isInstancedBufferGeometry&&delete n._maxInstanceCount,e.memory.geometries--}function o(t){const e=[],i=t.index,s=t.attributes.position;let r=0;if(null!==i){const t=i.array;r=i.version;for(let A=0,n=t.length;A<n;A+=3){const n=t[A+0],i=t[A+1],s=t[A+2];e.push(n,i,i,s,s,n)}}else{if(void 0===s)return;{const t=s.array;r=s.version;for(let A=0,n=t.length/3-1;A<n;A+=3){const t=A+0,n=A+1,i=A+2;e.push(t,n,n,i,i,t)}}}const o=new((0,n.AQS)(e)?n.MW4:n.A$4)(e,1);o.version=r;const g=a.get(t);g&&A.remove(g),a.set(t,o)}return{get:function(t,A){return!0===s[A.id]||(A.addEventListener("dispose",r),s[A.id]=!0,e.memory.geometries++),A},update:function(e){const n=e.attributes;for(const e in n)A.update(n[e],t.ARRAY_BUFFER)},getWireframeAttribute:function(t){const A=a.get(t);if(A){const e=t.index;null!==e&&A.version<e.version&&o(t)}else o(t);return a.get(t)}}}function G(t,A,e){let n,i,s;function a(A,a,r){0!==r&&(t.drawElementsInstanced(n,a,i,A*s,r),e.update(a,n,r))}this.setMode=function(t){n=t},this.setIndex=function(t){i=t.type,s=t.bytesPerElement},this.render=function(A,a){t.drawElements(n,a,i,A*s),e.update(a,n,1)},this.renderInstances=a,this.renderMultiDraw=function(t,s,a){if(0===a)return;A.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,s,0,i,t,0,a);let r=0;for(let t=0;t<a;t++)r+=s[t];e.update(r,n,1)},this.renderMultiDrawInstances=function(t,r,o,g){if(0===o)return;const c=A.get("WEBGL_multi_draw");if(null===c)for(let A=0;A<t.length;A++)a(t[A]/s,r[A],g[A]);else{c.multiDrawElementsInstancedWEBGL(n,r,0,i,t,0,g,0,o);let A=0;for(let t=0;t<o;t++)A+=r[t]*g[t];e.update(A,n,1)}}}function U(t){const A={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:A,programs:null,autoReset:!0,reset:function(){A.calls=0,A.triangles=0,A.points=0,A.lines=0},update:function(e,n,i){switch(A.calls++,n){case t.TRIANGLES:A.triangles+=i*(e/3);break;case t.LINES:A.lines+=i*(e/2);break;case t.LINE_STRIP:A.lines+=i*(e-1);break;case t.LINE_LOOP:A.lines+=i*e;break;case t.POINTS:A.points+=i*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function L(t,A,e){const i=new WeakMap,s=new n.IUQ;return{update:function(a,r,o){const g=a.morphTargetInfluences,c=r.morphAttributes.position||r.morphAttributes.normal||r.morphAttributes.color,l=void 0!==c?c.length:0;let I=i.get(r);if(void 0===I||I.count!==l){void 0!==I&&I.texture.dispose();const h=void 0!==r.morphAttributes.position,u=void 0!==r.morphAttributes.normal,B=void 0!==r.morphAttributes.color,d=r.morphAttributes.position||[],C=r.morphAttributes.normal||[],E=r.morphAttributes.color||[];let Q=0;!0===h&&(Q=1),!0===u&&(Q=2),!0===B&&(Q=3);let p=r.attributes.position.count*Q,f=1;p>A.maxTextureSize&&(f=Math.ceil(p/A.maxTextureSize),p=A.maxTextureSize);const m=new Float32Array(p*f*4*l),y=new n.rFo(m,p,f,l);y.type=n.RQf,y.needsUpdate=!0;const w=4*Q;for(let S=0;S<l;S++){const D=d[S],v=C[S],M=E[S],b=p*f*4*S;for(let _=0;_<D.count;_++){const R=_*w;!0===h&&(s.fromBufferAttribute(D,_),m[b+R+0]=s.x,m[b+R+1]=s.y,m[b+R+2]=s.z,m[b+R+3]=0),!0===u&&(s.fromBufferAttribute(v,_),m[b+R+4]=s.x,m[b+R+5]=s.y,m[b+R+6]=s.z,m[b+R+7]=0),!0===B&&(s.fromBufferAttribute(M,_),m[b+R+8]=s.x,m[b+R+9]=s.y,m[b+R+10]=s.z,m[b+R+11]=4===M.itemSize?s.w:1)}}function x(){y.dispose(),i.delete(r),r.removeEventListener("dispose",x)}I={count:l,texture:y,size:new n.I9Y(p,f)},i.set(r,I),r.addEventListener("dispose",x)}if(!0===a.isInstancedMesh&&null!==a.morphTexture)o.getUniforms().setValue(t,"morphTexture",a.morphTexture,e);else{let F=0;for(let k=0;k<g.length;k++)F+=g[k];const N=r.morphTargetsRelative?1:1-F;o.getUniforms().setValue(t,"morphTargetBaseInfluence",N),o.getUniforms().setValue(t,"morphTargetInfluences",g)}o.getUniforms().setValue(t,"morphTargetsTexture",I.texture,e),o.getUniforms().setValue(t,"morphTargetsTextureSize",I.size)}}}function H(t,A,e,n){let i=new WeakMap;function s(t){const A=t.target;A.removeEventListener("dispose",s),e.remove(A.instanceMatrix),null!==A.instanceColor&&e.remove(A.instanceColor)}return{update:function(a){const r=n.render.frame,o=a.geometry,g=A.get(a,o);if(i.get(g)!==r&&(A.update(g),i.set(g,r)),a.isInstancedMesh&&(!1===a.hasEventListener("dispose",s)&&a.addEventListener("dispose",s),i.get(a)!==r&&(e.update(a.instanceMatrix,t.ARRAY_BUFFER),null!==a.instanceColor&&e.update(a.instanceColor,t.ARRAY_BUFFER),i.set(a,r))),a.isSkinnedMesh){const t=a.skeleton;i.get(t)!==r&&(t.update(),i.set(t,r))}return g},dispose:function(){i=new WeakMap}}}const Y=new n.gPd,P=new n.VCu(1,1),J=new n.rFo,q=new n.dYF,z=new n.b4q,O=[],K=[],V=new Float32Array(16),W=new Float32Array(9),j=new Float32Array(4);function Z(t,A,e){const n=t[0];if(n<=0||n>0)return t;const i=A*e;let s=O[i];if(void 0===s&&(s=new Float32Array(i),O[i]=s),0!==A){n.toArray(s,0);for(let n=1,i=0;n!==A;++n)i+=e,t[n].toArray(s,i)}return s}function X(t,A){if(t.length!==A.length)return!1;for(let e=0,n=t.length;e<n;e++)if(t[e]!==A[e])return!1;return!0}function $(t,A){for(let e=0,n=A.length;e<n;e++)t[e]=A[e]}function tt(t,A){let e=K[A];void 0===e&&(e=new Int32Array(A),K[A]=e);for(let n=0;n!==A;++n)e[n]=t.allocateTextureUnit();return e}function At(t,A){const e=this.cache;e[0]!==A&&(t.uniform1f(this.addr,A),e[0]=A)}function et(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y||(t.uniform2f(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(X(e,A))return;t.uniform2fv(this.addr,A),$(e,A)}}function nt(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y&&e[2]===A.z||(t.uniform3f(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else if(void 0!==A.r)e[0]===A.r&&e[1]===A.g&&e[2]===A.b||(t.uniform3f(this.addr,A.r,A.g,A.b),e[0]=A.r,e[1]=A.g,e[2]=A.b);else{if(X(e,A))return;t.uniform3fv(this.addr,A),$(e,A)}}function it(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y&&e[2]===A.z&&e[3]===A.w||(t.uniform4f(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(X(e,A))return;t.uniform4fv(this.addr,A),$(e,A)}}function st(t,A){const e=this.cache,n=A.elements;if(void 0===n){if(X(e,A))return;t.uniformMatrix2fv(this.addr,!1,A),$(e,A)}else{if(X(e,n))return;j.set(n),t.uniformMatrix2fv(this.addr,!1,j),$(e,n)}}function at(t,A){const e=this.cache,n=A.elements;if(void 0===n){if(X(e,A))return;t.uniformMatrix3fv(this.addr,!1,A),$(e,A)}else{if(X(e,n))return;W.set(n),t.uniformMatrix3fv(this.addr,!1,W),$(e,n)}}function rt(t,A){const e=this.cache,n=A.elements;if(void 0===n){if(X(e,A))return;t.uniformMatrix4fv(this.addr,!1,A),$(e,A)}else{if(X(e,n))return;V.set(n),t.uniformMatrix4fv(this.addr,!1,V),$(e,n)}}function ot(t,A){const e=this.cache;e[0]!==A&&(t.uniform1i(this.addr,A),e[0]=A)}function gt(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y||(t.uniform2i(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(X(e,A))return;t.uniform2iv(this.addr,A),$(e,A)}}function ct(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y&&e[2]===A.z||(t.uniform3i(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else{if(X(e,A))return;t.uniform3iv(this.addr,A),$(e,A)}}function lt(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y&&e[2]===A.z&&e[3]===A.w||(t.uniform4i(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(X(e,A))return;t.uniform4iv(this.addr,A),$(e,A)}}function It(t,A){const e=this.cache;e[0]!==A&&(t.uniform1ui(this.addr,A),e[0]=A)}function ht(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y||(t.uniform2ui(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(X(e,A))return;t.uniform2uiv(this.addr,A),$(e,A)}}function ut(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y&&e[2]===A.z||(t.uniform3ui(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else{if(X(e,A))return;t.uniform3uiv(this.addr,A),$(e,A)}}function Bt(t,A){const e=this.cache;if(void 0!==A.x)e[0]===A.x&&e[1]===A.y&&e[2]===A.z&&e[3]===A.w||(t.uniform4ui(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(X(e,A))return;t.uniform4uiv(this.addr,A),$(e,A)}}function dt(t,A,e){const i=this.cache,s=e.allocateTextureUnit();let a;i[0]!==s&&(t.uniform1i(this.addr,s),i[0]=s),this.type===t.SAMPLER_2D_SHADOW?(P.compareFunction=n.TiK,a=P):a=Y,e.setTexture2D(A||a,s)}function Ct(t,A,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(t.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(A||q,i)}function Et(t,A,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(t.uniform1i(this.addr,i),n[0]=i),e.setTextureCube(A||z,i)}function Qt(t,A,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(t.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(A||J,i)}function pt(t,A){t.uniform1fv(this.addr,A)}function ft(t,A){const e=Z(A,this.size,2);t.uniform2fv(this.addr,e)}function mt(t,A){const e=Z(A,this.size,3);t.uniform3fv(this.addr,e)}function yt(t,A){const e=Z(A,this.size,4);t.uniform4fv(this.addr,e)}function wt(t,A){const e=Z(A,this.size,4);t.uniformMatrix2fv(this.addr,!1,e)}function xt(t,A){const e=Z(A,this.size,9);t.uniformMatrix3fv(this.addr,!1,e)}function St(t,A){const e=Z(A,this.size,16);t.uniformMatrix4fv(this.addr,!1,e)}function Dt(t,A){t.uniform1iv(this.addr,A)}function vt(t,A){t.uniform2iv(this.addr,A)}function Mt(t,A){t.uniform3iv(this.addr,A)}function bt(t,A){t.uniform4iv(this.addr,A)}function _t(t,A){t.uniform1uiv(this.addr,A)}function Rt(t,A){t.uniform2uiv(this.addr,A)}function Ft(t,A){t.uniform3uiv(this.addr,A)}function Nt(t,A){t.uniform4uiv(this.addr,A)}function kt(t,A,e){const n=this.cache,i=A.length,s=tt(e,i);X(n,s)||(t.uniform1iv(this.addr,s),$(n,s));for(let t=0;t!==i;++t)e.setTexture2D(A[t]||Y,s[t])}function Tt(t,A,e){const n=this.cache,i=A.length,s=tt(e,i);X(n,s)||(t.uniform1iv(this.addr,s),$(n,s));for(let t=0;t!==i;++t)e.setTexture3D(A[t]||q,s[t])}function Gt(t,A,e){const n=this.cache,i=A.length,s=tt(e,i);X(n,s)||(t.uniform1iv(this.addr,s),$(n,s));for(let t=0;t!==i;++t)e.setTextureCube(A[t]||z,s[t])}function Ut(t,A,e){const n=this.cache,i=A.length,s=tt(e,i);X(n,s)||(t.uniform1iv(this.addr,s),$(n,s));for(let t=0;t!==i;++t)e.setTexture2DArray(A[t]||J,s[t])}class Lt{constructor(t,A,e){this.id=t,this.addr=e,this.cache=[],this.type=A.type,this.setValue=function(t){switch(t){case 5126:return At;case 35664:return et;case 35665:return nt;case 35666:return it;case 35674:return st;case 35675:return at;case 35676:return rt;case 5124:case 35670:return ot;case 35667:case 35671:return gt;case 35668:case 35672:return ct;case 35669:case 35673:return lt;case 5125:return It;case 36294:return ht;case 36295:return ut;case 36296:return Bt;case 35678:case 36198:case 36298:case 36306:case 35682:return dt;case 35679:case 36299:case 36307:return Ct;case 35680:case 36300:case 36308:case 36293:return Et;case 36289:case 36303:case 36311:case 36292:return Qt}}(A.type)}}class Ht{constructor(t,A,e){this.id=t,this.addr=e,this.cache=[],this.type=A.type,this.size=A.size,this.setValue=function(t){switch(t){case 5126:return pt;case 35664:return ft;case 35665:return mt;case 35666:return yt;case 35674:return wt;case 35675:return xt;case 35676:return St;case 5124:case 35670:return Dt;case 35667:case 35671:return vt;case 35668:case 35672:return Mt;case 35669:case 35673:return bt;case 5125:return _t;case 36294:return Rt;case 36295:return Ft;case 36296:return Nt;case 35678:case 36198:case 36298:case 36306:case 35682:return kt;case 35679:case 36299:case 36307:return Tt;case 35680:case 36300:case 36308:case 36293:return Gt;case 36289:case 36303:case 36311:case 36292:return Ut}}(A.type)}}class Yt{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,A,e){const n=this.seq;for(let i=0,s=n.length;i!==s;++i){const s=n[i];s.setValue(t,A[s.id],e)}}}const Pt=/(\w+)(\])?(\[|\.)?/g;function Jt(t,A){t.seq.push(A),t.map[A.id]=A}function qt(t,A,e){const n=t.name,i=n.length;for(Pt.lastIndex=0;;){const s=Pt.exec(n),a=Pt.lastIndex;let r=s[1];const o="]"===s[2],g=s[3];if(o&&(r|=0),void 0===g||"["===g&&a+2===i){Jt(e,void 0===g?new Lt(r,t,A):new Ht(r,t,A));break}{let t=e.map[r];void 0===t&&(t=new Yt(r),Jt(e,t)),e=t}}}class zt{constructor(t,A){this.seq=[],this.map={};const e=t.getProgramParameter(A,t.ACTIVE_UNIFORMS);for(let n=0;n<e;++n){const e=t.getActiveUniform(A,n);qt(e,t.getUniformLocation(A,e.name),this)}}setValue(t,A,e,n){const i=this.map[A];void 0!==i&&i.setValue(t,e,n)}setOptional(t,A,e){const n=A[e];void 0!==n&&this.setValue(t,e,n)}static upload(t,A,e,n){for(let i=0,s=A.length;i!==s;++i){const s=A[i],a=e[s.id];!1!==a.needsUpdate&&s.setValue(t,a.value,n)}}static seqWithValue(t,A){const e=[];for(let n=0,i=t.length;n!==i;++n){const i=t[n];i.id in A&&e.push(i)}return e}}function Ot(t,A,e){const n=t.createShader(A);return t.shaderSource(n,e),t.compileShader(n),n}let Kt=0;const Vt=new n.dwI;function Wt(t,A,e){const n=t.getShaderParameter(A,t.COMPILE_STATUS),i=t.getShaderInfoLog(A).trim();if(n&&""===i)return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const n=parseInt(s[1]);return e.toUpperCase()+"\n\n"+i+"\n\n"+function(t,A){const e=t.split("\n"),n=[],i=Math.max(A-6,0),s=Math.min(A+6,e.length);for(let t=i;t<s;t++){const i=t+1;n.push(`${i===A?">":" "} ${i}: ${e[t]}`)}return n.join("\n")}(t.getShaderSource(A),n)}return i}function jt(t,A){const e=function(t){n.ppV._getMatrix(Vt,n.ppV.workingColorSpace,t);const A=`mat3( ${Vt.elements.map(t=>t.toFixed(4))} )`;switch(n.ppV.getTransfer(t)){case n.VxR:return[A,"LinearTransferOETF"];case n.KLL:return[A,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",t),[A,"LinearTransferOETF"]}}(A);return[`vec4 ${t}( vec4 value ) {`,`\treturn ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,"}"].join("\n")}function Zt(t,A){let e;switch(A){case n.kyO:e="Linear";break;case n.Mjd:e="Reinhard";break;case n.nNL:e="Cineon";break;case n.FV:e="ACESFilmic";break;case n.LAk:e="AgX";break;case n.aJ8:e="Neutral";break;case n.g7M:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",A),e="Linear"}return"vec3 "+t+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}const Xt=new n.Pq0;function $t(t){return""!==t}function tA(t,A){const e=A.numSpotLightShadows+A.numSpotLightMaps-A.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,A.numDirLights).replace(/NUM_SPOT_LIGHTS/g,A.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,A.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,A.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,A.numPointLights).replace(/NUM_HEMI_LIGHTS/g,A.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,A.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,A.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,A.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,A.numPointLightShadows)}function AA(t,A){return t.replace(/NUM_CLIPPING_PLANES/g,A.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,A.numClippingPlanes-A.numClipIntersection)}const eA=/^[ \t]*#include +<([\w\d./]+)>/gm;function nA(t){return t.replace(eA,sA)}const iA=new Map;function sA(t,A){let e=a[A];if(void 0===e){const t=iA.get(A);if(void 0===t)throw new Error("Can not resolve #include <"+A+">");e=a[t],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',A,t)}return nA(e)}const aA=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function rA(t){return t.replace(aA,oA)}function oA(t,A,e,n){let i="";for(let t=parseInt(A);t<parseInt(e);t++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return i}function gA(t){let A=`precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;return"highp"===t.precision?A+="\n#define HIGH_PRECISION":"mediump"===t.precision?A+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(A+="\n#define LOW_PRECISION"),A}function cA(t,A,e,i){const s=t.getContext(),r=e.defines;let o=e.vertexShader,g=e.fragmentShader;const c=function(t){let A="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===n.QP0?A="SHADOWMAP_TYPE_PCF":t.shadowMapType===n.Wk7?A="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===n.RyA&&(A="SHADOWMAP_TYPE_VSM"),A}(e),l=function(t){let A="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case n.hy7:case n.xFO:A="ENVMAP_TYPE_CUBE";break;case n.Om:A="ENVMAP_TYPE_CUBE_UV"}return A}(e),I=function(t){let A="ENVMAP_MODE_REFLECTION";return t.envMap&&t.envMapMode===n.xFO&&(A="ENVMAP_MODE_REFRACTION"),A}(e),h=function(t){let A="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case n.caT:A="ENVMAP_BLENDING_MULTIPLY";break;case n.KRh:A="ENVMAP_BLENDING_MIX";break;case n.XrR:A="ENVMAP_BLENDING_ADD"}return A}(e),u=function(t){const A=t.envMapCubeUVHeight;if(null===A)return null;const e=Math.log2(A)-2,n=1/A;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:n,maxMip:e}}(e),B=function(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",t.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter($t).join("\n")}(e),d=function(t){const A=[];for(const e in t){const n=t[e];!1!==n&&A.push("#define "+e+" "+n)}return A.join("\n")}(r),C=s.createProgram();let E,Q,p=e.glslVersion?"#version "+e.glslVersion+"\n":"";e.isRawShaderMaterial?(E=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,d].filter($t).join("\n"),E.length>0&&(E+="\n"),Q=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,d].filter($t).join("\n"),Q.length>0&&(Q+="\n")):(E=[gA(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,d,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.batchingColor?"#define USE_BATCHING_COLOR":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+I:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&!1===e.flatShading?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&!1===e.flatShading?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter($t).join("\n"),Q=[gA(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,d,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+l:"",e.envMap?"#define "+I:"",e.envMap?"#define "+h:"",u?"#define CUBEUV_TEXEL_WIDTH "+u.texelWidth:"",u?"#define CUBEUV_TEXEL_HEIGHT "+u.texelHeight:"",u?"#define CUBEUV_MAX_MIP "+u.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&!1===e.flatShading?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor||e.batchingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==n.y_p?"#define TONE_MAPPING":"",e.toneMapping!==n.y_p?a.tonemapping_pars_fragment:"",e.toneMapping!==n.y_p?Zt("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",a.colorspace_pars_fragment,jt("linearToOutputTexel",e.outputColorSpace),(n.ppV.getLuminanceCoefficients(Xt),["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${Xt.x.toFixed(4)}, ${Xt.y.toFixed(4)}, ${Xt.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join("\n")),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"","\n"].filter($t).join("\n")),o=nA(o),o=tA(o,e),o=AA(o,e),g=nA(g),g=tA(g,e),g=AA(g,e),o=rA(o),g=rA(g),!0!==e.isRawShaderMaterial&&(p="#version 300 es\n",E=[B,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+E,Q=["#define varying in",e.glslVersion===n.Wdf?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===n.Wdf?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+Q);const f=p+E+o,m=p+Q+g,y=Ot(s,s.VERTEX_SHADER,f),w=Ot(s,s.FRAGMENT_SHADER,m);function x(A){if(t.debug.checkShaderErrors){const e=s.getProgramInfoLog(C).trim(),n=s.getShaderInfoLog(y).trim(),i=s.getShaderInfoLog(w).trim();let a=!0,r=!0;if(!1===s.getProgramParameter(C,s.LINK_STATUS))if(a=!1,"function"==typeof t.debug.onShaderError)t.debug.onShaderError(s,C,y,w);else{const t=Wt(s,y,"vertex"),n=Wt(s,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(C,s.VALIDATE_STATUS)+"\n\nMaterial Name: "+A.name+"\nMaterial Type: "+A.type+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+n)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):""!==n&&""!==i||(r=!1);r&&(A.diagnostics={runnable:a,programLog:e,vertexShader:{log:n,prefix:E},fragmentShader:{log:i,prefix:Q}})}s.deleteShader(y),s.deleteShader(w),S=new zt(s,C),D=function(t,A){const e={},n=t.getProgramParameter(A,t.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const n=t.getActiveAttrib(A,i),s=n.name;let a=1;n.type===t.FLOAT_MAT2&&(a=2),n.type===t.FLOAT_MAT3&&(a=3),n.type===t.FLOAT_MAT4&&(a=4),e[s]={type:n.type,location:t.getAttribLocation(A,s),locationSize:a}}return e}(s,C)}let S,D;s.attachShader(C,y),s.attachShader(C,w),void 0!==e.index0AttributeName?s.bindAttribLocation(C,0,e.index0AttributeName):!0===e.morphTargets&&s.bindAttribLocation(C,0,"position"),s.linkProgram(C),this.getUniforms=function(){return void 0===S&&x(this),S},this.getAttributes=function(){return void 0===D&&x(this),D};let v=!1===e.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===v&&(v=s.getProgramParameter(C,37297)),v},this.destroy=function(){i.releaseStatesOfProgram(this),s.deleteProgram(C),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=Kt++,this.cacheKey=A,this.usedTimes=1,this.program=C,this.vertexShader=y,this.fragmentShader=w,this}let lA=0;class IA{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const A=t.vertexShader,e=t.fragmentShader,n=this._getShaderStage(A),i=this._getShaderStage(e),s=this._getShaderCacheForMaterial(t);return!1===s.has(n)&&(s.add(n),n.usedTimes++),!1===s.has(i)&&(s.add(i),i.usedTimes++),this}remove(t){const A=this.materialCache.get(t);for(const t of A)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const A=this.materialCache;let e=A.get(t);return void 0===e&&(e=new Set,A.set(t,e)),e}_getShaderStage(t){const A=this.shaderCache;let e=A.get(t);return void 0===e&&(e=new hA(t),A.set(t,e)),e}}class hA{constructor(t){this.id=lA++,this.code=t,this.usedTimes=0}}function uA(t,A,e,i,s,a,r){const g=new n.zgK,c=new IA,l=new Set,I=[],h=s.logarithmicDepthBuffer,u=s.vertexTextures;let B=s.precision;const d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function C(t){return l.add(t),0===t?"uv":`uv${t}`}return{getParameters:function(a,g,I,E,Q){const p=E.fog,f=Q.geometry,m=a.isMeshStandardMaterial?E.environment:null,y=(a.isMeshStandardMaterial?e:A).get(a.envMap||m),w=y&&y.mapping===n.Om?y.image.height:null,x=d[a.type];null!==a.precision&&(B=s.getMaxPrecision(a.precision),B!==a.precision&&console.warn("THREE.WebGLProgram.getParameters:",a.precision,"not supported, using",B,"instead."));const S=f.morphAttributes.position||f.morphAttributes.normal||f.morphAttributes.color,D=void 0!==S?S.length:0;let v,M,b,_,R=0;if(void 0!==f.morphAttributes.position&&(R=1),void 0!==f.morphAttributes.normal&&(R=2),void 0!==f.morphAttributes.color&&(R=3),x){const t=o[x];v=t.vertexShader,M=t.fragmentShader}else v=a.vertexShader,M=a.fragmentShader,c.update(a),b=c.getVertexShaderID(a),_=c.getFragmentShaderID(a);const F=t.getRenderTarget(),N=t.state.buffers.depth.getReversed(),k=!0===Q.isInstancedMesh,T=!0===Q.isBatchedMesh,G=!!a.map,U=!!a.matcap,L=!!y,H=!!a.aoMap,Y=!!a.lightMap,P=!!a.bumpMap,J=!!a.normalMap,q=!!a.displacementMap,z=!!a.emissiveMap,O=!!a.metalnessMap,K=!!a.roughnessMap,V=a.anisotropy>0,W=a.clearcoat>0,j=a.dispersion>0,Z=a.iridescence>0,X=a.sheen>0,$=a.transmission>0,tt=V&&!!a.anisotropyMap,At=W&&!!a.clearcoatMap,et=W&&!!a.clearcoatNormalMap,nt=W&&!!a.clearcoatRoughnessMap,it=Z&&!!a.iridescenceMap,st=Z&&!!a.iridescenceThicknessMap,at=X&&!!a.sheenColorMap,rt=X&&!!a.sheenRoughnessMap,ot=!!a.specularMap,gt=!!a.specularColorMap,ct=!!a.specularIntensityMap,lt=$&&!!a.transmissionMap,It=$&&!!a.thicknessMap,ht=!!a.gradientMap,ut=!!a.alphaMap,Bt=a.alphaTest>0,dt=!!a.alphaHash,Ct=!!a.extensions;let Et=n.y_p;a.toneMapped&&(null!==F&&!0!==F.isXRRenderTarget||(Et=t.toneMapping));const Qt={shaderID:x,shaderType:a.type,shaderName:a.name,vertexShader:v,fragmentShader:M,defines:a.defines,customVertexShaderID:b,customFragmentShaderID:_,isRawShaderMaterial:!0===a.isRawShaderMaterial,glslVersion:a.glslVersion,precision:B,batching:T,batchingColor:T&&null!==Q._colorsTexture,instancing:k,instancingColor:k&&null!==Q.instanceColor,instancingMorph:k&&null!==Q.morphTexture,supportsVertexTextures:u,outputColorSpace:null===F?t.outputColorSpace:!0===F.isXRRenderTarget?F.texture.colorSpace:n.Zr2,alphaToCoverage:!!a.alphaToCoverage,map:G,matcap:U,envMap:L,envMapMode:L&&y.mapping,envMapCubeUVHeight:w,aoMap:H,lightMap:Y,bumpMap:P,normalMap:J,displacementMap:u&&q,emissiveMap:z,normalMapObjectSpace:J&&a.normalMapType===n.vyJ,normalMapTangentSpace:J&&a.normalMapType===n.bI3,metalnessMap:O,roughnessMap:K,anisotropy:V,anisotropyMap:tt,clearcoat:W,clearcoatMap:At,clearcoatNormalMap:et,clearcoatRoughnessMap:nt,dispersion:j,iridescence:Z,iridescenceMap:it,iridescenceThicknessMap:st,sheen:X,sheenColorMap:at,sheenRoughnessMap:rt,specularMap:ot,specularColorMap:gt,specularIntensityMap:ct,transmission:$,transmissionMap:lt,thicknessMap:It,gradientMap:ht,opaque:!1===a.transparent&&a.blending===n.NTi&&!1===a.alphaToCoverage,alphaMap:ut,alphaTest:Bt,alphaHash:dt,combine:a.combine,mapUv:G&&C(a.map.channel),aoMapUv:H&&C(a.aoMap.channel),lightMapUv:Y&&C(a.lightMap.channel),bumpMapUv:P&&C(a.bumpMap.channel),normalMapUv:J&&C(a.normalMap.channel),displacementMapUv:q&&C(a.displacementMap.channel),emissiveMapUv:z&&C(a.emissiveMap.channel),metalnessMapUv:O&&C(a.metalnessMap.channel),roughnessMapUv:K&&C(a.roughnessMap.channel),anisotropyMapUv:tt&&C(a.anisotropyMap.channel),clearcoatMapUv:At&&C(a.clearcoatMap.channel),clearcoatNormalMapUv:et&&C(a.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:nt&&C(a.clearcoatRoughnessMap.channel),iridescenceMapUv:it&&C(a.iridescenceMap.channel),iridescenceThicknessMapUv:st&&C(a.iridescenceThicknessMap.channel),sheenColorMapUv:at&&C(a.sheenColorMap.channel),sheenRoughnessMapUv:rt&&C(a.sheenRoughnessMap.channel),specularMapUv:ot&&C(a.specularMap.channel),specularColorMapUv:gt&&C(a.specularColorMap.channel),specularIntensityMapUv:ct&&C(a.specularIntensityMap.channel),transmissionMapUv:lt&&C(a.transmissionMap.channel),thicknessMapUv:It&&C(a.thicknessMap.channel),alphaMapUv:ut&&C(a.alphaMap.channel),vertexTangents:!!f.attributes.tangent&&(J||V),vertexColors:a.vertexColors,vertexAlphas:!0===a.vertexColors&&!!f.attributes.color&&4===f.attributes.color.itemSize,pointsUvs:!0===Q.isPoints&&!!f.attributes.uv&&(G||ut),fog:!!p,useFog:!0===a.fog,fogExp2:!!p&&p.isFogExp2,flatShading:!0===a.flatShading&&!1===a.wireframe,sizeAttenuation:!0===a.sizeAttenuation,logarithmicDepthBuffer:h,reverseDepthBuffer:N,skinning:!0===Q.isSkinnedMesh,morphTargets:void 0!==f.morphAttributes.position,morphNormals:void 0!==f.morphAttributes.normal,morphColors:void 0!==f.morphAttributes.color,morphTargetsCount:D,morphTextureStride:R,numDirLights:g.directional.length,numPointLights:g.point.length,numSpotLights:g.spot.length,numSpotLightMaps:g.spotLightMap.length,numRectAreaLights:g.rectArea.length,numHemiLights:g.hemi.length,numDirLightShadows:g.directionalShadowMap.length,numPointLightShadows:g.pointShadowMap.length,numSpotLightShadows:g.spotShadowMap.length,numSpotLightShadowsWithMaps:g.numSpotLightShadowsWithMaps,numLightProbes:g.numLightProbes,numClippingPlanes:r.numPlanes,numClipIntersection:r.numIntersection,dithering:a.dithering,shadowMapEnabled:t.shadowMap.enabled&&I.length>0,shadowMapType:t.shadowMap.type,toneMapping:Et,decodeVideoTexture:G&&!0===a.map.isVideoTexture&&n.ppV.getTransfer(a.map.colorSpace)===n.KLL,decodeVideoTextureEmissive:z&&!0===a.emissiveMap.isVideoTexture&&n.ppV.getTransfer(a.emissiveMap.colorSpace)===n.KLL,premultipliedAlpha:a.premultipliedAlpha,doubleSided:a.side===n.$EB,flipSided:a.side===n.hsX,useDepthPacking:a.depthPacking>=0,depthPacking:a.depthPacking||0,index0AttributeName:a.index0AttributeName,extensionClipCullDistance:Ct&&!0===a.extensions.clipCullDistance&&i.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Ct&&!0===a.extensions.multiDraw||T)&&i.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:i.has("KHR_parallel_shader_compile"),customProgramCacheKey:a.customProgramCacheKey()};return Qt.vertexUv1s=l.has(1),Qt.vertexUv2s=l.has(2),Qt.vertexUv3s=l.has(3),l.clear(),Qt},getProgramCacheKey:function(A){const e=[];if(A.shaderID?e.push(A.shaderID):(e.push(A.customVertexShaderID),e.push(A.customFragmentShaderID)),void 0!==A.defines)for(const t in A.defines)e.push(t),e.push(A.defines[t]);return!1===A.isRawShaderMaterial&&(function(t,A){t.push(A.precision),t.push(A.outputColorSpace),t.push(A.envMapMode),t.push(A.envMapCubeUVHeight),t.push(A.mapUv),t.push(A.alphaMapUv),t.push(A.lightMapUv),t.push(A.aoMapUv),t.push(A.bumpMapUv),t.push(A.normalMapUv),t.push(A.displacementMapUv),t.push(A.emissiveMapUv),t.push(A.metalnessMapUv),t.push(A.roughnessMapUv),t.push(A.anisotropyMapUv),t.push(A.clearcoatMapUv),t.push(A.clearcoatNormalMapUv),t.push(A.clearcoatRoughnessMapUv),t.push(A.iridescenceMapUv),t.push(A.iridescenceThicknessMapUv),t.push(A.sheenColorMapUv),t.push(A.sheenRoughnessMapUv),t.push(A.specularMapUv),t.push(A.specularColorMapUv),t.push(A.specularIntensityMapUv),t.push(A.transmissionMapUv),t.push(A.thicknessMapUv),t.push(A.combine),t.push(A.fogExp2),t.push(A.sizeAttenuation),t.push(A.morphTargetsCount),t.push(A.morphAttributeCount),t.push(A.numDirLights),t.push(A.numPointLights),t.push(A.numSpotLights),t.push(A.numSpotLightMaps),t.push(A.numHemiLights),t.push(A.numRectAreaLights),t.push(A.numDirLightShadows),t.push(A.numPointLightShadows),t.push(A.numSpotLightShadows),t.push(A.numSpotLightShadowsWithMaps),t.push(A.numLightProbes),t.push(A.shadowMapType),t.push(A.toneMapping),t.push(A.numClippingPlanes),t.push(A.numClipIntersection),t.push(A.depthPacking)}(e,A),function(t,A){g.disableAll(),A.supportsVertexTextures&&g.enable(0),A.instancing&&g.enable(1),A.instancingColor&&g.enable(2),A.instancingMorph&&g.enable(3),A.matcap&&g.enable(4),A.envMap&&g.enable(5),A.normalMapObjectSpace&&g.enable(6),A.normalMapTangentSpace&&g.enable(7),A.clearcoat&&g.enable(8),A.iridescence&&g.enable(9),A.alphaTest&&g.enable(10),A.vertexColors&&g.enable(11),A.vertexAlphas&&g.enable(12),A.vertexUv1s&&g.enable(13),A.vertexUv2s&&g.enable(14),A.vertexUv3s&&g.enable(15),A.vertexTangents&&g.enable(16),A.anisotropy&&g.enable(17),A.alphaHash&&g.enable(18),A.batching&&g.enable(19),A.dispersion&&g.enable(20),A.batchingColor&&g.enable(21),A.gradientMap&&g.enable(22),t.push(g.mask),g.disableAll(),A.fog&&g.enable(0),A.useFog&&g.enable(1),A.flatShading&&g.enable(2),A.logarithmicDepthBuffer&&g.enable(3),A.reverseDepthBuffer&&g.enable(4),A.skinning&&g.enable(5),A.morphTargets&&g.enable(6),A.morphNormals&&g.enable(7),A.morphColors&&g.enable(8),A.premultipliedAlpha&&g.enable(9),A.shadowMapEnabled&&g.enable(10),A.doubleSided&&g.enable(11),A.flipSided&&g.enable(12),A.useDepthPacking&&g.enable(13),A.dithering&&g.enable(14),A.transmission&&g.enable(15),A.sheen&&g.enable(16),A.opaque&&g.enable(17),A.pointsUvs&&g.enable(18),A.decodeVideoTexture&&g.enable(19),A.decodeVideoTextureEmissive&&g.enable(20),A.alphaToCoverage&&g.enable(21),t.push(g.mask)}(e,A),e.push(t.outputColorSpace)),e.push(A.customProgramCacheKey),e.join()},getUniforms:function(t){const A=d[t.type];let e;if(A){const t=o[A];e=n.LlO.clone(t.uniforms)}else e=t.uniforms;return e},acquireProgram:function(A,e){let n;for(let t=0,A=I.length;t<A;t++){const A=I[t];if(A.cacheKey===e){n=A,++n.usedTimes;break}}return void 0===n&&(n=new cA(t,e,A,a),I.push(n)),n},releaseProgram:function(t){if(0===--t.usedTimes){const A=I.indexOf(t);I[A]=I[I.length-1],I.pop(),t.destroy()}},releaseShaderCache:function(t){c.remove(t)},programs:I,dispose:function(){c.dispose()}}}function BA(){let t=new WeakMap;return{has:function(A){return t.has(A)},get:function(A){let e=t.get(A);return void 0===e&&(e={},t.set(A,e)),e},remove:function(A){t.delete(A)},update:function(A,e,n){t.get(A)[e]=n},dispose:function(){t=new WeakMap}}}function dA(t,A){return t.groupOrder!==A.groupOrder?t.groupOrder-A.groupOrder:t.renderOrder!==A.renderOrder?t.renderOrder-A.renderOrder:t.material.id!==A.material.id?t.material.id-A.material.id:t.z!==A.z?t.z-A.z:t.id-A.id}function CA(t,A){return t.groupOrder!==A.groupOrder?t.groupOrder-A.groupOrder:t.renderOrder!==A.renderOrder?t.renderOrder-A.renderOrder:t.z!==A.z?A.z-t.z:t.id-A.id}function EA(){const t=[];let A=0;const e=[],n=[],i=[];function s(e,n,i,s,a,r){let o=t[A];return void 0===o?(o={id:e.id,object:e,geometry:n,material:i,groupOrder:s,renderOrder:e.renderOrder,z:a,group:r},t[A]=o):(o.id=e.id,o.object=e,o.geometry=n,o.material=i,o.groupOrder=s,o.renderOrder=e.renderOrder,o.z=a,o.group=r),A++,o}return{opaque:e,transmissive:n,transparent:i,init:function(){A=0,e.length=0,n.length=0,i.length=0},push:function(t,A,a,r,o,g){const c=s(t,A,a,r,o,g);a.transmission>0?n.push(c):!0===a.transparent?i.push(c):e.push(c)},unshift:function(t,A,a,r,o,g){const c=s(t,A,a,r,o,g);a.transmission>0?n.unshift(c):!0===a.transparent?i.unshift(c):e.unshift(c)},finish:function(){for(let e=A,n=t.length;e<n;e++){const A=t[e];if(null===A.id)break;A.id=null,A.object=null,A.geometry=null,A.material=null,A.group=null}},sort:function(t,A){e.length>1&&e.sort(t||dA),n.length>1&&n.sort(A||CA),i.length>1&&i.sort(A||CA)}}}function QA(){let t=new WeakMap;return{get:function(A,e){const n=t.get(A);let i;return void 0===n?(i=new EA,t.set(A,[i])):e>=n.length?(i=new EA,n.push(i)):i=n[e],i},dispose:function(){t=new WeakMap}}}function pA(){const t={};return{get:function(A){if(void 0!==t[A.id])return t[A.id];let e;switch(A.type){case"DirectionalLight":e={direction:new n.Pq0,color:new n.Q1f};break;case"SpotLight":e={position:new n.Pq0,direction:new n.Pq0,color:new n.Q1f,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new n.Pq0,color:new n.Q1f,distance:0,decay:0};break;case"HemisphereLight":e={direction:new n.Pq0,skyColor:new n.Q1f,groundColor:new n.Q1f};break;case"RectAreaLight":e={color:new n.Q1f,position:new n.Pq0,halfWidth:new n.Pq0,halfHeight:new n.Pq0}}return t[A.id]=e,e}}}let fA=0;function mA(t,A){return(A.castShadow?2:0)-(t.castShadow?2:0)+(A.map?1:0)-(t.map?1:0)}function yA(t){const A=new pA,e=function(){const t={};return{get:function(A){if(void 0!==t[A.id])return t[A.id];let e;switch(A.type){case"DirectionalLight":case"SpotLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new n.I9Y};break;case"PointLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new n.I9Y,shadowCameraNear:1,shadowCameraFar:1e3}}return t[A.id]=e,e}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let t=0;t<9;t++)i.probe.push(new n.Pq0);const s=new n.Pq0,a=new n.kn4,o=new n.kn4;return{setup:function(n){let s=0,a=0,o=0;for(let t=0;t<9;t++)i.probe[t].set(0,0,0);let g=0,c=0,l=0,I=0,h=0,u=0,B=0,d=0,C=0,E=0,Q=0;n.sort(mA);for(let t=0,r=n.length;t<r;t++){const r=n[t],p=r.color,f=r.intensity,m=r.distance,y=r.shadow&&r.shadow.map?r.shadow.map.texture:null;if(r.isAmbientLight)s+=p.r*f,a+=p.g*f,o+=p.b*f;else if(r.isLightProbe){for(let t=0;t<9;t++)i.probe[t].addScaledVector(r.sh.coefficients[t],f);Q++}else if(r.isDirectionalLight){const t=A.get(r);if(t.color.copy(r.color).multiplyScalar(r.intensity),r.castShadow){const t=r.shadow,A=e.get(r);A.shadowIntensity=t.intensity,A.shadowBias=t.bias,A.shadowNormalBias=t.normalBias,A.shadowRadius=t.radius,A.shadowMapSize=t.mapSize,i.directionalShadow[g]=A,i.directionalShadowMap[g]=y,i.directionalShadowMatrix[g]=r.shadow.matrix,u++}i.directional[g]=t,g++}else if(r.isSpotLight){const t=A.get(r);t.position.setFromMatrixPosition(r.matrixWorld),t.color.copy(p).multiplyScalar(f),t.distance=m,t.coneCos=Math.cos(r.angle),t.penumbraCos=Math.cos(r.angle*(1-r.penumbra)),t.decay=r.decay,i.spot[l]=t;const n=r.shadow;if(r.map&&(i.spotLightMap[C]=r.map,C++,n.updateMatrices(r),r.castShadow&&E++),i.spotLightMatrix[l]=n.matrix,r.castShadow){const t=e.get(r);t.shadowIntensity=n.intensity,t.shadowBias=n.bias,t.shadowNormalBias=n.normalBias,t.shadowRadius=n.radius,t.shadowMapSize=n.mapSize,i.spotShadow[l]=t,i.spotShadowMap[l]=y,d++}l++}else if(r.isRectAreaLight){const t=A.get(r);t.color.copy(p).multiplyScalar(f),t.halfWidth.set(.5*r.width,0,0),t.halfHeight.set(0,.5*r.height,0),i.rectArea[I]=t,I++}else if(r.isPointLight){const t=A.get(r);if(t.color.copy(r.color).multiplyScalar(r.intensity),t.distance=r.distance,t.decay=r.decay,r.castShadow){const t=r.shadow,A=e.get(r);A.shadowIntensity=t.intensity,A.shadowBias=t.bias,A.shadowNormalBias=t.normalBias,A.shadowRadius=t.radius,A.shadowMapSize=t.mapSize,A.shadowCameraNear=t.camera.near,A.shadowCameraFar=t.camera.far,i.pointShadow[c]=A,i.pointShadowMap[c]=y,i.pointShadowMatrix[c]=r.shadow.matrix,B++}i.point[c]=t,c++}else if(r.isHemisphereLight){const t=A.get(r);t.skyColor.copy(r.color).multiplyScalar(f),t.groundColor.copy(r.groundColor).multiplyScalar(f),i.hemi[h]=t,h++}}I>0&&(!0===t.has("OES_texture_float_linear")?(i.rectAreaLTC1=r.LTC_FLOAT_1,i.rectAreaLTC2=r.LTC_FLOAT_2):(i.rectAreaLTC1=r.LTC_HALF_1,i.rectAreaLTC2=r.LTC_HALF_2)),i.ambient[0]=s,i.ambient[1]=a,i.ambient[2]=o;const p=i.hash;p.directionalLength===g&&p.pointLength===c&&p.spotLength===l&&p.rectAreaLength===I&&p.hemiLength===h&&p.numDirectionalShadows===u&&p.numPointShadows===B&&p.numSpotShadows===d&&p.numSpotMaps===C&&p.numLightProbes===Q||(i.directional.length=g,i.spot.length=l,i.rectArea.length=I,i.point.length=c,i.hemi.length=h,i.directionalShadow.length=u,i.directionalShadowMap.length=u,i.pointShadow.length=B,i.pointShadowMap.length=B,i.spotShadow.length=d,i.spotShadowMap.length=d,i.directionalShadowMatrix.length=u,i.pointShadowMatrix.length=B,i.spotLightMatrix.length=d+C-E,i.spotLightMap.length=C,i.numSpotLightShadowsWithMaps=E,i.numLightProbes=Q,p.directionalLength=g,p.pointLength=c,p.spotLength=l,p.rectAreaLength=I,p.hemiLength=h,p.numDirectionalShadows=u,p.numPointShadows=B,p.numSpotShadows=d,p.numSpotMaps=C,p.numLightProbes=Q,i.version=fA++)},setupView:function(t,A){let e=0,n=0,r=0,g=0,c=0;const l=A.matrixWorldInverse;for(let A=0,I=t.length;A<I;A++){const I=t[A];if(I.isDirectionalLight){const t=i.directional[e];t.direction.setFromMatrixPosition(I.matrixWorld),s.setFromMatrixPosition(I.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(l),e++}else if(I.isSpotLight){const t=i.spot[r];t.position.setFromMatrixPosition(I.matrixWorld),t.position.applyMatrix4(l),t.direction.setFromMatrixPosition(I.matrixWorld),s.setFromMatrixPosition(I.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(l),r++}else if(I.isRectAreaLight){const t=i.rectArea[g];t.position.setFromMatrixPosition(I.matrixWorld),t.position.applyMatrix4(l),o.identity(),a.copy(I.matrixWorld),a.premultiply(l),o.extractRotation(a),t.halfWidth.set(.5*I.width,0,0),t.halfHeight.set(0,.5*I.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),g++}else if(I.isPointLight){const t=i.point[n];t.position.setFromMatrixPosition(I.matrixWorld),t.position.applyMatrix4(l),n++}else if(I.isHemisphereLight){const t=i.hemi[c];t.direction.setFromMatrixPosition(I.matrixWorld),t.direction.transformDirection(l),c++}}},state:i}}function wA(t){const A=new yA(t),e=[],n=[],i={lightsArray:e,shadowsArray:n,camera:null,lights:A,transmissionRenderTarget:{}};return{init:function(t){i.camera=t,e.length=0,n.length=0},state:i,setupLights:function(){A.setup(e)},setupLightsView:function(t){A.setupView(e,t)},pushLight:function(t){e.push(t)},pushShadow:function(t){n.push(t)}}}function xA(t){let A=new WeakMap;return{get:function(e,n=0){const i=A.get(e);let s;return void 0===i?(s=new wA(t),A.set(e,[s])):n>=i.length?(s=new wA(t),i.push(s)):s=i[n],s},dispose:function(){A=new WeakMap}}}function SA(t,A,e){let i=new n.PPD;const s=new n.I9Y,a=new n.I9Y,r=new n.IUQ,o=new n.CSG({depthPacking:n.N5j}),g=new n.aVO,c={},l=e.maxTextureSize,I={[n.hB5]:n.hsX,[n.hsX]:n.hB5,[n.$EB]:n.$EB},h=new n.BKk({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new n.I9Y},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),u=h.clone();u.defines.HORIZONTAL_PASS=1;const B=new n.LoY;B.setAttribute("position",new n.THS(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const d=new n.eaF(B,h),C=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=n.QP0;let E=this.type;function Q(e,i){const a=A.update(d);h.defines.VSM_SAMPLES!==e.blurSamples&&(h.defines.VSM_SAMPLES=e.blurSamples,u.defines.VSM_SAMPLES=e.blurSamples,h.needsUpdate=!0,u.needsUpdate=!0),null===e.mapPass&&(e.mapPass=new n.nWS(s.x,s.y)),h.uniforms.shadow_pass.value=e.map.texture,h.uniforms.resolution.value=e.mapSize,h.uniforms.radius.value=e.radius,t.setRenderTarget(e.mapPass),t.clear(),t.renderBufferDirect(i,null,a,h,d,null),u.uniforms.shadow_pass.value=e.mapPass.texture,u.uniforms.resolution.value=e.mapSize,u.uniforms.radius.value=e.radius,t.setRenderTarget(e.map),t.clear(),t.renderBufferDirect(i,null,a,u,d,null)}function p(A,e,i,s){let a=null;const r=!0===i.isPointLight?A.customDistanceMaterial:A.customDepthMaterial;if(void 0!==r)a=r;else if(a=!0===i.isPointLight?g:o,t.localClippingEnabled&&!0===e.clipShadows&&Array.isArray(e.clippingPlanes)&&0!==e.clippingPlanes.length||e.displacementMap&&0!==e.displacementScale||e.alphaMap&&e.alphaTest>0||e.map&&e.alphaTest>0||!0===e.alphaToCoverage){const t=a.uuid,A=e.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let i=n[A];void 0===i&&(i=a.clone(),n[A]=i,e.addEventListener("dispose",m)),a=i}return a.visible=e.visible,a.wireframe=e.wireframe,s===n.RyA?a.side=null!==e.shadowSide?e.shadowSide:e.side:a.side=null!==e.shadowSide?e.shadowSide:I[e.side],a.alphaMap=e.alphaMap,a.alphaTest=!0===e.alphaToCoverage?.5:e.alphaTest,a.map=e.map,a.clipShadows=e.clipShadows,a.clippingPlanes=e.clippingPlanes,a.clipIntersection=e.clipIntersection,a.displacementMap=e.displacementMap,a.displacementScale=e.displacementScale,a.displacementBias=e.displacementBias,a.wireframeLinewidth=e.wireframeLinewidth,a.linewidth=e.linewidth,!0===i.isPointLight&&!0===a.isMeshDistanceMaterial&&(t.properties.get(a).light=i),a}function f(e,s,a,r,o){if(!1===e.visible)return;if(e.layers.test(s.layers)&&(e.isMesh||e.isLine||e.isPoints)&&(e.castShadow||e.receiveShadow&&o===n.RyA)&&(!e.frustumCulled||i.intersectsObject(e))){e.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,e.matrixWorld);const n=A.update(e),i=e.material;if(Array.isArray(i)){const A=n.groups;for(let g=0,c=A.length;g<c;g++){const c=A[g],l=i[c.materialIndex];if(l&&l.visible){const A=p(e,l,r,o);e.onBeforeShadow(t,e,s,a,n,A,c),t.renderBufferDirect(a,null,n,A,e,c),e.onAfterShadow(t,e,s,a,n,A,c)}}}else if(i.visible){const A=p(e,i,r,o);e.onBeforeShadow(t,e,s,a,n,A,null),t.renderBufferDirect(a,null,n,A,e,null),e.onAfterShadow(t,e,s,a,n,A,null)}}const g=e.children;for(let t=0,A=g.length;t<A;t++)f(g[t],s,a,r,o)}function m(t){t.target.removeEventListener("dispose",m);for(const A in c){const e=c[A],n=t.target.uuid;n in e&&(e[n].dispose(),delete e[n])}}this.render=function(A,e,o){if(!1===C.enabled)return;if(!1===C.autoUpdate&&!1===C.needsUpdate)return;if(0===A.length)return;const g=t.getRenderTarget(),c=t.getActiveCubeFace(),I=t.getActiveMipmapLevel(),h=t.state;h.setBlending(n.XIg),h.buffers.color.setClear(1,1,1,1),h.buffers.depth.setTest(!0),h.setScissorTest(!1);const u=E!==n.RyA&&this.type===n.RyA,B=E===n.RyA&&this.type!==n.RyA;for(let g=0,c=A.length;g<c;g++){const c=A[g],I=c.shadow;if(void 0===I){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===I.autoUpdate&&!1===I.needsUpdate)continue;s.copy(I.mapSize);const d=I.getFrameExtents();if(s.multiply(d),a.copy(I.mapSize),(s.x>l||s.y>l)&&(s.x>l&&(a.x=Math.floor(l/d.x),s.x=a.x*d.x,I.mapSize.x=a.x),s.y>l&&(a.y=Math.floor(l/d.y),s.y=a.y*d.y,I.mapSize.y=a.y)),null===I.map||!0===u||!0===B){const t=this.type!==n.RyA?{minFilter:n.hxR,magFilter:n.hxR}:{};null!==I.map&&I.map.dispose(),I.map=new n.nWS(s.x,s.y,t),I.map.texture.name=c.name+".shadowMap",I.camera.updateProjectionMatrix()}t.setRenderTarget(I.map),t.clear();const C=I.getViewportCount();for(let t=0;t<C;t++){const A=I.getViewport(t);r.set(a.x*A.x,a.y*A.y,a.x*A.z,a.y*A.w),h.viewport(r),I.updateMatrices(c,t),i=I.getFrustum(),f(e,o,I.camera,c,this.type)}!0!==I.isPointLightShadow&&this.type===n.RyA&&Q(I,o),I.needsUpdate=!1}E=this.type,C.needsUpdate=!1,t.setRenderTarget(g,c,I)}}const DA={[n.eHc]:n.lGu,[n.brA]:n.K52,[n.U3G]:n.bw0,[n.xSv]:n.Gwm,[n.lGu]:n.eHc,[n.K52]:n.brA,[n.bw0]:n.U3G,[n.Gwm]:n.xSv};function vA(t,A){const e=new function(){let A=!1;const e=new n.IUQ;let i=null;const s=new n.IUQ(0,0,0,0);return{setMask:function(e){i===e||A||(t.colorMask(e,e,e,e),i=e)},setLocked:function(t){A=t},setClear:function(A,n,i,a,r){!0===r&&(A*=a,n*=a,i*=a),e.set(A,n,i,a),!1===s.equals(e)&&(t.clearColor(A,n,i,a),s.copy(e))},reset:function(){A=!1,i=null,s.set(-1,0,0,0)}}},i=new function(){let e=!1,i=!1,s=null,a=null,r=null;return{setReversed:function(t){if(i!==t){const e=A.get("EXT_clip_control");t?e.clipControlEXT(e.LOWER_LEFT_EXT,e.ZERO_TO_ONE_EXT):e.clipControlEXT(e.LOWER_LEFT_EXT,e.NEGATIVE_ONE_TO_ONE_EXT),i=t;const n=r;r=null,this.setClear(n)}},getReversed:function(){return i},setTest:function(A){A?Y(t.DEPTH_TEST):P(t.DEPTH_TEST)},setMask:function(A){s===A||e||(t.depthMask(A),s=A)},setFunc:function(A){if(i&&(A=DA[A]),a!==A){switch(A){case n.eHc:t.depthFunc(t.NEVER);break;case n.lGu:t.depthFunc(t.ALWAYS);break;case n.brA:t.depthFunc(t.LESS);break;case n.xSv:t.depthFunc(t.LEQUAL);break;case n.U3G:t.depthFunc(t.EQUAL);break;case n.Gwm:t.depthFunc(t.GEQUAL);break;case n.K52:t.depthFunc(t.GREATER);break;case n.bw0:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}a=A}},setLocked:function(t){e=t},setClear:function(A){r!==A&&(i&&(A=1-A),t.clearDepth(A),r=A)},reset:function(){e=!1,s=null,a=null,r=null,i=!1}}},s=new function(){let A=!1,e=null,n=null,i=null,s=null,a=null,r=null,o=null,g=null;return{setTest:function(e){A||(e?Y(t.STENCIL_TEST):P(t.STENCIL_TEST))},setMask:function(n){e===n||A||(t.stencilMask(n),e=n)},setFunc:function(A,e,a){n===A&&i===e&&s===a||(t.stencilFunc(A,e,a),n=A,i=e,s=a)},setOp:function(A,e,n){a===A&&r===e&&o===n||(t.stencilOp(A,e,n),a=A,r=e,o=n)},setLocked:function(t){A=t},setClear:function(A){g!==A&&(t.clearStencil(A),g=A)},reset:function(){A=!1,e=null,n=null,i=null,s=null,a=null,r=null,o=null,g=null}}},a=new WeakMap,r=new WeakMap;let o={},g={},c=new WeakMap,l=[],I=null,h=!1,u=null,B=null,d=null,C=null,E=null,Q=null,p=null,f=new n.Q1f(0,0,0),m=0,y=!1,w=null,x=null,S=null,D=null,v=null;const M=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let b=!1,_=0;const R=t.getParameter(t.VERSION);-1!==R.indexOf("WebGL")?(_=parseFloat(/^WebGL (\d)/.exec(R)[1]),b=_>=1):-1!==R.indexOf("OpenGL ES")&&(_=parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),b=_>=2);let F=null,N={};const k=t.getParameter(t.SCISSOR_BOX),T=t.getParameter(t.VIEWPORT),G=(new n.IUQ).fromArray(k),U=(new n.IUQ).fromArray(T);function L(A,e,n,i){const s=new Uint8Array(4),a=t.createTexture();t.bindTexture(A,a),t.texParameteri(A,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(A,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let a=0;a<n;a++)A===t.TEXTURE_3D||A===t.TEXTURE_2D_ARRAY?t.texImage3D(e,0,t.RGBA,1,1,i,0,t.RGBA,t.UNSIGNED_BYTE,s):t.texImage2D(e+a,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,s);return a}const H={};function Y(A){!0!==o[A]&&(t.enable(A),o[A]=!0)}function P(A){!1!==o[A]&&(t.disable(A),o[A]=!1)}H[t.TEXTURE_2D]=L(t.TEXTURE_2D,t.TEXTURE_2D,1),H[t.TEXTURE_CUBE_MAP]=L(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),H[t.TEXTURE_2D_ARRAY]=L(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),H[t.TEXTURE_3D]=L(t.TEXTURE_3D,t.TEXTURE_3D,1,1),e.setClear(0,0,0,1),i.setClear(1),s.setClear(0),Y(t.DEPTH_TEST),i.setFunc(n.xSv),O(!1),K(n.Vb5),Y(t.CULL_FACE),z(n.XIg);const J={[n.gO9]:t.FUNC_ADD,[n.FXf]:t.FUNC_SUBTRACT,[n.nST]:t.FUNC_REVERSE_SUBTRACT};J[n.znC]=t.MIN,J[n.$ei]=t.MAX;const q={[n.ojh]:t.ZERO,[n.qad]:t.ONE,[n.f4X]:t.SRC_COLOR,[n.ie2]:t.SRC_ALPHA,[n.hgQ]:t.SRC_ALPHA_SATURATE,[n.wn6]:t.DST_COLOR,[n.hdd]:t.DST_ALPHA,[n.LiQ]:t.ONE_MINUS_SRC_COLOR,[n.OuU]:t.ONE_MINUS_SRC_ALPHA,[n.aEY]:t.ONE_MINUS_DST_COLOR,[n.Nt7]:t.ONE_MINUS_DST_ALPHA,[n.RrE]:t.CONSTANT_COLOR,[n.$Yl]:t.ONE_MINUS_CONSTANT_COLOR,[n.e0p]:t.CONSTANT_ALPHA,[n.ov9]:t.ONE_MINUS_CONSTANT_ALPHA};function z(A,e,i,s,a,r,o,g,c,l){if(A!==n.XIg){if(!1===h&&(Y(t.BLEND),h=!0),A===n.bCz)a=a||e,r=r||i,o=o||s,e===B&&a===E||(t.blendEquationSeparate(J[e],J[a]),B=e,E=a),i===d&&s===C&&r===Q&&o===p||(t.blendFuncSeparate(q[i],q[s],q[r],q[o]),d=i,C=s,Q=r,p=o),!1!==g.equals(f)&&c===m||(t.blendColor(g.r,g.g,g.b,c),f.copy(g),m=c),u=A,y=!1;else if(A!==u||l!==y){if(B===n.gO9&&E===n.gO9||(t.blendEquation(t.FUNC_ADD),B=n.gO9,E=n.gO9),l)switch(A){case n.NTi:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case n.EZo:t.blendFunc(t.ONE,t.ONE);break;case n.Kwu:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case n.EdD:t.blendFuncSeparate(t.DST_COLOR,t.ONE_MINUS_SRC_ALPHA,t.ZERO,t.ONE);break;default:console.error("THREE.WebGLState: Invalid blending: ",A)}else switch(A){case n.NTi:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case n.EZo:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE,t.ONE,t.ONE);break;case n.Kwu:console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case n.EdD:console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:console.error("THREE.WebGLState: Invalid blending: ",A)}d=null,C=null,Q=null,p=null,f.set(0,0,0),m=0,u=A,y=l}}else!0===h&&(P(t.BLEND),h=!1)}function O(A){w!==A&&(A?t.frontFace(t.CW):t.frontFace(t.CCW),w=A)}function K(A){A!==n.WNZ?(Y(t.CULL_FACE),A!==x&&(A===n.Vb5?t.cullFace(t.BACK):A===n.Jnc?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):P(t.CULL_FACE),x=A}function V(A,e,n){A?(Y(t.POLYGON_OFFSET_FILL),D===e&&v===n||(t.polygonOffset(e,n),D=e,v=n)):P(t.POLYGON_OFFSET_FILL)}return{buffers:{color:e,depth:i,stencil:s},enable:Y,disable:P,bindFramebuffer:function(A,e){return g[A]!==e&&(t.bindFramebuffer(A,e),g[A]=e,A===t.DRAW_FRAMEBUFFER&&(g[t.FRAMEBUFFER]=e),A===t.FRAMEBUFFER&&(g[t.DRAW_FRAMEBUFFER]=e),!0)},drawBuffers:function(A,e){let n=l,i=!1;if(A){n=c.get(e),void 0===n&&(n=[],c.set(e,n));const s=A.textures;if(n.length!==s.length||n[0]!==t.COLOR_ATTACHMENT0){for(let A=0,e=s.length;A<e;A++)n[A]=t.COLOR_ATTACHMENT0+A;n.length=s.length,i=!0}}else n[0]!==t.BACK&&(n[0]=t.BACK,i=!0);i&&t.drawBuffers(n)},useProgram:function(A){return I!==A&&(t.useProgram(A),I=A,!0)},setBlending:z,setMaterial:function(A,a){A.side===n.$EB?P(t.CULL_FACE):Y(t.CULL_FACE);let r=A.side===n.hsX;a&&(r=!r),O(r),A.blending===n.NTi&&!1===A.transparent?z(n.XIg):z(A.blending,A.blendEquation,A.blendSrc,A.blendDst,A.blendEquationAlpha,A.blendSrcAlpha,A.blendDstAlpha,A.blendColor,A.blendAlpha,A.premultipliedAlpha),i.setFunc(A.depthFunc),i.setTest(A.depthTest),i.setMask(A.depthWrite),e.setMask(A.colorWrite);const o=A.stencilWrite;s.setTest(o),o&&(s.setMask(A.stencilWriteMask),s.setFunc(A.stencilFunc,A.stencilRef,A.stencilFuncMask),s.setOp(A.stencilFail,A.stencilZFail,A.stencilZPass)),V(A.polygonOffset,A.polygonOffsetFactor,A.polygonOffsetUnits),!0===A.alphaToCoverage?Y(t.SAMPLE_ALPHA_TO_COVERAGE):P(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:O,setCullFace:K,setLineWidth:function(A){A!==S&&(b&&t.lineWidth(A),S=A)},setPolygonOffset:V,setScissorTest:function(A){A?Y(t.SCISSOR_TEST):P(t.SCISSOR_TEST)},activeTexture:function(A){void 0===A&&(A=t.TEXTURE0+M-1),F!==A&&(t.activeTexture(A),F=A)},bindTexture:function(A,e,n){void 0===n&&(n=null===F?t.TEXTURE0+M-1:F);let i=N[n];void 0===i&&(i={type:void 0,texture:void 0},N[n]=i),i.type===A&&i.texture===e||(F!==n&&(t.activeTexture(n),F=n),t.bindTexture(A,e||H[A]),i.type=A,i.texture=e)},unbindTexture:function(){const A=N[F];void 0!==A&&void 0!==A.type&&(t.bindTexture(A.type,null),A.type=void 0,A.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexImage3D:function(){try{t.compressedTexImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},updateUBOMapping:function(A,e){let n=r.get(e);void 0===n&&(n=new WeakMap,r.set(e,n));let i=n.get(A);void 0===i&&(i=t.getUniformBlockIndex(e,A.name),n.set(A,i))},uniformBlockBinding:function(A,e){const n=r.get(e).get(A);a.get(e)!==n&&(t.uniformBlockBinding(e,n,A.__bindingPointIndex),a.set(e,n))},texStorage2D:function(){try{t.texStorage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(A){!1===G.equals(A)&&(t.scissor(A.x,A.y,A.z,A.w),G.copy(A))},viewport:function(A){!1===U.equals(A)&&(t.viewport(A.x,A.y,A.z,A.w),U.copy(A))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),i.setReversed(!1),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),o={},F=null,N={},g={},c=new WeakMap,l=[],I=null,h=!1,u=null,B=null,d=null,C=null,E=null,Q=null,p=null,f=new n.Q1f(0,0,0),m=0,y=!1,w=null,x=null,S=null,D=null,v=null,G.set(0,0,t.canvas.width,t.canvas.height),U.set(0,0,t.canvas.width,t.canvas.height),e.reset(),i.reset(),s.reset()}}}function MA(t,A,e,i,s,a,r){const o=A.has("WEBGL_multisampled_render_to_texture")?A.get("WEBGL_multisampled_render_to_texture"):null,g="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),c=new n.I9Y,l=new WeakMap;let I;const h=new WeakMap;let u=!1;try{u="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function B(t,A){return u?new OffscreenCanvas(t,A):(0,n.qq$)("canvas")}function d(t,A,e){let n=1;const i=q(t);if((i.width>e||i.height>e)&&(n=e/Math.max(i.width,i.height)),n<1){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&t instanceof VideoFrame){const e=Math.floor(n*i.width),s=Math.floor(n*i.height);void 0===I&&(I=B(e,s));const a=A?B(e,s):I;return a.width=e,a.height=s,a.getContext("2d").drawImage(t,0,0,e,s),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+i.width+"x"+i.height+") to ("+e+"x"+s+")."),a}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+i.width+"x"+i.height+")."),t}return t}function C(t){return t.generateMipmaps}function E(A){t.generateMipmap(A)}function Q(A){return A.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:A.isWebGL3DRenderTarget?t.TEXTURE_3D:A.isWebGLArrayRenderTarget||A.isCompressedArrayTexture?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D}function p(e,i,s,a,r=!1){if(null!==e){if(void 0!==t[e])return t[e];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+e+"'")}let o=i;if(i===t.RED&&(s===t.FLOAT&&(o=t.R32F),s===t.HALF_FLOAT&&(o=t.R16F),s===t.UNSIGNED_BYTE&&(o=t.R8)),i===t.RED_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.R8UI),s===t.UNSIGNED_SHORT&&(o=t.R16UI),s===t.UNSIGNED_INT&&(o=t.R32UI),s===t.BYTE&&(o=t.R8I),s===t.SHORT&&(o=t.R16I),s===t.INT&&(o=t.R32I)),i===t.RG&&(s===t.FLOAT&&(o=t.RG32F),s===t.HALF_FLOAT&&(o=t.RG16F),s===t.UNSIGNED_BYTE&&(o=t.RG8)),i===t.RG_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RG8UI),s===t.UNSIGNED_SHORT&&(o=t.RG16UI),s===t.UNSIGNED_INT&&(o=t.RG32UI),s===t.BYTE&&(o=t.RG8I),s===t.SHORT&&(o=t.RG16I),s===t.INT&&(o=t.RG32I)),i===t.RGB_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RGB8UI),s===t.UNSIGNED_SHORT&&(o=t.RGB16UI),s===t.UNSIGNED_INT&&(o=t.RGB32UI),s===t.BYTE&&(o=t.RGB8I),s===t.SHORT&&(o=t.RGB16I),s===t.INT&&(o=t.RGB32I)),i===t.RGBA_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RGBA8UI),s===t.UNSIGNED_SHORT&&(o=t.RGBA16UI),s===t.UNSIGNED_INT&&(o=t.RGBA32UI),s===t.BYTE&&(o=t.RGBA8I),s===t.SHORT&&(o=t.RGBA16I),s===t.INT&&(o=t.RGBA32I)),i===t.RGB&&s===t.UNSIGNED_INT_5_9_9_9_REV&&(o=t.RGB9_E5),i===t.RGBA){const A=r?n.VxR:n.ppV.getTransfer(a);s===t.FLOAT&&(o=t.RGBA32F),s===t.HALF_FLOAT&&(o=t.RGBA16F),s===t.UNSIGNED_BYTE&&(o=A===n.KLL?t.SRGB8_ALPHA8:t.RGBA8),s===t.UNSIGNED_SHORT_4_4_4_4&&(o=t.RGBA4),s===t.UNSIGNED_SHORT_5_5_5_1&&(o=t.RGB5_A1)}return o!==t.R16F&&o!==t.R32F&&o!==t.RG16F&&o!==t.RG32F&&o!==t.RGBA16F&&o!==t.RGBA32F||A.get("EXT_color_buffer_float"),o}function f(A,e){let i;return A?null===e||e===n.bkx||e===n.V3x?i=t.DEPTH24_STENCIL8:e===n.RQf?i=t.DEPTH32F_STENCIL8:e===n.cHt&&(i=t.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):null===e||e===n.bkx||e===n.V3x?i=t.DEPTH_COMPONENT24:e===n.RQf?i=t.DEPTH_COMPONENT32F:e===n.cHt&&(i=t.DEPTH_COMPONENT16),i}function m(t,A){return!0===C(t)||t.isFramebufferTexture&&t.minFilter!==n.hxR&&t.minFilter!==n.k6q?Math.log2(Math.max(A.width,A.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?A.mipmaps.length:1}function y(t){const A=t.target;A.removeEventListener("dispose",y),function(t){const A=i.get(t);if(void 0===A.__webglInit)return;const e=t.source,n=h.get(e);if(n){const i=n[A.__cacheKey];i.usedTimes--,0===i.usedTimes&&x(t),0===Object.keys(n).length&&h.delete(e)}i.remove(t)}(A),A.isVideoTexture&&l.delete(A)}function w(A){const e=A.target;e.removeEventListener("dispose",w),function(A){const e=i.get(A);if(A.depthTexture&&(A.depthTexture.dispose(),i.remove(A.depthTexture)),A.isWebGLCubeRenderTarget)for(let A=0;A<6;A++){if(Array.isArray(e.__webglFramebuffer[A]))for(let n=0;n<e.__webglFramebuffer[A].length;n++)t.deleteFramebuffer(e.__webglFramebuffer[A][n]);else t.deleteFramebuffer(e.__webglFramebuffer[A]);e.__webglDepthbuffer&&t.deleteRenderbuffer(e.__webglDepthbuffer[A])}else{if(Array.isArray(e.__webglFramebuffer))for(let A=0;A<e.__webglFramebuffer.length;A++)t.deleteFramebuffer(e.__webglFramebuffer[A]);else t.deleteFramebuffer(e.__webglFramebuffer);if(e.__webglDepthbuffer&&t.deleteRenderbuffer(e.__webglDepthbuffer),e.__webglMultisampledFramebuffer&&t.deleteFramebuffer(e.__webglMultisampledFramebuffer),e.__webglColorRenderbuffer)for(let A=0;A<e.__webglColorRenderbuffer.length;A++)e.__webglColorRenderbuffer[A]&&t.deleteRenderbuffer(e.__webglColorRenderbuffer[A]);e.__webglDepthRenderbuffer&&t.deleteRenderbuffer(e.__webglDepthRenderbuffer)}const n=A.textures;for(let A=0,e=n.length;A<e;A++){const e=i.get(n[A]);e.__webglTexture&&(t.deleteTexture(e.__webglTexture),r.memory.textures--),i.remove(n[A])}i.remove(A)}(e)}function x(A){const e=i.get(A);t.deleteTexture(e.__webglTexture);const n=A.source;delete h.get(n)[e.__cacheKey],r.memory.textures--}let S=0;function D(A,n){const s=i.get(A);if(A.isVideoTexture&&function(t){const A=r.render.frame;l.get(t)!==A&&(l.set(t,A),t.update())}(A),!1===A.isRenderTargetTexture&&A.version>0&&s.__version!==A.version){const t=A.image;if(null===t)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==t.complete)return void N(s,A,n);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}e.bindTexture(t.TEXTURE_2D,s.__webglTexture,t.TEXTURE0+n)}const v={[n.GJx]:t.REPEAT,[n.ghU]:t.CLAMP_TO_EDGE,[n.kTW]:t.MIRRORED_REPEAT},M={[n.hxR]:t.NEAREST,[n.pHI]:t.NEAREST_MIPMAP_NEAREST,[n.Cfg]:t.NEAREST_MIPMAP_LINEAR,[n.k6q]:t.LINEAR,[n.kRr]:t.LINEAR_MIPMAP_NEAREST,[n.$_I]:t.LINEAR_MIPMAP_LINEAR},b={[n.amv]:t.NEVER,[n.FFZ]:t.ALWAYS,[n.vim]:t.LESS,[n.TiK]:t.LEQUAL,[n.kO0]:t.EQUAL,[n.gWB]:t.GEQUAL,[n.eoi]:t.GREATER,[n.jzd]:t.NOTEQUAL};function _(e,a){if(a.type!==n.RQf||!1!==A.has("OES_texture_float_linear")||a.magFilter!==n.k6q&&a.magFilter!==n.kRr&&a.magFilter!==n.Cfg&&a.magFilter!==n.$_I&&a.minFilter!==n.k6q&&a.minFilter!==n.kRr&&a.minFilter!==n.Cfg&&a.minFilter!==n.$_I||console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),t.texParameteri(e,t.TEXTURE_WRAP_S,v[a.wrapS]),t.texParameteri(e,t.TEXTURE_WRAP_T,v[a.wrapT]),e!==t.TEXTURE_3D&&e!==t.TEXTURE_2D_ARRAY||t.texParameteri(e,t.TEXTURE_WRAP_R,v[a.wrapR]),t.texParameteri(e,t.TEXTURE_MAG_FILTER,M[a.magFilter]),t.texParameteri(e,t.TEXTURE_MIN_FILTER,M[a.minFilter]),a.compareFunction&&(t.texParameteri(e,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(e,t.TEXTURE_COMPARE_FUNC,b[a.compareFunction])),!0===A.has("EXT_texture_filter_anisotropic")){if(a.magFilter===n.hxR)return;if(a.minFilter!==n.Cfg&&a.minFilter!==n.$_I)return;if(a.type===n.RQf&&!1===A.has("OES_texture_float_linear"))return;if(a.anisotropy>1||i.get(a).__currentAnisotropy){const n=A.get("EXT_texture_filter_anisotropic");t.texParameterf(e,n.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,s.getMaxAnisotropy())),i.get(a).__currentAnisotropy=a.anisotropy}}}function R(A,e){let n=!1;void 0===A.__webglInit&&(A.__webglInit=!0,e.addEventListener("dispose",y));const i=e.source;let s=h.get(i);void 0===s&&(s={},h.set(i,s));const a=function(t){const A=[];return A.push(t.wrapS),A.push(t.wrapT),A.push(t.wrapR||0),A.push(t.magFilter),A.push(t.minFilter),A.push(t.anisotropy),A.push(t.internalFormat),A.push(t.format),A.push(t.type),A.push(t.generateMipmaps),A.push(t.premultiplyAlpha),A.push(t.flipY),A.push(t.unpackAlignment),A.push(t.colorSpace),A.join()}(e);if(a!==A.__cacheKey){void 0===s[a]&&(s[a]={texture:t.createTexture(),usedTimes:0},r.memory.textures++,n=!0),s[a].usedTimes++;const i=s[A.__cacheKey];void 0!==i&&(s[A.__cacheKey].usedTimes--,0===i.usedTimes&&x(e)),A.__cacheKey=a,A.__webglTexture=s[a].texture}return n}function F(t,A,e){return Math.floor(Math.floor(t/e)/A)}function N(A,r,o){let g=t.TEXTURE_2D;(r.isDataArrayTexture||r.isCompressedArrayTexture)&&(g=t.TEXTURE_2D_ARRAY),r.isData3DTexture&&(g=t.TEXTURE_3D);const c=R(A,r),l=r.source;e.bindTexture(g,A.__webglTexture,t.TEXTURE0+o);const I=i.get(l);if(l.version!==I.__version||!0===c){e.activeTexture(t.TEXTURE0+o);const A=n.ppV.getPrimaries(n.ppV.workingColorSpace),i=r.colorSpace===n.jf0?null:n.ppV.getPrimaries(r.colorSpace),h=r.colorSpace===n.jf0||A===i?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,r.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,h);let u=d(r.image,!1,s.maxTextureSize);u=J(r,u);const B=a.convert(r.format,r.colorSpace),Q=a.convert(r.type);let y,w=p(r.internalFormat,B,Q,r.colorSpace,r.isVideoTexture);_(g,r);const x=r.mipmaps,S=!0!==r.isVideoTexture,D=void 0===I.__version||!0===c,v=l.dataReady,M=m(r,u);if(r.isDepthTexture)w=f(r.format===n.dcC,r.type),D&&(S?e.texStorage2D(t.TEXTURE_2D,1,w,u.width,u.height):e.texImage2D(t.TEXTURE_2D,0,w,u.width,u.height,0,B,Q,null));else if(r.isDataTexture)if(x.length>0){S&&D&&e.texStorage2D(t.TEXTURE_2D,M,w,x[0].width,x[0].height);for(let A=0,n=x.length;A<n;A++)y=x[A],S?v&&e.texSubImage2D(t.TEXTURE_2D,A,0,0,y.width,y.height,B,Q,y.data):e.texImage2D(t.TEXTURE_2D,A,w,y.width,y.height,0,B,Q,y.data);r.generateMipmaps=!1}else S?(D&&e.texStorage2D(t.TEXTURE_2D,M,w,u.width,u.height),v&&function(A,n,i,s){const a=A.updateRanges;if(0===a.length)e.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,i,s,n.data);else{a.sort((t,A)=>t.start-A.start);let r=0;for(let t=1;t<a.length;t++){const A=a[r],e=a[t],i=A.start+A.count,s=F(e.start,n.width,4),o=F(A.start,n.width,4);e.start<=i+1&&s===o&&F(e.start+e.count-1,n.width,4)===s?A.count=Math.max(A.count,e.start+e.count-A.start):(++r,a[r]=e)}a.length=r+1;const o=t.getParameter(t.UNPACK_ROW_LENGTH),g=t.getParameter(t.UNPACK_SKIP_PIXELS),c=t.getParameter(t.UNPACK_SKIP_ROWS);t.pixelStorei(t.UNPACK_ROW_LENGTH,n.width);for(let A=0,r=a.length;A<r;A++){const r=a[A],o=Math.floor(r.start/4),g=Math.ceil(r.count/4),c=o%n.width,l=Math.floor(o/n.width),I=g,h=1;t.pixelStorei(t.UNPACK_SKIP_PIXELS,c),t.pixelStorei(t.UNPACK_SKIP_ROWS,l),e.texSubImage2D(t.TEXTURE_2D,0,c,l,I,h,i,s,n.data)}A.clearUpdateRanges(),t.pixelStorei(t.UNPACK_ROW_LENGTH,o),t.pixelStorei(t.UNPACK_SKIP_PIXELS,g),t.pixelStorei(t.UNPACK_SKIP_ROWS,c)}}(r,u,B,Q)):e.texImage2D(t.TEXTURE_2D,0,w,u.width,u.height,0,B,Q,u.data);else if(r.isCompressedTexture)if(r.isCompressedArrayTexture){S&&D&&e.texStorage3D(t.TEXTURE_2D_ARRAY,M,w,x[0].width,x[0].height,u.depth);for(let A=0,i=x.length;A<i;A++)if(y=x[A],r.format!==n.GWd)if(null!==B)if(S){if(v)if(r.layerUpdates.size>0){const i=(0,n.Nex)(y.width,y.height,r.format,r.type);for(const n of r.layerUpdates){const s=y.data.subarray(n*i/y.data.BYTES_PER_ELEMENT,(n+1)*i/y.data.BYTES_PER_ELEMENT);e.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,A,0,0,n,y.width,y.height,1,B,s)}r.clearLayerUpdates()}else e.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,A,0,0,0,y.width,y.height,u.depth,B,y.data)}else e.compressedTexImage3D(t.TEXTURE_2D_ARRAY,A,w,y.width,y.height,u.depth,0,y.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else S?v&&e.texSubImage3D(t.TEXTURE_2D_ARRAY,A,0,0,0,y.width,y.height,u.depth,B,Q,y.data):e.texImage3D(t.TEXTURE_2D_ARRAY,A,w,y.width,y.height,u.depth,0,B,Q,y.data)}else{S&&D&&e.texStorage2D(t.TEXTURE_2D,M,w,x[0].width,x[0].height);for(let A=0,i=x.length;A<i;A++)y=x[A],r.format!==n.GWd?null!==B?S?v&&e.compressedTexSubImage2D(t.TEXTURE_2D,A,0,0,y.width,y.height,B,y.data):e.compressedTexImage2D(t.TEXTURE_2D,A,w,y.width,y.height,0,y.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):S?v&&e.texSubImage2D(t.TEXTURE_2D,A,0,0,y.width,y.height,B,Q,y.data):e.texImage2D(t.TEXTURE_2D,A,w,y.width,y.height,0,B,Q,y.data)}else if(r.isDataArrayTexture)if(S){if(D&&e.texStorage3D(t.TEXTURE_2D_ARRAY,M,w,u.width,u.height,u.depth),v)if(r.layerUpdates.size>0){const A=(0,n.Nex)(u.width,u.height,r.format,r.type);for(const n of r.layerUpdates){const i=u.data.subarray(n*A/u.data.BYTES_PER_ELEMENT,(n+1)*A/u.data.BYTES_PER_ELEMENT);e.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,n,u.width,u.height,1,B,Q,i)}r.clearLayerUpdates()}else e.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,u.width,u.height,u.depth,B,Q,u.data)}else e.texImage3D(t.TEXTURE_2D_ARRAY,0,w,u.width,u.height,u.depth,0,B,Q,u.data);else if(r.isData3DTexture)S?(D&&e.texStorage3D(t.TEXTURE_3D,M,w,u.width,u.height,u.depth),v&&e.texSubImage3D(t.TEXTURE_3D,0,0,0,0,u.width,u.height,u.depth,B,Q,u.data)):e.texImage3D(t.TEXTURE_3D,0,w,u.width,u.height,u.depth,0,B,Q,u.data);else if(r.isFramebufferTexture){if(D)if(S)e.texStorage2D(t.TEXTURE_2D,M,w,u.width,u.height);else{let A=u.width,n=u.height;for(let i=0;i<M;i++)e.texImage2D(t.TEXTURE_2D,i,w,A,n,0,B,Q,null),A>>=1,n>>=1}}else if(x.length>0){if(S&&D){const A=q(x[0]);e.texStorage2D(t.TEXTURE_2D,M,w,A.width,A.height)}for(let A=0,n=x.length;A<n;A++)y=x[A],S?v&&e.texSubImage2D(t.TEXTURE_2D,A,0,0,B,Q,y):e.texImage2D(t.TEXTURE_2D,A,w,B,Q,y);r.generateMipmaps=!1}else if(S){if(D){const A=q(u);e.texStorage2D(t.TEXTURE_2D,M,w,A.width,A.height)}v&&e.texSubImage2D(t.TEXTURE_2D,0,0,0,B,Q,u)}else e.texImage2D(t.TEXTURE_2D,0,w,B,Q,u);C(r)&&E(g),I.__version=l.version,r.onUpdate&&r.onUpdate(r)}A.__version=r.version}function k(A,n,s,r,g,c){const l=a.convert(s.format,s.colorSpace),I=a.convert(s.type),h=p(s.internalFormat,l,I,s.colorSpace),u=i.get(n),B=i.get(s);if(B.__renderTarget=n,!u.__hasExternalTextures){const A=Math.max(1,n.width>>c),i=Math.max(1,n.height>>c);g===t.TEXTURE_3D||g===t.TEXTURE_2D_ARRAY?e.texImage3D(g,c,h,A,i,n.depth,0,l,I,null):e.texImage2D(g,c,h,A,i,0,l,I,null)}e.bindFramebuffer(t.FRAMEBUFFER,A),P(n)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,r,g,B.__webglTexture,0,Y(n)):(g===t.TEXTURE_2D||g>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&g<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,r,g,B.__webglTexture,c),e.bindFramebuffer(t.FRAMEBUFFER,null)}function T(A,e,n){if(t.bindRenderbuffer(t.RENDERBUFFER,A),e.depthBuffer){const i=e.depthTexture,s=i&&i.isDepthTexture?i.type:null,a=f(e.stencilBuffer,s),r=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,g=Y(e);P(e)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,g,a,e.width,e.height):n?t.renderbufferStorageMultisample(t.RENDERBUFFER,g,a,e.width,e.height):t.renderbufferStorage(t.RENDERBUFFER,a,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,r,t.RENDERBUFFER,A)}else{const A=e.textures;for(let i=0;i<A.length;i++){const s=A[i],r=a.convert(s.format,s.colorSpace),g=a.convert(s.type),c=p(s.internalFormat,r,g,s.colorSpace),l=Y(e);n&&!1===P(e)?t.renderbufferStorageMultisample(t.RENDERBUFFER,l,c,e.width,e.height):P(e)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,l,c,e.width,e.height):t.renderbufferStorage(t.RENDERBUFFER,c,e.width,e.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function G(A,s){if(s&&s.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(t.FRAMEBUFFER,A),!s.depthTexture||!s.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const a=i.get(s.depthTexture);a.__renderTarget=s,a.__webglTexture&&s.depthTexture.image.width===s.width&&s.depthTexture.image.height===s.height||(s.depthTexture.image.width=s.width,s.depthTexture.image.height=s.height,s.depthTexture.needsUpdate=!0),D(s.depthTexture,0);const r=a.__webglTexture,g=Y(s);if(s.depthTexture.format===n.zdS)P(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,r,0,g):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,r,0);else{if(s.depthTexture.format!==n.dcC)throw new Error("Unknown depthTexture format");P(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,r,0,g):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,r,0)}}function U(A){const n=i.get(A),s=!0===A.isWebGLCubeRenderTarget;if(n.__boundDepthTexture!==A.depthTexture){const t=A.depthTexture;if(n.__depthDisposeCallback&&n.__depthDisposeCallback(),t){const A=()=>{delete n.__boundDepthTexture,delete n.__depthDisposeCallback,t.removeEventListener("dispose",A)};t.addEventListener("dispose",A),n.__depthDisposeCallback=A}n.__boundDepthTexture=t}if(A.depthTexture&&!n.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");const t=A.texture.mipmaps;t&&t.length>0?G(n.__webglFramebuffer[0],A):G(n.__webglFramebuffer,A)}else if(s){n.__webglDepthbuffer=[];for(let i=0;i<6;i++)if(e.bindFramebuffer(t.FRAMEBUFFER,n.__webglFramebuffer[i]),void 0===n.__webglDepthbuffer[i])n.__webglDepthbuffer[i]=t.createRenderbuffer(),T(n.__webglDepthbuffer[i],A,!1);else{const e=A.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,s=n.__webglDepthbuffer[i];t.bindRenderbuffer(t.RENDERBUFFER,s),t.framebufferRenderbuffer(t.FRAMEBUFFER,e,t.RENDERBUFFER,s)}}else{const i=A.texture.mipmaps;if(i&&i.length>0?e.bindFramebuffer(t.FRAMEBUFFER,n.__webglFramebuffer[0]):e.bindFramebuffer(t.FRAMEBUFFER,n.__webglFramebuffer),void 0===n.__webglDepthbuffer)n.__webglDepthbuffer=t.createRenderbuffer(),T(n.__webglDepthbuffer,A,!1);else{const e=A.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,i=n.__webglDepthbuffer;t.bindRenderbuffer(t.RENDERBUFFER,i),t.framebufferRenderbuffer(t.FRAMEBUFFER,e,t.RENDERBUFFER,i)}}e.bindFramebuffer(t.FRAMEBUFFER,null)}const L=[],H=[];function Y(t){return Math.min(s.maxSamples,t.samples)}function P(t){const e=i.get(t);return t.samples>0&&!0===A.has("WEBGL_multisampled_render_to_texture")&&!1!==e.__useRenderToTexture}function J(t,A){const e=t.colorSpace,i=t.format,s=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||e!==n.Zr2&&e!==n.jf0&&(n.ppV.getTransfer(e)===n.KLL?i===n.GWd&&s===n.OUM||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",e)),A}function q(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement?(c.width=t.naturalWidth||t.width,c.height=t.naturalHeight||t.height):"undefined"!=typeof VideoFrame&&t instanceof VideoFrame?(c.width=t.displayWidth,c.height=t.displayHeight):(c.width=t.width,c.height=t.height),c}this.allocateTextureUnit=function(){const t=S;return t>=s.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+s.maxTextures),S+=1,t},this.resetTextureUnits=function(){S=0},this.setTexture2D=D,this.setTexture2DArray=function(A,n){const s=i.get(A);A.version>0&&s.__version!==A.version?N(s,A,n):e.bindTexture(t.TEXTURE_2D_ARRAY,s.__webglTexture,t.TEXTURE0+n)},this.setTexture3D=function(A,n){const s=i.get(A);A.version>0&&s.__version!==A.version?N(s,A,n):e.bindTexture(t.TEXTURE_3D,s.__webglTexture,t.TEXTURE0+n)},this.setTextureCube=function(A,r){const o=i.get(A);A.version>0&&o.__version!==A.version?function(A,r,o){if(6!==r.image.length)return;const g=R(A,r),c=r.source;e.bindTexture(t.TEXTURE_CUBE_MAP,A.__webglTexture,t.TEXTURE0+o);const l=i.get(c);if(c.version!==l.__version||!0===g){e.activeTexture(t.TEXTURE0+o);const A=n.ppV.getPrimaries(n.ppV.workingColorSpace),i=r.colorSpace===n.jf0?null:n.ppV.getPrimaries(r.colorSpace),I=r.colorSpace===n.jf0||A===i?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,r.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,I);const h=r.isCompressedTexture||r.image[0].isCompressedTexture,u=r.image[0]&&r.image[0].isDataTexture,B=[];for(let t=0;t<6;t++)B[t]=h||u?u?r.image[t].image:r.image[t]:d(r.image[t],!0,s.maxCubemapSize),B[t]=J(r,B[t]);const Q=B[0],f=a.convert(r.format,r.colorSpace),y=a.convert(r.type),w=p(r.internalFormat,f,y,r.colorSpace),x=!0!==r.isVideoTexture,S=void 0===l.__version||!0===g,D=c.dataReady;let v,M=m(r,Q);if(_(t.TEXTURE_CUBE_MAP,r),h){x&&S&&e.texStorage2D(t.TEXTURE_CUBE_MAP,M,w,Q.width,Q.height);for(let A=0;A<6;A++){v=B[A].mipmaps;for(let i=0;i<v.length;i++){const s=v[i];r.format!==n.GWd?null!==f?x?D&&e.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,i,0,0,s.width,s.height,f,s.data):e.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,i,w,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):x?D&&e.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,i,0,0,s.width,s.height,f,y,s.data):e.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,i,w,s.width,s.height,0,f,y,s.data)}}}else{if(v=r.mipmaps,x&&S){v.length>0&&M++;const A=q(B[0]);e.texStorage2D(t.TEXTURE_CUBE_MAP,M,w,A.width,A.height)}for(let A=0;A<6;A++)if(u){x?D&&e.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,0,0,0,B[A].width,B[A].height,f,y,B[A].data):e.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,0,w,B[A].width,B[A].height,0,f,y,B[A].data);for(let n=0;n<v.length;n++){const i=v[n].image[A].image;x?D&&e.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,n+1,0,0,i.width,i.height,f,y,i.data):e.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,n+1,w,i.width,i.height,0,f,y,i.data)}}else{x?D&&e.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,0,0,0,f,y,B[A]):e.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,0,w,f,y,B[A]);for(let n=0;n<v.length;n++){const i=v[n];x?D&&e.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,n+1,0,0,f,y,i.image[A]):e.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+A,n+1,w,f,y,i.image[A])}}}C(r)&&E(t.TEXTURE_CUBE_MAP),l.__version=c.version,r.onUpdate&&r.onUpdate(r)}A.__version=r.version}(o,A,r):e.bindTexture(t.TEXTURE_CUBE_MAP,o.__webglTexture,t.TEXTURE0+r)},this.rebindTextures=function(A,e,n){const s=i.get(A);void 0!==e&&k(s.__webglFramebuffer,A,A.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),void 0!==n&&U(A)},this.setupRenderTarget=function(A){const n=A.texture,s=i.get(A),o=i.get(n);A.addEventListener("dispose",w);const g=A.textures,c=!0===A.isWebGLCubeRenderTarget,l=g.length>1;if(l||(void 0===o.__webglTexture&&(o.__webglTexture=t.createTexture()),o.__version=n.version,r.memory.textures++),c){s.__webglFramebuffer=[];for(let A=0;A<6;A++)if(n.mipmaps&&n.mipmaps.length>0){s.__webglFramebuffer[A]=[];for(let e=0;e<n.mipmaps.length;e++)s.__webglFramebuffer[A][e]=t.createFramebuffer()}else s.__webglFramebuffer[A]=t.createFramebuffer()}else{if(n.mipmaps&&n.mipmaps.length>0){s.__webglFramebuffer=[];for(let A=0;A<n.mipmaps.length;A++)s.__webglFramebuffer[A]=t.createFramebuffer()}else s.__webglFramebuffer=t.createFramebuffer();if(l)for(let A=0,e=g.length;A<e;A++){const e=i.get(g[A]);void 0===e.__webglTexture&&(e.__webglTexture=t.createTexture(),r.memory.textures++)}if(A.samples>0&&!1===P(A)){s.__webglMultisampledFramebuffer=t.createFramebuffer(),s.__webglColorRenderbuffer=[],e.bindFramebuffer(t.FRAMEBUFFER,s.__webglMultisampledFramebuffer);for(let e=0;e<g.length;e++){const n=g[e];s.__webglColorRenderbuffer[e]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,s.__webglColorRenderbuffer[e]);const i=a.convert(n.format,n.colorSpace),r=a.convert(n.type),o=p(n.internalFormat,i,r,n.colorSpace,!0===A.isXRRenderTarget),c=Y(A);t.renderbufferStorageMultisample(t.RENDERBUFFER,c,o,A.width,A.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,s.__webglColorRenderbuffer[e])}t.bindRenderbuffer(t.RENDERBUFFER,null),A.depthBuffer&&(s.__webglDepthRenderbuffer=t.createRenderbuffer(),T(s.__webglDepthRenderbuffer,A,!0)),e.bindFramebuffer(t.FRAMEBUFFER,null)}}if(c){e.bindTexture(t.TEXTURE_CUBE_MAP,o.__webglTexture),_(t.TEXTURE_CUBE_MAP,n);for(let e=0;e<6;e++)if(n.mipmaps&&n.mipmaps.length>0)for(let i=0;i<n.mipmaps.length;i++)k(s.__webglFramebuffer[e][i],A,n,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i);else k(s.__webglFramebuffer[e],A,n,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0);C(n)&&E(t.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(l){for(let n=0,a=g.length;n<a;n++){const a=g[n],r=i.get(a);e.bindTexture(t.TEXTURE_2D,r.__webglTexture),_(t.TEXTURE_2D,a),k(s.__webglFramebuffer,A,a,t.COLOR_ATTACHMENT0+n,t.TEXTURE_2D,0),C(a)&&E(t.TEXTURE_2D)}e.unbindTexture()}else{let i=t.TEXTURE_2D;if((A.isWebGL3DRenderTarget||A.isWebGLArrayRenderTarget)&&(i=A.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),e.bindTexture(i,o.__webglTexture),_(i,n),n.mipmaps&&n.mipmaps.length>0)for(let e=0;e<n.mipmaps.length;e++)k(s.__webglFramebuffer[e],A,n,t.COLOR_ATTACHMENT0,i,e);else k(s.__webglFramebuffer,A,n,t.COLOR_ATTACHMENT0,i,0);C(n)&&E(i),e.unbindTexture()}A.depthBuffer&&U(A)},this.updateRenderTargetMipmap=function(t){const A=t.textures;for(let n=0,s=A.length;n<s;n++){const s=A[n];if(C(s)){const A=Q(t),n=i.get(s).__webglTexture;e.bindTexture(A,n),E(A),e.unbindTexture()}}},this.updateMultisampleRenderTarget=function(A){if(A.samples>0)if(!1===P(A)){const n=A.textures,s=A.width,a=A.height;let r=t.COLOR_BUFFER_BIT;const o=A.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,c=i.get(A),l=n.length>1;if(l)for(let A=0;A<n.length;A++)e.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+A,t.RENDERBUFFER,null),e.bindFramebuffer(t.FRAMEBUFFER,c.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+A,t.TEXTURE_2D,null,0);e.bindFramebuffer(t.READ_FRAMEBUFFER,c.__webglMultisampledFramebuffer);const I=A.texture.mipmaps;I&&I.length>0?e.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglFramebuffer[0]):e.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglFramebuffer);for(let e=0;e<n.length;e++){if(A.resolveDepthBuffer&&(A.depthBuffer&&(r|=t.DEPTH_BUFFER_BIT),A.stencilBuffer&&A.resolveStencilBuffer&&(r|=t.STENCIL_BUFFER_BIT)),l){t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,c.__webglColorRenderbuffer[e]);const A=i.get(n[e]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,A,0)}t.blitFramebuffer(0,0,s,a,0,0,s,a,r,t.NEAREST),!0===g&&(L.length=0,H.length=0,L.push(t.COLOR_ATTACHMENT0+e),A.depthBuffer&&!1===A.resolveDepthBuffer&&(L.push(o),H.push(o),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,H)),t.invalidateFramebuffer(t.READ_FRAMEBUFFER,L))}if(e.bindFramebuffer(t.READ_FRAMEBUFFER,null),e.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),l)for(let A=0;A<n.length;A++){e.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+A,t.RENDERBUFFER,c.__webglColorRenderbuffer[A]);const s=i.get(n[A]).__webglTexture;e.bindFramebuffer(t.FRAMEBUFFER,c.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+A,t.TEXTURE_2D,s,0)}e.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglMultisampledFramebuffer)}else if(A.depthBuffer&&!1===A.resolveDepthBuffer&&g){const e=A.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[e])}},this.setupDepthRenderbuffer=U,this.setupFrameBufferTexture=k,this.useMultisampledRTT=P}function bA(t,A){return{convert:function(e,i=n.jf0){let s;const a=n.ppV.getTransfer(i);if(e===n.OUM)return t.UNSIGNED_BYTE;if(e===n.Wew)return t.UNSIGNED_SHORT_4_4_4_4;if(e===n.gJ2)return t.UNSIGNED_SHORT_5_5_5_1;if(e===n.Dmk)return t.UNSIGNED_INT_5_9_9_9_REV;if(e===n.tJf)return t.BYTE;if(e===n.fBL)return t.SHORT;if(e===n.cHt)return t.UNSIGNED_SHORT;if(e===n.Yuy)return t.INT;if(e===n.bkx)return t.UNSIGNED_INT;if(e===n.RQf)return t.FLOAT;if(e===n.ix0)return t.HALF_FLOAT;if(e===n.wrO)return t.ALPHA;if(e===n.HIg)return t.RGB;if(e===n.GWd)return t.RGBA;if(e===n.zdS)return t.DEPTH_COMPONENT;if(e===n.dcC)return t.DEPTH_STENCIL;if(e===n.VT0)return t.RED;if(e===n.ZQM)return t.RED_INTEGER;if(e===n.paN)return t.RG;if(e===n.TkQ)return t.RG_INTEGER;if(e===n.c90)return t.RGBA_INTEGER;if(e===n.IE4||e===n.Nz6||e===n.jR7||e===n.BXX)if(a===n.KLL){if(s=A.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(e===n.IE4)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(e===n.Nz6)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(e===n.jR7)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(e===n.BXX)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=A.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(e===n.IE4)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===n.Nz6)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===n.jR7)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===n.BXX)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===n.k6Q||e===n.kTp||e===n.HXV||e===n.pBf){if(s=A.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(e===n.k6Q)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===n.kTp)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===n.HXV)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===n.pBf)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===n.CVz||e===n.Riy||e===n.KDk){if(s=A.get("WEBGL_compressed_texture_etc"),null===s)return null;if(e===n.CVz||e===n.Riy)return a===n.KLL?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(e===n.KDk)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(e===n.qa3||e===n.B_h||e===n.czI||e===n.rSH||e===n.Qrf||e===n.psI||e===n.a5J||e===n._QJ||e===n.uB5||e===n.lyL||e===n.bC7||e===n.y3Z||e===n.ojs||e===n.S$4){if(s=A.get("WEBGL_compressed_texture_astc"),null===s)return null;if(e===n.qa3)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(e===n.B_h)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(e===n.czI)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(e===n.rSH)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(e===n.Qrf)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(e===n.psI)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(e===n.a5J)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(e===n._QJ)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(e===n.uB5)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(e===n.lyL)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(e===n.bC7)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(e===n.y3Z)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(e===n.ojs)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(e===n.S$4)return a===n.KLL?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(e===n.Fn||e===n.H23||e===n.W9U){if(s=A.get("EXT_texture_compression_bptc"),null===s)return null;if(e===n.Fn)return a===n.KLL?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(e===n.H23)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(e===n.W9U)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(e===n.Kef||e===n.XG_||e===n.HO_||e===n.CWW){if(s=A.get("EXT_texture_compression_rgtc"),null===s)return null;if(e===n.Fn)return s.COMPRESSED_RED_RGTC1_EXT;if(e===n.XG_)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(e===n.HO_)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(e===n.CWW)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return e===n.V3x?t.UNSIGNED_INT_24_8:void 0!==t[e]?t[e]:null}}}class _A{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,A,e){if(null===this.texture){const i=new n.gPd;t.properties.get(i).__webglTexture=A.texture,A.depthNear===e.depthNear&&A.depthFar===e.depthFar||(this.depthNear=A.depthNear,this.depthFar=A.depthFar),this.texture=i}}getMesh(t){if(null!==this.texture&&null===this.mesh){const A=t.cameras[0].viewport,e=new n.BKk({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:A.z},depthHeight:{value:A.w}}});this.mesh=new n.eaF(new n.bdM(20,20),e)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class RA extends n.Qev{constructor(t,A){super();const e=this;let s=null,a=1,r=null,o="local-floor",g=1,c=null,l=null,I=null,h=null,u=null,B=null;const d=new _A,C=A.getContextAttributes();let E=null,Q=null;const p=[],f=[],m=new n.I9Y;let y=null;const w=new n.ubm;w.viewport=new n.IUQ;const x=new n.ubm;x.viewport=new n.IUQ;const S=[w,x],D=new n.nZQ;let v=null,M=null;function b(t){const A=f.indexOf(t.inputSource);if(-1===A)return;const e=p[A];void 0!==e&&(e.update(t.inputSource,t.frame,c||r),e.dispatchEvent({type:t.type,data:t.inputSource}))}function _(){s.removeEventListener("select",b),s.removeEventListener("selectstart",b),s.removeEventListener("selectend",b),s.removeEventListener("squeeze",b),s.removeEventListener("squeezestart",b),s.removeEventListener("squeezeend",b),s.removeEventListener("end",_),s.removeEventListener("inputsourceschange",R);for(let t=0;t<p.length;t++){const A=f[t];null!==A&&(f[t]=null,p[t].disconnect(A))}v=null,M=null,d.reset(),t.setRenderTarget(E),u=null,h=null,I=null,s=null,Q=null,G.stop(),e.isPresenting=!1,t.setPixelRatio(y),t.setSize(m.width,m.height,!1),e.dispatchEvent({type:"sessionend"})}function R(t){for(let A=0;A<t.removed.length;A++){const e=t.removed[A],n=f.indexOf(e);n>=0&&(f[n]=null,p[n].disconnect(e))}for(let A=0;A<t.added.length;A++){const e=t.added[A];let n=f.indexOf(e);if(-1===n){for(let t=0;t<p.length;t++){if(t>=f.length){f.push(e),n=t;break}if(null===f[t]){f[t]=e,n=t;break}}if(-1===n)break}const i=p[n];i&&i.connect(e)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let A=p[t];return void 0===A&&(A=new n.R3r,p[t]=A),A.getTargetRaySpace()},this.getControllerGrip=function(t){let A=p[t];return void 0===A&&(A=new n.R3r,p[t]=A),A.getGripSpace()},this.getHand=function(t){let A=p[t];return void 0===A&&(A=new n.R3r,p[t]=A),A.getHandSpace()},this.setFramebufferScaleFactor=function(t){a=t,!0===e.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===e.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||r},this.setReferenceSpace=function(t){c=t},this.getBaseLayer=function(){return null!==h?h:u},this.getBinding=function(){return I},this.getFrame=function(){return B},this.getSession=function(){return s},this.setSession=async function(i){if(s=i,null!==s){if(E=t.getRenderTarget(),s.addEventListener("select",b),s.addEventListener("selectstart",b),s.addEventListener("selectend",b),s.addEventListener("squeeze",b),s.addEventListener("squeezestart",b),s.addEventListener("squeezeend",b),s.addEventListener("end",_),s.addEventListener("inputsourceschange",R),!0!==C.xrCompatible&&await A.makeXRCompatible(),y=t.getPixelRatio(),t.getSize(m),"undefined"!=typeof XRWebGLBinding&&"createProjectionLayer"in XRWebGLBinding.prototype){let e=null,i=null,r=null;C.depth&&(r=C.stencil?A.DEPTH24_STENCIL8:A.DEPTH_COMPONENT24,e=C.stencil?n.dcC:n.zdS,i=C.stencil?n.V3x:n.bkx);const o={colorFormat:A.RGBA8,depthFormat:r,scaleFactor:a};I=new XRWebGLBinding(s,A),h=I.createProjectionLayer(o),s.updateRenderState({layers:[h]}),t.setPixelRatio(1),t.setSize(h.textureWidth,h.textureHeight,!1),Q=new n.nWS(h.textureWidth,h.textureHeight,{format:n.GWd,type:n.OUM,depthTexture:new n.VCu(h.textureWidth,h.textureHeight,i,void 0,void 0,void 0,void 0,void 0,void 0,e),stencilBuffer:C.stencil,colorSpace:t.outputColorSpace,samples:C.antialias?4:0,resolveDepthBuffer:!1===h.ignoreDepthValues,resolveStencilBuffer:!1===h.ignoreDepthValues})}else{const e={antialias:C.antialias,alpha:!0,depth:C.depth,stencil:C.stencil,framebufferScaleFactor:a};u=new XRWebGLLayer(s,A,e),s.updateRenderState({baseLayer:u}),t.setPixelRatio(1),t.setSize(u.framebufferWidth,u.framebufferHeight,!1),Q=new n.nWS(u.framebufferWidth,u.framebufferHeight,{format:n.GWd,type:n.OUM,colorSpace:t.outputColorSpace,stencilBuffer:C.stencil,resolveDepthBuffer:!1===u.ignoreDepthValues,resolveStencilBuffer:!1===u.ignoreDepthValues})}Q.isXRRenderTarget=!0,this.setFoveation(g),c=null,r=await s.requestReferenceSpace(o),G.setContext(s),G.start(),e.isPresenting=!0,e.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==s)return s.environmentBlendMode},this.getDepthTexture=function(){return d.getDepthTexture()};const F=new n.Pq0,N=new n.Pq0;function k(t,A){null===A?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(A.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===s)return;let A=t.near,e=t.far;null!==d.texture&&(d.depthNear>0&&(A=d.depthNear),d.depthFar>0&&(e=d.depthFar)),D.near=x.near=w.near=A,D.far=x.far=w.far=e,v===D.near&&M===D.far||(s.updateRenderState({depthNear:D.near,depthFar:D.far}),v=D.near,M=D.far),w.layers.mask=2|t.layers.mask,x.layers.mask=4|t.layers.mask,D.layers.mask=w.layers.mask|x.layers.mask;const i=t.parent,a=D.cameras;k(D,i);for(let t=0;t<a.length;t++)k(a[t],i);2===a.length?function(t,A,e){F.setFromMatrixPosition(A.matrixWorld),N.setFromMatrixPosition(e.matrixWorld);const n=F.distanceTo(N),i=A.projectionMatrix.elements,s=e.projectionMatrix.elements,a=i[14]/(i[10]-1),r=i[14]/(i[10]+1),o=(i[9]+1)/i[5],g=(i[9]-1)/i[5],c=(i[8]-1)/i[0],l=(s[8]+1)/s[0],I=a*c,h=a*l,u=n/(-c+l),B=u*-c;if(A.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(B),t.translateZ(u),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert(),-1===i[10])t.projectionMatrix.copy(A.projectionMatrix),t.projectionMatrixInverse.copy(A.projectionMatrixInverse);else{const A=a+u,e=r+u,i=I-B,s=h+(n-B),c=o*r/e*A,l=g*r/e*A;t.projectionMatrix.makePerspective(i,s,c,l,A,e),t.projectionMatrixInverse.copy(t.projectionMatrix).invert()}}(D,w,x):D.projectionMatrix.copy(w.projectionMatrix),function(t,A,e){null===e?t.matrix.copy(A.matrixWorld):(t.matrix.copy(e.matrixWorld),t.matrix.invert(),t.matrix.multiply(A.matrixWorld)),t.matrix.decompose(t.position,t.quaternion,t.scale),t.updateMatrixWorld(!0),t.projectionMatrix.copy(A.projectionMatrix),t.projectionMatrixInverse.copy(A.projectionMatrixInverse),t.isPerspectiveCamera&&(t.fov=2*n.a55*Math.atan(1/t.projectionMatrix.elements[5]),t.zoom=1)}(t,D,i)},this.getCamera=function(){return D},this.getFoveation=function(){if(null!==h||null!==u)return g},this.setFoveation=function(t){g=t,null!==h&&(h.fixedFoveation=t),null!==u&&void 0!==u.fixedFoveation&&(u.fixedFoveation=t)},this.hasDepthSensing=function(){return null!==d.texture},this.getDepthSensingMesh=function(){return d.getMesh(D)};let T=null;const G=new i;G.setAnimationLoop(function(A,i){if(l=i.getViewerPose(c||r),B=i,null!==l){const A=l.views;null!==u&&(t.setRenderTargetFramebuffer(Q,u.framebuffer),t.setRenderTarget(Q));let e=!1;A.length!==D.cameras.length&&(D.cameras.length=0,e=!0);for(let i=0;i<A.length;i++){const s=A[i];let a=null;if(null!==u)a=u.getViewport(s);else{const A=I.getViewSubImage(h,s);a=A.viewport,0===i&&(t.setRenderTargetTextures(Q,A.colorTexture,A.depthStencilTexture),t.setRenderTarget(Q))}let r=S[i];void 0===r&&(r=new n.ubm,r.layers.enable(i),r.viewport=new n.IUQ,S[i]=r),r.matrix.fromArray(s.transform.matrix),r.matrix.decompose(r.position,r.quaternion,r.scale),r.projectionMatrix.fromArray(s.projectionMatrix),r.projectionMatrixInverse.copy(r.projectionMatrix).invert(),r.viewport.set(a.x,a.y,a.width,a.height),0===i&&(D.matrix.copy(r.matrix),D.matrix.decompose(D.position,D.quaternion,D.scale)),!0===e&&D.cameras.push(r)}const i=s.enabledFeatures;if(i&&i.includes("depth-sensing")&&"gpu-optimized"==s.depthUsage&&I){const e=I.getDepthInformation(A[0]);e&&e.isValid&&e.texture&&d.init(t,e,s.renderState)}}for(let t=0;t<p.length;t++){const A=f[t],e=p[t];null!==A&&void 0!==e&&e.update(A,i,c||r)}T&&T(A,i),i.detectedPlanes&&e.dispatchEvent({type:"planesdetected",data:i}),B=null}),this.setAnimationLoop=function(t){T=t},this.dispose=function(){}}}const FA=new n.O9p,NA=new n.kn4;function kA(t,A){function e(t,A){!0===t.matrixAutoUpdate&&t.updateMatrix(),A.value.copy(t.matrix)}function i(t,i){t.opacity.value=i.opacity,i.color&&t.diffuse.value.copy(i.color),i.emissive&&t.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(t.map.value=i.map,e(i.map,t.mapTransform)),i.alphaMap&&(t.alphaMap.value=i.alphaMap,e(i.alphaMap,t.alphaMapTransform)),i.bumpMap&&(t.bumpMap.value=i.bumpMap,e(i.bumpMap,t.bumpMapTransform),t.bumpScale.value=i.bumpScale,i.side===n.hsX&&(t.bumpScale.value*=-1)),i.normalMap&&(t.normalMap.value=i.normalMap,e(i.normalMap,t.normalMapTransform),t.normalScale.value.copy(i.normalScale),i.side===n.hsX&&t.normalScale.value.negate()),i.displacementMap&&(t.displacementMap.value=i.displacementMap,e(i.displacementMap,t.displacementMapTransform),t.displacementScale.value=i.displacementScale,t.displacementBias.value=i.displacementBias),i.emissiveMap&&(t.emissiveMap.value=i.emissiveMap,e(i.emissiveMap,t.emissiveMapTransform)),i.specularMap&&(t.specularMap.value=i.specularMap,e(i.specularMap,t.specularMapTransform)),i.alphaTest>0&&(t.alphaTest.value=i.alphaTest);const s=A.get(i),a=s.envMap,r=s.envMapRotation;a&&(t.envMap.value=a,FA.copy(r),FA.x*=-1,FA.y*=-1,FA.z*=-1,a.isCubeTexture&&!1===a.isRenderTargetTexture&&(FA.y*=-1,FA.z*=-1),t.envMapRotation.value.setFromMatrix4(NA.makeRotationFromEuler(FA)),t.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,t.reflectivity.value=i.reflectivity,t.ior.value=i.ior,t.refractionRatio.value=i.refractionRatio),i.lightMap&&(t.lightMap.value=i.lightMap,t.lightMapIntensity.value=i.lightMapIntensity,e(i.lightMap,t.lightMapTransform)),i.aoMap&&(t.aoMap.value=i.aoMap,t.aoMapIntensity.value=i.aoMapIntensity,e(i.aoMap,t.aoMapTransform))}return{refreshFogUniforms:function(A,e){e.color.getRGB(A.fogColor.value,(0,n._Ut)(t)),e.isFog?(A.fogNear.value=e.near,A.fogFar.value=e.far):e.isFogExp2&&(A.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,s,a,r,o){s.isMeshBasicMaterial||s.isMeshLambertMaterial?i(t,s):s.isMeshToonMaterial?(i(t,s),function(t,A){A.gradientMap&&(t.gradientMap.value=A.gradientMap)}(t,s)):s.isMeshPhongMaterial?(i(t,s),function(t,A){t.specular.value.copy(A.specular),t.shininess.value=Math.max(A.shininess,1e-4)}(t,s)):s.isMeshStandardMaterial?(i(t,s),function(t,A){t.metalness.value=A.metalness,A.metalnessMap&&(t.metalnessMap.value=A.metalnessMap,e(A.metalnessMap,t.metalnessMapTransform)),t.roughness.value=A.roughness,A.roughnessMap&&(t.roughnessMap.value=A.roughnessMap,e(A.roughnessMap,t.roughnessMapTransform)),A.envMap&&(t.envMapIntensity.value=A.envMapIntensity)}(t,s),s.isMeshPhysicalMaterial&&function(t,A,i){t.ior.value=A.ior,A.sheen>0&&(t.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen),t.sheenRoughness.value=A.sheenRoughness,A.sheenColorMap&&(t.sheenColorMap.value=A.sheenColorMap,e(A.sheenColorMap,t.sheenColorMapTransform)),A.sheenRoughnessMap&&(t.sheenRoughnessMap.value=A.sheenRoughnessMap,e(A.sheenRoughnessMap,t.sheenRoughnessMapTransform))),A.clearcoat>0&&(t.clearcoat.value=A.clearcoat,t.clearcoatRoughness.value=A.clearcoatRoughness,A.clearcoatMap&&(t.clearcoatMap.value=A.clearcoatMap,e(A.clearcoatMap,t.clearcoatMapTransform)),A.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=A.clearcoatRoughnessMap,e(A.clearcoatRoughnessMap,t.clearcoatRoughnessMapTransform)),A.clearcoatNormalMap&&(t.clearcoatNormalMap.value=A.clearcoatNormalMap,e(A.clearcoatNormalMap,t.clearcoatNormalMapTransform),t.clearcoatNormalScale.value.copy(A.clearcoatNormalScale),A.side===n.hsX&&t.clearcoatNormalScale.value.negate())),A.dispersion>0&&(t.dispersion.value=A.dispersion),A.iridescence>0&&(t.iridescence.value=A.iridescence,t.iridescenceIOR.value=A.iridescenceIOR,t.iridescenceThicknessMinimum.value=A.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=A.iridescenceThicknessRange[1],A.iridescenceMap&&(t.iridescenceMap.value=A.iridescenceMap,e(A.iridescenceMap,t.iridescenceMapTransform)),A.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=A.iridescenceThicknessMap,e(A.iridescenceThicknessMap,t.iridescenceThicknessMapTransform))),A.transmission>0&&(t.transmission.value=A.transmission,t.transmissionSamplerMap.value=i.texture,t.transmissionSamplerSize.value.set(i.width,i.height),A.transmissionMap&&(t.transmissionMap.value=A.transmissionMap,e(A.transmissionMap,t.transmissionMapTransform)),t.thickness.value=A.thickness,A.thicknessMap&&(t.thicknessMap.value=A.thicknessMap,e(A.thicknessMap,t.thicknessMapTransform)),t.attenuationDistance.value=A.attenuationDistance,t.attenuationColor.value.copy(A.attenuationColor)),A.anisotropy>0&&(t.anisotropyVector.value.set(A.anisotropy*Math.cos(A.anisotropyRotation),A.anisotropy*Math.sin(A.anisotropyRotation)),A.anisotropyMap&&(t.anisotropyMap.value=A.anisotropyMap,e(A.anisotropyMap,t.anisotropyMapTransform))),t.specularIntensity.value=A.specularIntensity,t.specularColor.value.copy(A.specularColor),A.specularColorMap&&(t.specularColorMap.value=A.specularColorMap,e(A.specularColorMap,t.specularColorMapTransform)),A.specularIntensityMap&&(t.specularIntensityMap.value=A.specularIntensityMap,e(A.specularIntensityMap,t.specularIntensityMapTransform))}(t,s,o)):s.isMeshMatcapMaterial?(i(t,s),function(t,A){A.matcap&&(t.matcap.value=A.matcap)}(t,s)):s.isMeshDepthMaterial?i(t,s):s.isMeshDistanceMaterial?(i(t,s),function(t,e){const n=A.get(e).light;t.referencePosition.value.setFromMatrixPosition(n.matrixWorld),t.nearDistance.value=n.shadow.camera.near,t.farDistance.value=n.shadow.camera.far}(t,s)):s.isMeshNormalMaterial?i(t,s):s.isLineBasicMaterial?(function(t,A){t.diffuse.value.copy(A.color),t.opacity.value=A.opacity,A.map&&(t.map.value=A.map,e(A.map,t.mapTransform))}(t,s),s.isLineDashedMaterial&&function(t,A){t.dashSize.value=A.dashSize,t.totalSize.value=A.dashSize+A.gapSize,t.scale.value=A.scale}(t,s)):s.isPointsMaterial?function(t,A,n,i){t.diffuse.value.copy(A.color),t.opacity.value=A.opacity,t.size.value=A.size*n,t.scale.value=.5*i,A.map&&(t.map.value=A.map,e(A.map,t.uvTransform)),A.alphaMap&&(t.alphaMap.value=A.alphaMap,e(A.alphaMap,t.alphaMapTransform)),A.alphaTest>0&&(t.alphaTest.value=A.alphaTest)}(t,s,a,r):s.isSpriteMaterial?function(t,A){t.diffuse.value.copy(A.color),t.opacity.value=A.opacity,t.rotation.value=A.rotation,A.map&&(t.map.value=A.map,e(A.map,t.mapTransform)),A.alphaMap&&(t.alphaMap.value=A.alphaMap,e(A.alphaMap,t.alphaMapTransform)),A.alphaTest>0&&(t.alphaTest.value=A.alphaTest)}(t,s):s.isShadowMaterial?(t.color.value.copy(s.color),t.opacity.value=s.opacity):s.isShaderMaterial&&(s.uniformsNeedUpdate=!1)}}}function TA(t,A,e,n){let i={},s={},a=[];const r=t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);function o(t,A,e,n){const i=t.value,s=A+"_"+e;if(void 0===n[s])return n[s]="number"==typeof i||"boolean"==typeof i?i:i.clone(),!0;{const t=n[s];if("number"==typeof i||"boolean"==typeof i){if(t!==i)return n[s]=i,!0}else if(!1===t.equals(i))return t.copy(i),!0}return!1}function g(t){const A={boundary:0,storage:0};return"number"==typeof t||"boolean"==typeof t?(A.boundary=4,A.storage=4):t.isVector2?(A.boundary=8,A.storage=8):t.isVector3||t.isColor?(A.boundary=16,A.storage=12):t.isVector4?(A.boundary=16,A.storage=16):t.isMatrix3?(A.boundary=48,A.storage=48):t.isMatrix4?(A.boundary=64,A.storage=64):t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",t),A}function c(A){const e=A.target;e.removeEventListener("dispose",c);const n=a.indexOf(e.__bindingPointIndex);a.splice(n,1),t.deleteBuffer(i[e.id]),delete i[e.id],delete s[e.id]}return{bind:function(t,A){const e=A.program;n.uniformBlockBinding(t,e)},update:function(e,l){let I=i[e.id];void 0===I&&(function(t){const A=t.uniforms;let e=0;for(let t=0,n=A.length;t<n;t++){const n=Array.isArray(A[t])?A[t]:[A[t]];for(let t=0,A=n.length;t<A;t++){const A=n[t],i=Array.isArray(A.value)?A.value:[A.value];for(let t=0,n=i.length;t<n;t++){const n=g(i[t]),s=e%16,a=s%n.boundary,r=s+a;e+=a,0!==r&&16-r<n.storage&&(e+=16-r),A.__data=new Float32Array(n.storage/Float32Array.BYTES_PER_ELEMENT),A.__offset=e,e+=n.storage}}}const n=e%16;n>0&&(e+=16-n),t.__size=e,t.__cache={}}(e),I=function(A){const e=function(){for(let t=0;t<r;t++)if(-1===a.indexOf(t))return a.push(t),t;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();A.__bindingPointIndex=e;const n=t.createBuffer(),i=A.__size,s=A.usage;return t.bindBuffer(t.UNIFORM_BUFFER,n),t.bufferData(t.UNIFORM_BUFFER,i,s),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,e,n),n}(e),i[e.id]=I,e.addEventListener("dispose",c));const h=l.program;n.updateUBOMapping(e,h);const u=A.render.frame;s[e.id]!==u&&(function(A){const e=i[A.id],n=A.uniforms,s=A.__cache;t.bindBuffer(t.UNIFORM_BUFFER,e);for(let A=0,e=n.length;A<e;A++){const e=Array.isArray(n[A])?n[A]:[n[A]];for(let n=0,i=e.length;n<i;n++){const i=e[n];if(!0===o(i,A,n,s)){const A=i.__offset,e=Array.isArray(i.value)?i.value:[i.value];let n=0;for(let s=0;s<e.length;s++){const a=e[s],r=g(a);"number"==typeof a||"boolean"==typeof a?(i.__data[0]=a,t.bufferSubData(t.UNIFORM_BUFFER,A+n,i.__data)):a.isMatrix3?(i.__data[0]=a.elements[0],i.__data[1]=a.elements[1],i.__data[2]=a.elements[2],i.__data[3]=0,i.__data[4]=a.elements[3],i.__data[5]=a.elements[4],i.__data[6]=a.elements[5],i.__data[7]=0,i.__data[8]=a.elements[6],i.__data[9]=a.elements[7],i.__data[10]=a.elements[8],i.__data[11]=0):(a.toArray(i.__data,n),n+=r.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,A,i.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}(e),s[e.id]=u)},dispose:function(){for(const A in i)t.deleteBuffer(i[A]);a=[],i={},s={}}}}class GA{constructor(t={}){const{canvas:A=(0,n.lPF)(),context:e=null,depth:a=!0,stencil:r=!1,alpha:o=!1,antialias:g=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:l=!1,powerPreference:E="default",failIfMajorPerformanceCaveat:Q=!1,reverseDepthBuffer:p=!1}=t;let f;if(this.isWebGLRenderer=!0,null!==e){if("undefined"!=typeof WebGLRenderingContext&&e instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");f=e.getContextAttributes().alpha}else f=o;const m=new Uint32Array(4),y=new Int32Array(4);let w=null,x=null;const S=[],D=[];this.domElement=A,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=n.y_p,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const v=this;let M=!1;this._outputColorSpace=n.er$;let b=0,_=0,R=null,F=-1,Y=null;const P=new n.IUQ,J=new n.IUQ;let q=null;const z=new n.Q1f(0);let O=0,K=A.width,V=A.height,W=1,j=null,Z=null;const X=new n.IUQ(0,0,K,V),$=new n.IUQ(0,0,K,V);let tt=!1;const At=new n.PPD;let et=!1,nt=!1;const it=new n.kn4,st=new n.kn4,at=new n.Pq0,rt=new n.IUQ,ot={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let gt=!1;function ct(){return null===R?W:1}let lt,It,ht,ut,Bt,dt,Ct,Et,Qt,pt,ft,mt,yt,wt,xt,St,Dt,vt,Mt,bt,_t,Rt,Ft,Nt,kt=e;function Tt(t,e){return A.getContext(t,e)}try{const t={alpha:!0,depth:a,stencil:r,antialias:g,premultipliedAlpha:c,preserveDrawingBuffer:l,powerPreference:E,failIfMajorPerformanceCaveat:Q};if("setAttribute"in A&&A.setAttribute("data-engine",`three.js r${n.sPf}`),A.addEventListener("webglcontextlost",Lt,!1),A.addEventListener("webglcontextrestored",Ht,!1),A.addEventListener("webglcontextcreationerror",Yt,!1),null===kt){const A="webgl2";if(kt=Tt(A,t),null===kt)throw Tt(A)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function Gt(){lt=new k(kt),lt.init(),Rt=new bA(kt,lt),It=new B(kt,lt,t,Rt),ht=new vA(kt,lt),It.reverseDepthBuffer&&p&&ht.buffers.depth.setReversed(!0),ut=new U(kt),Bt=new BA,dt=new MA(kt,lt,ht,Bt,It,Rt,ut),Ct=new C(v),Et=new N(v),Qt=new s(kt),Ft=new h(kt,Qt),pt=new T(kt,Qt,ut,Ft),ft=new H(kt,pt,Qt,ut),Mt=new L(kt,It,dt),St=new d(Bt),mt=new uA(v,Ct,Et,lt,It,Ft,St),yt=new kA(v,Bt),wt=new QA,xt=new xA(lt),vt=new I(v,Ct,Et,ht,ft,f,c),Dt=new SA(v,ft,It),Nt=new TA(kt,ut,It,ht),bt=new u(kt,lt,ut),_t=new G(kt,lt,ut),ut.programs=mt.programs,v.capabilities=It,v.extensions=lt,v.properties=Bt,v.renderLists=wt,v.shadowMap=Dt,v.state=ht,v.info=ut}Gt();const Ut=new RA(v,kt);function Lt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),M=!0}function Ht(){console.log("THREE.WebGLRenderer: Context Restored."),M=!1;const t=ut.autoReset,A=Dt.enabled,e=Dt.autoUpdate,n=Dt.needsUpdate,i=Dt.type;Gt(),ut.autoReset=t,Dt.enabled=A,Dt.autoUpdate=e,Dt.needsUpdate=n,Dt.type=i}function Yt(t){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",t.statusMessage)}function Pt(t){const A=t.target;A.removeEventListener("dispose",Pt),function(t){(function(t){const A=Bt.get(t).programs;void 0!==A&&(A.forEach(function(t){mt.releaseProgram(t)}),t.isShaderMaterial&&mt.releaseShaderCache(t))})(t),Bt.remove(t)}(A)}function Jt(t,A,e){!0===t.transparent&&t.side===n.$EB&&!1===t.forceSinglePass?(t.side=n.hsX,t.needsUpdate=!0,tA(t,A,e),t.side=n.hB5,t.needsUpdate=!0,tA(t,A,e),t.side=n.$EB):tA(t,A,e)}this.xr=Ut,this.getContext=function(){return kt},this.getContextAttributes=function(){return kt.getContextAttributes()},this.forceContextLoss=function(){const t=lt.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=lt.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return W},this.setPixelRatio=function(t){void 0!==t&&(W=t,this.setSize(K,V,!1))},this.getSize=function(t){return t.set(K,V)},this.setSize=function(t,e,n=!0){Ut.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(K=t,V=e,A.width=Math.floor(t*W),A.height=Math.floor(e*W),!0===n&&(A.style.width=t+"px",A.style.height=e+"px"),this.setViewport(0,0,t,e))},this.getDrawingBufferSize=function(t){return t.set(K*W,V*W).floor()},this.setDrawingBufferSize=function(t,e,n){K=t,V=e,W=n,A.width=Math.floor(t*n),A.height=Math.floor(e*n),this.setViewport(0,0,t,e)},this.getCurrentViewport=function(t){return t.copy(P)},this.getViewport=function(t){return t.copy(X)},this.setViewport=function(t,A,e,n){t.isVector4?X.set(t.x,t.y,t.z,t.w):X.set(t,A,e,n),ht.viewport(P.copy(X).multiplyScalar(W).round())},this.getScissor=function(t){return t.copy($)},this.setScissor=function(t,A,e,n){t.isVector4?$.set(t.x,t.y,t.z,t.w):$.set(t,A,e,n),ht.scissor(J.copy($).multiplyScalar(W).round())},this.getScissorTest=function(){return tt},this.setScissorTest=function(t){ht.setScissorTest(tt=t)},this.setOpaqueSort=function(t){j=t},this.setTransparentSort=function(t){Z=t},this.getClearColor=function(t){return t.copy(vt.getClearColor())},this.setClearColor=function(){vt.setClearColor(...arguments)},this.getClearAlpha=function(){return vt.getClearAlpha()},this.setClearAlpha=function(){vt.setClearAlpha(...arguments)},this.clear=function(t=!0,A=!0,e=!0){let i=0;if(t){let t=!1;if(null!==R){const A=R.texture.format;t=A===n.c90||A===n.TkQ||A===n.ZQM}if(t){const t=R.texture.type,A=t===n.OUM||t===n.bkx||t===n.cHt||t===n.V3x||t===n.Wew||t===n.gJ2,e=vt.getClearColor(),i=vt.getClearAlpha(),s=e.r,a=e.g,r=e.b;A?(m[0]=s,m[1]=a,m[2]=r,m[3]=i,kt.clearBufferuiv(kt.COLOR,0,m)):(y[0]=s,y[1]=a,y[2]=r,y[3]=i,kt.clearBufferiv(kt.COLOR,0,y))}else i|=kt.COLOR_BUFFER_BIT}A&&(i|=kt.DEPTH_BUFFER_BIT),e&&(i|=kt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),kt.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){A.removeEventListener("webglcontextlost",Lt,!1),A.removeEventListener("webglcontextrestored",Ht,!1),A.removeEventListener("webglcontextcreationerror",Yt,!1),vt.dispose(),wt.dispose(),xt.dispose(),Bt.dispose(),Ct.dispose(),Et.dispose(),ft.dispose(),Ft.dispose(),Nt.dispose(),mt.dispose(),Ut.dispose(),Ut.removeEventListener("sessionstart",Ot),Ut.removeEventListener("sessionend",Kt),Vt.stop()},this.renderBufferDirect=function(t,A,e,i,s,a){null===A&&(A=ot);const r=s.isMesh&&s.matrixWorld.determinant()<0,o=function(t,A,e,i,s){!0!==A.isScene&&(A=ot),dt.resetTextureUnits();const a=A.fog,r=i.isMeshStandardMaterial?A.environment:null,o=null===R?v.outputColorSpace:!0===R.isXRRenderTarget?R.texture.colorSpace:n.Zr2,g=(i.isMeshStandardMaterial?Et:Ct).get(i.envMap||r),c=!0===i.vertexColors&&!!e.attributes.color&&4===e.attributes.color.itemSize,l=!!e.attributes.tangent&&(!!i.normalMap||i.anisotropy>0),I=!!e.morphAttributes.position,h=!!e.morphAttributes.normal,u=!!e.morphAttributes.color;let B=n.y_p;i.toneMapped&&(null!==R&&!0!==R.isXRRenderTarget||(B=v.toneMapping));const d=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,C=void 0!==d?d.length:0,E=Bt.get(i),Q=x.state.lights;if(!0===et&&(!0===nt||t!==Y)){const A=t===Y&&i.id===F;St.setState(i,t,A)}let p=!1;i.version===E.__version?E.needsLights&&E.lightsStateVersion!==Q.state.version||E.outputColorSpace!==o||s.isBatchedMesh&&!1===E.batching?p=!0:s.isBatchedMesh||!0!==E.batching?s.isBatchedMesh&&!0===E.batchingColor&&null===s.colorTexture||s.isBatchedMesh&&!1===E.batchingColor&&null!==s.colorTexture||s.isInstancedMesh&&!1===E.instancing?p=!0:s.isInstancedMesh||!0!==E.instancing?s.isSkinnedMesh&&!1===E.skinning?p=!0:s.isSkinnedMesh||!0!==E.skinning?s.isInstancedMesh&&!0===E.instancingColor&&null===s.instanceColor||s.isInstancedMesh&&!1===E.instancingColor&&null!==s.instanceColor||s.isInstancedMesh&&!0===E.instancingMorph&&null===s.morphTexture||s.isInstancedMesh&&!1===E.instancingMorph&&null!==s.morphTexture||E.envMap!==g||!0===i.fog&&E.fog!==a?p=!0:void 0===E.numClippingPlanes||E.numClippingPlanes===St.numPlanes&&E.numIntersection===St.numIntersection?(E.vertexAlphas!==c||E.vertexTangents!==l||E.morphTargets!==I||E.morphNormals!==h||E.morphColors!==u||E.toneMapping!==B||E.morphTargetsCount!==C)&&(p=!0):p=!0:p=!0:p=!0:p=!0:(p=!0,E.__version=i.version);let f=E.currentProgram;!0===p&&(f=tA(i,A,s));let m=!1,y=!1,w=!1;const S=f.getUniforms(),D=E.uniforms;if(ht.useProgram(f.program)&&(m=!0,y=!0,w=!0),i.id!==F&&(F=i.id,y=!0),m||Y!==t){ht.buffers.depth.getReversed()?(it.copy(t.projectionMatrix),(0,n.xiE)(it),(0,n.Mmk)(it),S.setValue(kt,"projectionMatrix",it)):S.setValue(kt,"projectionMatrix",t.projectionMatrix),S.setValue(kt,"viewMatrix",t.matrixWorldInverse);const A=S.map.cameraPosition;void 0!==A&&A.setValue(kt,at.setFromMatrixPosition(t.matrixWorld)),It.logarithmicDepthBuffer&&S.setValue(kt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),(i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial)&&S.setValue(kt,"isOrthographic",!0===t.isOrthographicCamera),Y!==t&&(Y=t,y=!0,w=!0)}if(s.isSkinnedMesh){S.setOptional(kt,s,"bindMatrix"),S.setOptional(kt,s,"bindMatrixInverse");const t=s.skeleton;t&&(null===t.boneTexture&&t.computeBoneTexture(),S.setValue(kt,"boneTexture",t.boneTexture,dt))}s.isBatchedMesh&&(S.setOptional(kt,s,"batchingTexture"),S.setValue(kt,"batchingTexture",s._matricesTexture,dt),S.setOptional(kt,s,"batchingIdTexture"),S.setValue(kt,"batchingIdTexture",s._indirectTexture,dt),S.setOptional(kt,s,"batchingColorTexture"),null!==s._colorsTexture&&S.setValue(kt,"batchingColorTexture",s._colorsTexture,dt));const M=e.morphAttributes;var b,_;if(void 0===M.position&&void 0===M.normal&&void 0===M.color||Mt.update(s,e,f),(y||E.receiveShadow!==s.receiveShadow)&&(E.receiveShadow=s.receiveShadow,S.setValue(kt,"receiveShadow",s.receiveShadow)),i.isMeshGouraudMaterial&&null!==i.envMap&&(D.envMap.value=g,D.flipEnvMap.value=g.isCubeTexture&&!1===g.isRenderTargetTexture?-1:1),i.isMeshStandardMaterial&&null===i.envMap&&null!==A.environment&&(D.envMapIntensity.value=A.environmentIntensity),y&&(S.setValue(kt,"toneMappingExposure",v.toneMappingExposure),E.needsLights&&(_=w,(b=D).ambientLightColor.needsUpdate=_,b.lightProbe.needsUpdate=_,b.directionalLights.needsUpdate=_,b.directionalLightShadows.needsUpdate=_,b.pointLights.needsUpdate=_,b.pointLightShadows.needsUpdate=_,b.spotLights.needsUpdate=_,b.spotLightShadows.needsUpdate=_,b.rectAreaLights.needsUpdate=_,b.hemisphereLights.needsUpdate=_),a&&!0===i.fog&&yt.refreshFogUniforms(D,a),yt.refreshMaterialUniforms(D,i,W,V,x.state.transmissionRenderTarget[t.id]),zt.upload(kt,AA(E),D,dt)),i.isShaderMaterial&&!0===i.uniformsNeedUpdate&&(zt.upload(kt,AA(E),D,dt),i.uniformsNeedUpdate=!1),i.isSpriteMaterial&&S.setValue(kt,"center",s.center),S.setValue(kt,"modelViewMatrix",s.modelViewMatrix),S.setValue(kt,"normalMatrix",s.normalMatrix),S.setValue(kt,"modelMatrix",s.matrixWorld),i.isShaderMaterial||i.isRawShaderMaterial){const t=i.uniformsGroups;for(let A=0,e=t.length;A<e;A++){const e=t[A];Nt.update(e,f),Nt.bind(e,f)}}return f}(t,A,e,i,s);ht.setMaterial(i,r);let g=e.index,c=1;if(!0===i.wireframe){if(g=pt.getWireframeAttribute(e),void 0===g)return;c=2}const l=e.drawRange,I=e.attributes.position;let h=l.start*c,u=(l.start+l.count)*c;null!==a&&(h=Math.max(h,a.start*c),u=Math.min(u,(a.start+a.count)*c)),null!==g?(h=Math.max(h,0),u=Math.min(u,g.count)):null!=I&&(h=Math.max(h,0),u=Math.min(u,I.count));const B=u-h;if(B<0||B===1/0)return;let d;Ft.setup(s,i,o,e,g);let C=bt;if(null!==g&&(d=Qt.get(g),C=_t,C.setIndex(d)),s.isMesh)!0===i.wireframe?(ht.setLineWidth(i.wireframeLinewidth*ct()),C.setMode(kt.LINES)):C.setMode(kt.TRIANGLES);else if(s.isLine){let t=i.linewidth;void 0===t&&(t=1),ht.setLineWidth(t*ct()),s.isLineSegments?C.setMode(kt.LINES):s.isLineLoop?C.setMode(kt.LINE_LOOP):C.setMode(kt.LINE_STRIP)}else s.isPoints?C.setMode(kt.POINTS):s.isSprite&&C.setMode(kt.TRIANGLES);if(s.isBatchedMesh)if(null!==s._multiDrawInstances)(0,n.mcG)("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),C.renderMultiDrawInstances(s._multiDrawStarts,s._multiDrawCounts,s._multiDrawCount,s._multiDrawInstances);else if(lt.get("WEBGL_multi_draw"))C.renderMultiDraw(s._multiDrawStarts,s._multiDrawCounts,s._multiDrawCount);else{const t=s._multiDrawStarts,A=s._multiDrawCounts,e=s._multiDrawCount,n=g?Qt.get(g).bytesPerElement:1,a=Bt.get(i).currentProgram.getUniforms();for(let i=0;i<e;i++)a.setValue(kt,"_gl_DrawID",i),C.render(t[i]/n,A[i])}else if(s.isInstancedMesh)C.renderInstances(h,B,s.count);else if(e.isInstancedBufferGeometry){const t=void 0!==e._maxInstanceCount?e._maxInstanceCount:1/0,A=Math.min(e.instanceCount,t);C.renderInstances(h,B,A)}else C.render(h,B)},this.compile=function(t,A,e=null){null===e&&(e=t),x=xt.get(e),x.init(A),D.push(x),e.traverseVisible(function(t){t.isLight&&t.layers.test(A.layers)&&(x.pushLight(t),t.castShadow&&x.pushShadow(t))}),t!==e&&t.traverseVisible(function(t){t.isLight&&t.layers.test(A.layers)&&(x.pushLight(t),t.castShadow&&x.pushShadow(t))}),x.setupLights();const n=new Set;return t.traverse(function(t){if(!(t.isMesh||t.isPoints||t.isLine||t.isSprite))return;const A=t.material;if(A)if(Array.isArray(A))for(let i=0;i<A.length;i++){const s=A[i];Jt(s,e,t),n.add(s)}else Jt(A,e,t),n.add(A)}),x=D.pop(),n},this.compileAsync=function(t,A,e=null){const n=this.compile(t,A,e);return new Promise(A=>{function e(){n.forEach(function(t){Bt.get(t).currentProgram.isReady()&&n.delete(t)}),0!==n.size?setTimeout(e,10):A(t)}null!==lt.get("KHR_parallel_shader_compile")?e():setTimeout(e,10)})};let qt=null;function Ot(){Vt.stop()}function Kt(){Vt.start()}const Vt=new i;function Wt(t,A,e,n){if(!1===t.visible)return;if(t.layers.test(A.layers))if(t.isGroup)e=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(A);else if(t.isLight)x.pushLight(t),t.castShadow&&x.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||At.intersectsSprite(t)){n&&rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(st);const A=ft.update(t),i=t.material;i.visible&&w.push(t,A,i,e,rt.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||At.intersectsObject(t))){const A=ft.update(t),i=t.material;if(n&&(void 0!==t.boundingSphere?(null===t.boundingSphere&&t.computeBoundingSphere(),rt.copy(t.boundingSphere.center)):(null===A.boundingSphere&&A.computeBoundingSphere(),rt.copy(A.boundingSphere.center)),rt.applyMatrix4(t.matrixWorld).applyMatrix4(st)),Array.isArray(i)){const n=A.groups;for(let s=0,a=n.length;s<a;s++){const a=n[s],r=i[a.materialIndex];r&&r.visible&&w.push(t,A,r,e,rt.z,a)}}else i.visible&&w.push(t,A,i,e,rt.z,null)}const i=t.children;for(let t=0,s=i.length;t<s;t++)Wt(i[t],A,e,n)}function jt(t,A,e,n){const i=t.opaque,s=t.transmissive,a=t.transparent;x.setupLightsView(e),!0===et&&St.setGlobalState(v.clippingPlanes,e),n&&ht.viewport(P.copy(n)),i.length>0&&Xt(i,A,e),s.length>0&&Xt(s,A,e),a.length>0&&Xt(a,A,e),ht.buffers.depth.setTest(!0),ht.buffers.depth.setMask(!0),ht.buffers.color.setMask(!0),ht.setPolygonOffset(!1)}function Zt(t,A,e,i){if(null!==(!0===e.isScene?e.overrideMaterial:null))return;void 0===x.state.transmissionRenderTarget[i.id]&&(x.state.transmissionRenderTarget[i.id]=new n.nWS(1,1,{generateMipmaps:!0,type:lt.has("EXT_color_buffer_half_float")||lt.has("EXT_color_buffer_float")?n.ix0:n.OUM,minFilter:n.$_I,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:n.ppV.workingColorSpace}));const s=x.state.transmissionRenderTarget[i.id],a=i.viewport||P;s.setSize(a.z*v.transmissionResolutionScale,a.w*v.transmissionResolutionScale);const o=v.getRenderTarget(),g=v.getActiveCubeFace(),c=v.getActiveMipmapLevel();v.setRenderTarget(s),v.getClearColor(z),O=v.getClearAlpha(),O<1&&v.setClearColor(16777215,.5),v.clear(),gt&&vt.render(e);const l=v.toneMapping;v.toneMapping=n.y_p;const I=i.viewport;if(void 0!==i.viewport&&(i.viewport=void 0),x.setupLightsView(i),!0===et&&St.setGlobalState(v.clippingPlanes,i),Xt(t,e,i),dt.updateMultisampleRenderTarget(s),dt.updateRenderTargetMipmap(s),!1===lt.has("WEBGL_multisampled_render_to_texture")){let t=!1;for(let s=0,a=A.length;s<a;s++){const a=A[s],r=a.object,o=a.geometry,g=a.material,c=a.group;if(g.side===n.$EB&&r.layers.test(i.layers)){const A=g.side;g.side=n.hsX,g.needsUpdate=!0,$t(r,e,i,o,g,c),g.side=A,g.needsUpdate=!0,t=!0}}!0===t&&(dt.updateMultisampleRenderTarget(s),dt.updateRenderTargetMipmap(s))}v.setRenderTarget(o,g,c),v.setClearColor(z,O),void 0!==I&&(i.viewport=I),v.toneMapping=l}function Xt(t,A,e){const n=!0===A.isScene?A.overrideMaterial:null;for(let i=0,s=t.length;i<s;i++){const s=t[i],a=s.object,r=s.geometry,o=s.group;let g=s.material;!0===g.allowOverride&&null!==n&&(g=n),a.layers.test(e.layers)&&$t(a,A,e,r,g,o)}}function $t(t,A,e,i,s,a){t.onBeforeRender(v,A,e,i,s,a),t.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),s.onBeforeRender(v,A,e,i,t,a),!0===s.transparent&&s.side===n.$EB&&!1===s.forceSinglePass?(s.side=n.hsX,s.needsUpdate=!0,v.renderBufferDirect(e,A,i,s,t,a),s.side=n.hB5,s.needsUpdate=!0,v.renderBufferDirect(e,A,i,s,t,a),s.side=n.$EB):v.renderBufferDirect(e,A,i,s,t,a),t.onAfterRender(v,A,e,i,s,a)}function tA(t,A,e){!0!==A.isScene&&(A=ot);const n=Bt.get(t),i=x.state.lights,s=x.state.shadowsArray,a=i.state.version,r=mt.getParameters(t,i.state,s,A,e),o=mt.getProgramCacheKey(r);let g=n.programs;n.environment=t.isMeshStandardMaterial?A.environment:null,n.fog=A.fog,n.envMap=(t.isMeshStandardMaterial?Et:Ct).get(t.envMap||n.environment),n.envMapRotation=null!==n.environment&&null===t.envMap?A.environmentRotation:t.envMapRotation,void 0===g&&(t.addEventListener("dispose",Pt),g=new Map,n.programs=g);let c=g.get(o);if(void 0!==c){if(n.currentProgram===c&&n.lightsStateVersion===a)return eA(t,r),c}else r.uniforms=mt.getUniforms(t),t.onBeforeCompile(r,v),c=mt.acquireProgram(r,o),g.set(o,c),n.uniforms=r.uniforms;const l=n.uniforms;return(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(l.clippingPlanes=St.uniform),eA(t,r),n.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),n.lightsStateVersion=a,n.needsLights&&(l.ambientLightColor.value=i.state.ambient,l.lightProbe.value=i.state.probe,l.directionalLights.value=i.state.directional,l.directionalLightShadows.value=i.state.directionalShadow,l.spotLights.value=i.state.spot,l.spotLightShadows.value=i.state.spotShadow,l.rectAreaLights.value=i.state.rectArea,l.ltc_1.value=i.state.rectAreaLTC1,l.ltc_2.value=i.state.rectAreaLTC2,l.pointLights.value=i.state.point,l.pointLightShadows.value=i.state.pointShadow,l.hemisphereLights.value=i.state.hemi,l.directionalShadowMap.value=i.state.directionalShadowMap,l.directionalShadowMatrix.value=i.state.directionalShadowMatrix,l.spotShadowMap.value=i.state.spotShadowMap,l.spotLightMatrix.value=i.state.spotLightMatrix,l.spotLightMap.value=i.state.spotLightMap,l.pointShadowMap.value=i.state.pointShadowMap,l.pointShadowMatrix.value=i.state.pointShadowMatrix),n.currentProgram=c,n.uniformsList=null,c}function AA(t){if(null===t.uniformsList){const A=t.currentProgram.getUniforms();t.uniformsList=zt.seqWithValue(A.seq,t.uniforms)}return t.uniformsList}function eA(t,A){const e=Bt.get(t);e.outputColorSpace=A.outputColorSpace,e.batching=A.batching,e.batchingColor=A.batchingColor,e.instancing=A.instancing,e.instancingColor=A.instancingColor,e.instancingMorph=A.instancingMorph,e.skinning=A.skinning,e.morphTargets=A.morphTargets,e.morphNormals=A.morphNormals,e.morphColors=A.morphColors,e.morphTargetsCount=A.morphTargetsCount,e.numClippingPlanes=A.numClippingPlanes,e.numIntersection=A.numClipIntersection,e.vertexAlphas=A.vertexAlphas,e.vertexTangents=A.vertexTangents,e.toneMapping=A.toneMapping}Vt.setAnimationLoop(function(t){qt&&qt(t)}),"undefined"!=typeof self&&Vt.setContext(self),this.setAnimationLoop=function(t){qt=t,Ut.setAnimationLoop(t),null===t?Vt.stop():Vt.start()},Ut.addEventListener("sessionstart",Ot),Ut.addEventListener("sessionend",Kt),this.render=function(t,A){if(void 0!==A&&!0!==A.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===M)return;if(!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===A.parent&&!0===A.matrixWorldAutoUpdate&&A.updateMatrixWorld(),!0===Ut.enabled&&!0===Ut.isPresenting&&(!0===Ut.cameraAutoUpdate&&Ut.updateCamera(A),A=Ut.getCamera()),!0===t.isScene&&t.onBeforeRender(v,t,A,R),x=xt.get(t,D.length),x.init(A),D.push(x),st.multiplyMatrices(A.projectionMatrix,A.matrixWorldInverse),At.setFromProjectionMatrix(st),nt=this.localClippingEnabled,et=St.init(this.clippingPlanes,nt),w=wt.get(t,S.length),w.init(),S.push(w),!0===Ut.enabled&&!0===Ut.isPresenting){const t=v.xr.getDepthSensingMesh();null!==t&&Wt(t,A,-1/0,v.sortObjects)}Wt(t,A,0,v.sortObjects),w.finish(),!0===v.sortObjects&&w.sort(j,Z),gt=!1===Ut.enabled||!1===Ut.isPresenting||!1===Ut.hasDepthSensing(),gt&&vt.addToRenderList(w,t),this.info.render.frame++,!0===et&&St.beginShadows();const e=x.state.shadowsArray;Dt.render(e,t,A),!0===et&&St.endShadows(),!0===this.info.autoReset&&this.info.reset();const n=w.opaque,i=w.transmissive;if(x.setupLights(),A.isArrayCamera){const e=A.cameras;if(i.length>0)for(let A=0,s=e.length;A<s;A++)Zt(n,i,t,e[A]);gt&&vt.render(t);for(let A=0,n=e.length;A<n;A++){const n=e[A];jt(w,t,n,n.viewport)}}else i.length>0&&Zt(n,i,t,A),gt&&vt.render(t),jt(w,t,A);null!==R&&0===_&&(dt.updateMultisampleRenderTarget(R),dt.updateRenderTargetMipmap(R)),!0===t.isScene&&t.onAfterRender(v,t,A),Ft.resetDefaultState(),F=-1,Y=null,D.pop(),D.length>0?(x=D[D.length-1],!0===et&&St.setGlobalState(v.clippingPlanes,x.state.camera)):x=null,S.pop(),w=S.length>0?S[S.length-1]:null},this.getActiveCubeFace=function(){return b},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return R},this.setRenderTargetTextures=function(t,A,e){const n=Bt.get(t);n.__autoAllocateDepthBuffer=!1===t.resolveDepthBuffer,!1===n.__autoAllocateDepthBuffer&&(n.__useRenderToTexture=!1),Bt.get(t.texture).__webglTexture=A,Bt.get(t.depthTexture).__webglTexture=n.__autoAllocateDepthBuffer?void 0:e,n.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(t,A){const e=Bt.get(t);e.__webglFramebuffer=A,e.__useDefaultFramebuffer=void 0===A};const nA=kt.createFramebuffer();this.setRenderTarget=function(t,A=0,e=0){R=t,b=A,_=e;let n=!0,i=null,s=!1,a=!1;if(t){const r=Bt.get(t);if(void 0!==r.__useDefaultFramebuffer)ht.bindFramebuffer(kt.FRAMEBUFFER,null),n=!1;else if(void 0===r.__webglFramebuffer)dt.setupRenderTarget(t);else if(r.__hasExternalTextures)dt.rebindTextures(t,Bt.get(t.texture).__webglTexture,Bt.get(t.depthTexture).__webglTexture);else if(t.depthBuffer){const A=t.depthTexture;if(r.__boundDepthTexture!==A){if(null!==A&&Bt.has(A)&&(t.width!==A.image.width||t.height!==A.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");dt.setupDepthRenderbuffer(t)}}const o=t.texture;(o.isData3DTexture||o.isDataArrayTexture||o.isCompressedArrayTexture)&&(a=!0);const g=Bt.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=Array.isArray(g[A])?g[A][e]:g[A],s=!0):i=t.samples>0&&!1===dt.useMultisampledRTT(t)?Bt.get(t).__webglMultisampledFramebuffer:Array.isArray(g)?g[e]:g,P.copy(t.viewport),J.copy(t.scissor),q=t.scissorTest}else P.copy(X).multiplyScalar(W).floor(),J.copy($).multiplyScalar(W).floor(),q=tt;if(0!==e&&(i=nA),ht.bindFramebuffer(kt.FRAMEBUFFER,i)&&n&&ht.drawBuffers(t,i),ht.viewport(P),ht.scissor(J),ht.setScissorTest(q),s){const n=Bt.get(t.texture);kt.framebufferTexture2D(kt.FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_CUBE_MAP_POSITIVE_X+A,n.__webglTexture,e)}else if(a){const n=Bt.get(t.texture),i=A;kt.framebufferTextureLayer(kt.FRAMEBUFFER,kt.COLOR_ATTACHMENT0,n.__webglTexture,e,i)}else if(null!==t&&0!==e){const A=Bt.get(t.texture);kt.framebufferTexture2D(kt.FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_2D,A.__webglTexture,e)}F=-1},this.readRenderTargetPixels=function(t,A,e,n,i,s,a,r=0){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=Bt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){ht.bindFramebuffer(kt.FRAMEBUFFER,o);try{const a=t.textures[r],o=a.format,g=a.type;if(!It.textureFormatReadable(o))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!It.textureTypeReadable(g))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");A>=0&&A<=t.width-n&&e>=0&&e<=t.height-i&&(t.textures.length>1&&kt.readBuffer(kt.COLOR_ATTACHMENT0+r),kt.readPixels(A,e,n,i,Rt.convert(o),Rt.convert(g),s))}finally{const t=null!==R?Bt.get(R).__webglFramebuffer:null;ht.bindFramebuffer(kt.FRAMEBUFFER,t)}}},this.readRenderTargetPixelsAsync=async function(t,A,e,i,s,a,r,o=0){if(!t||!t.isWebGLRenderTarget)throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let g=Bt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==r&&(g=g[r]),g){if(A>=0&&A<=t.width-i&&e>=0&&e<=t.height-s){ht.bindFramebuffer(kt.FRAMEBUFFER,g);const r=t.textures[o],c=r.format,l=r.type;if(!It.textureFormatReadable(c))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!It.textureTypeReadable(l))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const I=kt.createBuffer();kt.bindBuffer(kt.PIXEL_PACK_BUFFER,I),kt.bufferData(kt.PIXEL_PACK_BUFFER,a.byteLength,kt.STREAM_READ),t.textures.length>1&&kt.readBuffer(kt.COLOR_ATTACHMENT0+o),kt.readPixels(A,e,i,s,Rt.convert(c),Rt.convert(l),0);const h=null!==R?Bt.get(R).__webglFramebuffer:null;ht.bindFramebuffer(kt.FRAMEBUFFER,h);const u=kt.fenceSync(kt.SYNC_GPU_COMMANDS_COMPLETE,0);return kt.flush(),await(0,n.jej)(kt,u,4),kt.bindBuffer(kt.PIXEL_PACK_BUFFER,I),kt.getBufferSubData(kt.PIXEL_PACK_BUFFER,0,a),kt.deleteBuffer(I),kt.deleteSync(u),a}throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(t,A=null,e=0){const n=Math.pow(2,-e),i=Math.floor(t.image.width*n),s=Math.floor(t.image.height*n),a=null!==A?A.x:0,r=null!==A?A.y:0;dt.setTexture2D(t,0),kt.copyTexSubImage2D(kt.TEXTURE_2D,e,0,0,a,r,i,s),ht.unbindTexture()};const iA=kt.createFramebuffer(),sA=kt.createFramebuffer();this.copyTextureToTexture=function(t,A,e=null,i=null,s=0,a=null){let r,o,g,c,l,I,h,u,B;null===a&&(0!==s?((0,n.mcG)("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),a=s,s=0):a=0);const d=t.isCompressedTexture?t.mipmaps[a]:t.image;if(null!==e)r=e.max.x-e.min.x,o=e.max.y-e.min.y,g=e.isBox3?e.max.z-e.min.z:1,c=e.min.x,l=e.min.y,I=e.isBox3?e.min.z:0;else{const A=Math.pow(2,-s);r=Math.floor(d.width*A),o=Math.floor(d.height*A),g=t.isDataArrayTexture?d.depth:t.isData3DTexture?Math.floor(d.depth*A):1,c=0,l=0,I=0}null!==i?(h=i.x,u=i.y,B=i.z):(h=0,u=0,B=0);const C=Rt.convert(A.format),E=Rt.convert(A.type);let Q;A.isData3DTexture?(dt.setTexture3D(A,0),Q=kt.TEXTURE_3D):A.isDataArrayTexture||A.isCompressedArrayTexture?(dt.setTexture2DArray(A,0),Q=kt.TEXTURE_2D_ARRAY):(dt.setTexture2D(A,0),Q=kt.TEXTURE_2D),kt.pixelStorei(kt.UNPACK_FLIP_Y_WEBGL,A.flipY),kt.pixelStorei(kt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,A.premultiplyAlpha),kt.pixelStorei(kt.UNPACK_ALIGNMENT,A.unpackAlignment);const p=kt.getParameter(kt.UNPACK_ROW_LENGTH),f=kt.getParameter(kt.UNPACK_IMAGE_HEIGHT),m=kt.getParameter(kt.UNPACK_SKIP_PIXELS),y=kt.getParameter(kt.UNPACK_SKIP_ROWS),w=kt.getParameter(kt.UNPACK_SKIP_IMAGES);kt.pixelStorei(kt.UNPACK_ROW_LENGTH,d.width),kt.pixelStorei(kt.UNPACK_IMAGE_HEIGHT,d.height),kt.pixelStorei(kt.UNPACK_SKIP_PIXELS,c),kt.pixelStorei(kt.UNPACK_SKIP_ROWS,l),kt.pixelStorei(kt.UNPACK_SKIP_IMAGES,I);const x=t.isDataArrayTexture||t.isData3DTexture,S=A.isDataArrayTexture||A.isData3DTexture;if(t.isDepthTexture){const e=Bt.get(t),n=Bt.get(A),i=Bt.get(e.__renderTarget),d=Bt.get(n.__renderTarget);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,i.__webglFramebuffer),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,d.__webglFramebuffer);for(let e=0;e<g;e++)x&&(kt.framebufferTextureLayer(kt.READ_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,Bt.get(t).__webglTexture,s,I+e),kt.framebufferTextureLayer(kt.DRAW_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,Bt.get(A).__webglTexture,a,B+e)),kt.blitFramebuffer(c,l,r,o,h,u,r,o,kt.DEPTH_BUFFER_BIT,kt.NEAREST);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,null),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,null)}else if(0!==s||t.isRenderTargetTexture||Bt.has(t)){const e=Bt.get(t),n=Bt.get(A);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,iA),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,sA);for(let t=0;t<g;t++)x?kt.framebufferTextureLayer(kt.READ_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,e.__webglTexture,s,I+t):kt.framebufferTexture2D(kt.READ_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_2D,e.__webglTexture,s),S?kt.framebufferTextureLayer(kt.DRAW_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,n.__webglTexture,a,B+t):kt.framebufferTexture2D(kt.DRAW_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_2D,n.__webglTexture,a),0!==s?kt.blitFramebuffer(c,l,r,o,h,u,r,o,kt.COLOR_BUFFER_BIT,kt.NEAREST):S?kt.copyTexSubImage3D(Q,a,h,u,B+t,c,l,r,o):kt.copyTexSubImage2D(Q,a,h,u,c,l,r,o);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,null),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,null)}else S?t.isDataTexture||t.isData3DTexture?kt.texSubImage3D(Q,a,h,u,B,r,o,g,C,E,d.data):A.isCompressedArrayTexture?kt.compressedTexSubImage3D(Q,a,h,u,B,r,o,g,C,d.data):kt.texSubImage3D(Q,a,h,u,B,r,o,g,C,E,d):t.isDataTexture?kt.texSubImage2D(kt.TEXTURE_2D,a,h,u,r,o,C,E,d.data):t.isCompressedTexture?kt.compressedTexSubImage2D(kt.TEXTURE_2D,a,h,u,d.width,d.height,C,d.data):kt.texSubImage2D(kt.TEXTURE_2D,a,h,u,r,o,C,E,d);kt.pixelStorei(kt.UNPACK_ROW_LENGTH,p),kt.pixelStorei(kt.UNPACK_IMAGE_HEIGHT,f),kt.pixelStorei(kt.UNPACK_SKIP_PIXELS,m),kt.pixelStorei(kt.UNPACK_SKIP_ROWS,y),kt.pixelStorei(kt.UNPACK_SKIP_IMAGES,w),0===a&&A.generateMipmaps&&kt.generateMipmap(Q),ht.unbindTexture()},this.copyTextureToTexture3D=function(t,A,e=null,i=null,s=0){return(0,n.mcG)('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(t,A,e,i,s)},this.initRenderTarget=function(t){void 0===Bt.get(t).__webglFramebuffer&&dt.setupRenderTarget(t)},this.initTexture=function(t){t.isCubeTexture?dt.setTextureCube(t,0):t.isData3DTexture?dt.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?dt.setTexture2DArray(t,0):dt.setTexture2D(t,0),ht.unbindTexture()},this.resetState=function(){b=0,_=0,R=null,ht.reset(),Ft.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return n.TdN}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const A=this.getContext();A.drawingBufferColorSpace=n.ppV._getDrawingBufferColorSpace(t),A.unpackColorSpace=n.ppV._getUnpackColorSpace()}}},493:(t,A,e)=>{function n(t,A){(null==A||A>t.length)&&(A=t.length);for(var e=0,n=Array(A);e<A;e++)n[e]=t[e];return n}function i(t){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i(t)}function s(t,A){if(!(t instanceof A))throw new TypeError("Cannot call a class as a function")}function a(t,A){for(var e=0;e<A.length;e++){var n=A[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,o(n.key),n)}}function r(t,A,e){return A&&a(t.prototype,A),e&&a(t,e),Object.defineProperty(t,"prototype",{writable:!1}),t}function o(t){var A=function(t){if("object"!=i(t)||!t)return t;var A=t[Symbol.toPrimitive];if(void 0!==A){var e=A.call(t,"string");if("object"!=i(e))return e;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==i(A)?A:A+""}Object.defineProperty(A,"__esModule",{value:!0}),A.Controls=void 0;var g=e(294),c={i:function(t){return t*Math.PI/180},o:function(t){return 180*t/Math.PI}},l=function(){return r(function t(){s(this,t),this.version=0,this.x=this.createAccessor(function(t){return t.splatMesh.position},"x",0),this.y=this.createAccessor(function(t){return t.splatMesh.position},"y",0),this.z=this.createAccessor(function(t){return t.splatMesh.position},"z",0),this.rx=this.createAccessor(function(t){return t.splatMesh.rotation},"x",0,c),this.ry=this.createAccessor(function(t){return t.splatMesh.rotation},"y",0,c),this.rz=this.createAccessor(function(t){return t.splatMesh.rotation},"z",0,c)},[{key:"name",get:function(){return this.intake?this.intake.name:""}},{key:"createAccessor",value:function(t,A,e,n){var i=this;return Object.defineProperty({value:e},"value",{get:function(){return i.intake?n?n.o(t(i.intake)[A]):t(i.intake)[A]:e},set:function(e){if(i.intake){var s=t(i.intake),a=n?n.i(e):e;s[A]!==a&&(s[A]=a,i.version++)}}})}}])}();function I(t,A,e,n,i){return Object.defineProperty({value:n},"value",{get:function(){var s=t();if(!s)return n;var a=A(s)[e];return null==a?n:i&&i.o?i.o(a):a},set:function(n){var s=t();if(s){var a=A(s),r=i&&i.i?i.i(n):n;a[e]!==r&&(a[e]=r,i&&i.c&&i.c(r))}}})}function h(t,A,e,i,s,a){var r,o={},g={},c=function(t,A){var e="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!e){if(Array.isArray(t)||(e=function(t,A){if(t){if("string"==typeof t)return n(t,A);var e={}.toString.call(t).slice(8,-1);return"Object"===e&&t.constructor&&(e=t.constructor.name),"Map"===e||"Set"===e?Array.from(t):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?n(t,A):void 0}}(t))||A&&t&&"number"==typeof t.length){e&&(t=e);var i=0,s=function(){};return{s,n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,r=!0,o=!1;return{s:function(){e=e.call(t)},n:function(){var t=e.next();return r=t.done,t},e:function(t){o=!0,a=t},f:function(){try{r||null==e.return||e.return()}finally{if(o)throw a}}}}(i);try{for(c.s();!(r=c.n()).done;){var l=r.value;o[l]=e;var h={};a&&Object.assign(h,a),s&&(h.c=function(e){a&&a.c&&a.c(e);var n=t();if(!n)return o;s(A(n))}),g[l]=I(t,A,l,e,h)}}catch(t){c.e(t)}finally{c.f()}return g}var u=function(){return r(function t(A){var e=this;s(this,t),this.service=A,this.isEditing=!1,this.intakeId="",this.environment=I(function(){return e.intake},function(t){return t},"environment","",{c:function(t){return e.service.viewer.transitionToEnvironment(t)}}),this.environmentRotation=I(function(){return e.intake},function(t){return t},"environmentRotation",0,{c:function(t){return e.service.viewer.environmentRotation=t}}),this.environmentHeight=I(function(){return e.intake},function(t){return t},"environmentHeight",0,{c:function(t){return e.service.viewer.environmentHeight=t}}),this.minCameraDistance=I(function(){return e.intake},function(t){return t},"minCameraDistance",0,{c:function(t){var A=e.service.viewer.orbitControls;A.minDistance=t,A.object.position.sub(A.target).normalize().multiplyScalar(t).add(A.target)}}),this.maxCameraDistance=I(function(){return e.intake},function(t){return t},"maxCameraDistance",0,{c:function(t){var A=e.service.viewer.orbitControls;A.maxDistance=t,A.object.position.sub(A.target).normalize().multiplyScalar(t).add(A.target)}}),this.useMinCameraDistance=this.useCameraDistanceRange.bind(this,"minCameraDistance"),this.useMaxCameraDistance=this.useCameraDistanceRange.bind(this,"maxCameraDistance"),this.initialCameraPosition=h(function(){return e.intake},function(t){return t.initialCameraPosition},0,["x","y","z"],function(t){return e.service.viewer.orbitControls.object.position.copy(t)}),this.initialCameraTarget=h(function(){return e.intake},function(t){return t.initialCameraTarget},0,["x","y","z"],function(t){return e.service.viewer.orbitControls.target.copy(t)})},[{key:"getOrCreateIntake",value:function(t){if(!g.struct.SPLATS[t])throw new RangeError("splat ".concat(t," not found"));var A=g.slideshowConfig.SPLATS[t];if(void 0===A)A=g.slideshowConfig.SPLATS[t]={id:crypto.randomUUID(),environment:"",environmentRotation:0,environmentHeight:10,minCameraDistance:0,maxCameraDistance:1,initialCameraPosition:{x:0,y:0,z:0},initialCameraTarget:{x:0,y:0,z:0}};else{var e=A.initialCameraPosition;Array.isArray(e)&&(A.initialCameraPosition={x:e[0],y:e[1],z:e[2]}),e=A.initialCameraTarget,Array.isArray(e)&&(A.initialCameraTarget={x:e[0],y:e[1],z:e[2]})}return A}},{key:"useCameraDistanceRange",value:function(t){var A=this.service.viewer.orbitControls;this[t].value=A.object.position.distanceTo(A.target)}},{key:"useCameraPosition",value:function(){if(this.intake){var t=this.intake.initialCameraPosition,A=this.service.viewer.orbitControls.object.position;t.x=A.x,t.y=A.y,t.z=A.z}}},{key:"useCameraTarget",value:function(){if(this.intake){var t=this.intake.initialCameraTarget,A=this.service.viewer.orbitControls.target;t.x=A.x,t.y=A.y,t.z=A.z}}}])}(),B=function(){return r(function t(){s(this,t),this.localStorageKey="splat-gallery-struct",this.splatUrl="",this.splatName=""},[{key:"_serialize",value:function(){return{struct:g.struct,slideshowConfig:g.slideshowConfig}}},{key:"serialize",value:function(){return JSON.stringify(this._serialize())}},{key:"addSplatSource",value:function(){if(""!==this.splatName&&""!==this.splatUrl){var t=crypto.randomUUID();g.struct.SPLAT_SOURCES[t]={id:t,name:this.splatName,url:this.splatUrl},g.struct.SPLATS[t]={id:t,source:t,matrix:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],transitionType:"instant"}}}},{key:"merge",value:function(t){if("object"!==i(t)||null===t)throw new RangeError("object must be an object");var A=!1,e=t;"struct"in e&&"slideshowConfig"in e&&(Object.assign(g.struct.APP,e.struct.APP),Object.assign(g.struct.SPLATS,e.struct.SPLATS),Object.assign(g.struct.SPLAT_SOURCES,e.struct.SPLAT_SOURCES),Object.assign(g.struct.SCENE,e.struct.SCENE),Object.assign(g.slideshowConfig,e.slideshowConfig),A=!0);var n=t;"SPLATS"in n&&"APP"in n&&(Object.assign(g.struct.APP,n.APP),Object.assign(g.struct.SPLATS,n.SPLATS),Object.assign(g.struct.SPLAT_SOURCES,n.SPLAT_SOURCES),Object.assign(g.struct.SCENE,n.SCENE),A=!0),A?this.serialize():console.warn("object is not a valid save state",t)}},{key:"saveToLocalStorage",value:function(){var t=this.serialize();null===t?localStorage.removeItem(this.localStorageKey):localStorage.setItem(this.localStorageKey,t)}},{key:"loadFromLocalStorage",value:function(){var t=localStorage.getItem(this.localStorageKey);t&&this.merge(JSON.parse(t))}},{key:"generateDownload",value:function(){var t=JSON.stringify(this._serialize(),void 0,2),A=new Blob([t],{type:"application/json"}),e=URL.createObjectURL(A),n=document.createElement("a");n.href=e,n.download="config.json",n.click(),URL.revokeObjectURL(e)}}])}(),d=function(){return r(function t(A){s(this,t),this.viewer=A,this.activeSplat=new l,this.io=new B},[{key:"slideshowSplat",get:function(){return this._slideshowSplat||(this._slideshowSplat=new u({viewer:this.viewer})),this._slideshowSplat}}])}();A.Controls=d},509:function(t,A,e){function n(){var t,A,e="function"==typeof Symbol?Symbol:{},s=e.iterator||"@@iterator",a=e.toStringTag||"@@toStringTag";function r(e,n,s,a){var r=n&&n.prototype instanceof g?n:g,c=Object.create(r.prototype);return i(c,"_invoke",function(e,n,i){var s,a,r,g=0,c=i||[],l=!1,I={p:0,n:0,v:t,a:h,f:h.bind(t,4),d:function(A,e){return s=A,a=0,r=t,I.n=e,o}};function h(e,n){for(a=e,r=n,A=0;!l&&g&&!i&&A<c.length;A++){var i,s=c[A],h=I.p,u=s[2];e>3?(i=u===n)&&(r=s[(a=s[4])?5:(a=3,3)],s[4]=s[5]=t):s[0]<=h&&((i=e<2&&h<s[1])?(a=0,I.v=n,I.n=s[1]):h<u&&(i=e<3||s[0]>n||n>u)&&(s[4]=e,s[5]=n,I.n=u,a=0))}if(i||e>1)return o;throw l=!0,n}return function(i,c,u){if(g>1)throw TypeError("Generator is already running");for(l&&1===c&&h(c,u),a=c,r=u;(A=a<2?t:r)||!l;){s||(a?a<3?(a>1&&(I.n=-1),h(a,r)):I.n=r:I.v=r);try{if(g=2,s){if(a||(i="next"),A=s[i]){if(!(A=A.call(s,r)))throw TypeError("iterator result is not an object");if(!A.done)return A;r=A.value,a<2&&(a=0)}else 1===a&&(A=s.return)&&A.call(s),a<2&&(r=TypeError("The iterator does not provide a '"+i+"' method"),a=1);s=t}else if((A=(l=I.n<0)?r:e.call(n,I))!==o)break}catch(A){s=t,a=1,r=A}finally{g=1}}return{value:A,done:l}}}(e,s,a),!0),c}var o={};function g(){}function c(){}function l(){}A=Object.getPrototypeOf;var I=[][s]?A(A([][s]())):(i(A={},s,function(){return this}),A),h=l.prototype=g.prototype=Object.create(I);function u(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,l):(t.__proto__=l,i(t,a,"GeneratorFunction")),t.prototype=Object.create(h),t}return c.prototype=l,i(h,"constructor",l),i(l,"constructor",c),c.displayName="GeneratorFunction",i(l,a,"GeneratorFunction"),i(h),i(h,a,"Generator"),i(h,s,function(){return this}),i(h,"toString",function(){return"[object Generator]"}),(n=function(){return{w:r,m:u}})()}function i(t,A,e,n){var s=Object.defineProperty;try{s({},"",{})}catch(t){s=0}i=function(t,A,e,n){function a(A,e){i(t,A,function(t){return this._invoke(A,e,t)})}A?s?s(t,A,{value:e,enumerable:!n,configurable:!n,writable:!n}):t[A]=e:(a("next",0),a("throw",1),a("return",2))},i(t,A,e,n)}var s=this&&this.__createBinding||(Object.create?function(t,A,e,n){void 0===n&&(n=e);var i=Object.getOwnPropertyDescriptor(A,e);i&&!("get"in i?!A.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return A[e]}}),Object.defineProperty(t,n,i)}:function(t,A,e,n){void 0===n&&(n=e),t[n]=A[e]}),a=this&&this.__exportStar||function(t,A){for(var e in t)"default"===e||Object.prototype.hasOwnProperty.call(A,e)||s(A,t,e)},r=this&&this.__awaiter||function(t,A,e,n){return new(e||(e=Promise))(function(i,s){function a(t){try{o(n.next(t))}catch(t){s(t)}}function r(t){try{o(n.throw(t))}catch(t){s(t)}}function o(t){var A;t.done?i(t.value):(A=t.value,A instanceof e?A:new e(function(t){t(A)})).then(a,r)}o((n=n.apply(t,A||[])).next())})};Object.defineProperty(A,"__esModule",{value:!0}),A.load=function(){return r(this,void 0,void 0,n().m(function t(){return n().w(function(t){for(;;)switch(t.n){case 0:return t.n=1,(0,g.loadGUIModule)();case 1:o=t.v;case 2:return t.a(2)}},t)}))},A.init=function(t){var A=t.title;return new o.GUI({title:A,width:320})};var o,g=e(563);a(e(563),A)},563:(t,A)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.loadGUIModule=function(){return void 0===n&&(n=s(i).then(function(t){return e=t})),n},A.addCustomController=function(t,A,n,i){if(void 0===e)throw new Error("GUI module not loaded");var s=new e.Controller(t,A,n,"no-class");return A instanceof HTMLElement&&s.$widget.appendChild(A),void 0!==i?s.name(i):s.$name.remove(),s.updateDisplay=function(){return s},s};var e,n,i="https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm",s=new Function("url","return import(url);")},641:function(t,A,e){function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}function i(t,A){(null==A||A>t.length)&&(A=t.length);for(var e=0,n=Array(A);e<A;e++)n[e]=t[e];return n}function s(t,A){for(var e=0;e<A.length;e++){var n=A[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,a(n.key),n)}}function a(t){var A=function(t){if("object"!=n(t)||!t)return t;var A=t[Symbol.toPrimitive];if(void 0!==A){var e=A.call(t,"string");if("object"!=n(e))return e;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==n(A)?A:A+""}var r,o=this&&this.__createBinding||(Object.create?function(t,A,e,n){void 0===n&&(n=e);var i=Object.getOwnPropertyDescriptor(A,e);i&&!("get"in i?!A.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return A[e]}}),Object.defineProperty(t,n,i)}:function(t,A,e,n){void 0===n&&(n=e),t[n]=A[e]}),g=this&&this.__setModuleDefault||(Object.create?function(t,A){Object.defineProperty(t,"default",{enumerable:!0,value:A})}:function(t,A){t.default=A}),c=this&&this.__importStar||(r=function(t){return r=Object.getOwnPropertyNames||function(t){var A=[];for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(A[A.length]=e);return A},r(t)},function(t){if(t&&t.__esModule)return t;var A={};if(null!=t)for(var e=r(t),n=0;n<e.length;n++)"default"!==e[n]&&o(A,t,e[n]);return g(A,t),A});Object.defineProperty(A,"__esModule",{value:!0}),A.Viewer=void 0;var l=c(e(451)),I=e(970),h=e(932),u=function(){return t=function t(A){var e=this;!function(t,A){if(!(t instanceof A))throw new TypeError("Cannot call a class as a function")}(this,t),this._config=A,this.renderSize=new l.Vector2,this.cameraVersion=0,this._objects=new Map,this._debug=this._config.isEditor?{gridHelper:new l.GridHelper(1,6,"#999","#000")}:null,this._renderer=new l.WebGLRenderer({antialias:!0}),this._renderer.getSize(this._renderSize=new l.Vector2),this._renderer.setClearColor(0,1),this._scene=new l.Scene,this._camera=new l.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,1e3),this._camera.position.set(0,1,2),this._scene.add(this._camera),this._scene.background=new l.Color("#222"),this._debug&&this._scene.add(this._debug.gridHelper),this._controls=new I.OrbitControls(this._camera,this._renderer.domElement),this._controls.minDistance=2*this._camera.near,this._controls.maxDistance=.8*this._camera.far,this._controls.enabled=!0,this._controls.addEventListener("change",function(){return e.cameraVersion++})},A=[{key:"domElement",get:function(){return this._renderer.domElement}},{key:"cameraPosition",get:function(){return this._camera.position}},{key:"cameraTarget",get:function(){return this._controls.target}},{key:"rendererRef",get:function(){return this._renderer}},{key:"orbitControls",get:function(){return this._controls}},{key:"setSceneObject",value:function(t,A){var e=this._objects.get(t);e===A||null===A&&void 0===e||(void 0!==e&&this._scene.remove(e),null===A?this._objects.delete(t):(this._objects.set(t,A),this._scene.add(A)))}},{key:"update",value:function(){this._controls.update(),(Math.abs(this._renderSize.x-this.renderSize.x)>.001||Math.abs(this._renderSize.y-this.renderSize.y)>.001)&&(this._renderer.setSize(this.renderSize.x,this.renderSize.y),this._renderSize.copy(this.renderSize)),this._renderer.render(this._scene,this._camera)}},{key:"fitToScene",value:function(){var t,A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=new l.Vector3,n=new l.Vector3(1/0,1/0,1/0),s=new l.Vector3(-1/0,-1/0,-1/0),a=new l.Vector3,r=Array.from(this._objects.values()).map(function(t){return t.position}),o=function(t,A){var e="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!e){if(Array.isArray(t)||(e=function(t,A){if(t){if("string"==typeof t)return i(t,A);var e={}.toString.call(t).slice(8,-1);return"Object"===e&&t.constructor&&(e=t.constructor.name),"Map"===e||"Set"===e?Array.from(t):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?i(t,A):void 0}}(t))||A&&t&&"number"==typeof t.length){e&&(t=e);var n=0,s=function(){};return{s,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,r=!0,o=!1;return{s:function(){e=e.call(t)},n:function(){var t=e.next();return r=t.done,t},e:function(t){o=!0,a=t},f:function(){try{r||null==e.return||e.return()}finally{if(o)throw a}}}}(r);try{for(o.s();!(t=o.n()).done;){var g=t.value;g.x<n.x&&(n.x=g.x),g.y<n.y&&(n.y=g.y),g.z<n.z&&(n.z=g.z),g.x>s.x&&(s.x=g.x),g.y>s.y&&(s.y=g.y),g.z>s.z&&(s.z=g.z),Math.abs(g.x)>a.x&&(a.x=Math.abs(g.x)),Math.abs(g.y)>a.y&&(a.y=Math.abs(g.y)),Math.abs(g.z)>a.z&&(a.z=Math.abs(g.z)),e.add(g)}}catch(t){o.e(t)}finally{o.f()}e.divideScalar(r.length);var c=s.clone().sub(n);if(this._debug){this._debug.gridHelper.position.copy(e);var I=Math.max(c.x,c.y,c.z)*A;this._debug.gridHelper.scale.setScalar(I),this._debug.gridHelper.position.setScalar(0),this._debug.gridHelper.scale.setScalar(2*a.length()*A)}}},{key:"transitionToEnvironment",value:function(t){var A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t!==this._environment&&(this._environment=t,void 0!==this._groundedSkybox&&(this._scene.remove(this._groundedSkybox),this._groundedSkybox.geometry.dispose(),this._groundedSkybox.material.dispose(),this._groundedSkybox=void 0),this._scene.environment=null,t)){var e=(new l.TextureLoader).load(t);e.colorSpace=l.SRGBColorSpace,e.mapping=l.EquirectangularReflectionMapping,this._groundedSkybox=new h.GroundedSkybox(e,10,100),this._groundedSkybox.rotateY(A),this._scene.add(this._groundedSkybox),this._scene.environment=e}}},{key:"environmentRotation",get:function(){var t,A;return null!==(A=null===(t=this._groundedSkybox)||void 0===t?void 0:t.rotation.y)&&void 0!==A?A:0},set:function(t){var A;null===(A=this._groundedSkybox)||void 0===A||A.rotateY(t)}},{key:"environmentHeight",get:function(){var t,A;return null!==(A=null===(t=this._groundedSkybox)||void 0===t?void 0:t.height)&&void 0!==A?A:0},set:function(t){this._groundedSkybox&&(this._groundedSkybox.height=t)}}],A&&s(t.prototype,A),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,A}();A.Viewer=u},932:function(t,A,e){function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}function i(t,A){for(var e=0;e<A.length;e++){var n=A[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,s(n.key),n)}}function s(t){var A=function(t){if("object"!=n(t)||!t)return t;var A=t[Symbol.toPrimitive];if(void 0!==A){var e=A.call(t,"string");if("object"!=n(e))return e;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==n(A)?A:A+""}function a(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(t){}return(a=function(){return!!t})()}function r(t){return r=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},r(t)}function o(t,A){return o=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,A){return t.__proto__=A,t},o(t,A)}var g,c=this&&this.__createBinding||(Object.create?function(t,A,e,n){void 0===n&&(n=e);var i=Object.getOwnPropertyDescriptor(A,e);i&&!("get"in i?!A.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return A[e]}}),Object.defineProperty(t,n,i)}:function(t,A,e,n){void 0===n&&(n=e),t[n]=A[e]}),l=this&&this.__setModuleDefault||(Object.create?function(t,A){Object.defineProperty(t,"default",{enumerable:!0,value:A})}:function(t,A){t.default=A}),I=this&&this.__importStar||(g=function(t){return g=Object.getOwnPropertyNames||function(t){var A=[];for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(A[A.length]=e);return A},g(t)},function(t){if(t&&t.__esModule)return t;var A={};if(null!=t)for(var e=g(t),n=0;n<e.length;n++)"default"!==e[n]&&c(A,t,e[n]);return l(A,t),A});Object.defineProperty(A,"__esModule",{value:!0}),A.GroundedSkybox=void 0;var h=I(e(451)),u=function(t){function A(t,e,i){var s,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:128;!function(t,A){if(!(t instanceof A))throw new TypeError("Cannot call a class as a function")}(this,A);var g=new h.SphereGeometry(i,2*o,o);return g.scale(1,1,-1),(s=function(t,A,e){return A=r(A),function(t,A){if(A&&("object"==n(A)||"function"==typeof A))return A;if(void 0!==A)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,a()?Reflect.construct(A,e||[],r(t).constructor):A.apply(t,e))}(this,A,[g,new h.MeshBasicMaterial({map:t,depthWrite:!1})]))._templatePosition=g.getAttribute("position").clone(),s._height=e,s.groundGeometry(),s}return function(t,A){if("function"!=typeof A&&null!==A)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(A&&A.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),A&&o(t,A)}(A,t),e=A,(s=[{key:"groundGeometry",value:function(){for(var t=this._templatePosition,A=this.geometry.getAttribute("position"),e=new h.Vector3,n=this._height,i=0;i<t.count;++i){if(e.fromBufferAttribute(t,i),e.y<0){var s=3*-n/2,a=e.y<s?-n/e.y:1-e.y*e.y/(3*s*s);e.multiplyScalar(a)}e.toArray(A.array,3*i)}A.needsUpdate=!0,this.position.set(0,n-.01,0)}},{key:"height",get:function(){return this._height},set:function(t){this._height=t,this.groundGeometry()}}])&&i(e.prototype,s),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,s}(h.Mesh);A.GroundedSkybox=u},933:t=>{t.exports="data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSANQQJ0QQQQsAELCwJAAkACQAJAAkBBwM7AACgCAEUEQEHAzsAAQX82AgBBzM7AACgCACIEIAtJBEAgCyAEIgBrIgVBxM7AACgCACAAa0sEQEHEzsAAIAAgBUECQQIQTEHMzsAAKAIAIQALQcjOwAAoAgAiAyAAQQF0aiEHIAVBAk8EQCAHIARBf3MgC2pBAXQQVxogACALakEBdCAEQQF0ayADakECayEHIAAgBWpBAWshAAsgB0EAOwEAQczOwAAgAEEBajYCAAtB2M7AACgCACIEIAtJBEAgCyAEIgBrIgVB0M7AACgCACAAa0sEQEHQzsAAIAAgBUEEQQQQTEHYzsAAKAIAIQALQdTOwAAoAgAiAyAAQQJ0aiEHIAVBAk8EQCAHIARBf3MgC2pBAnQQVxogACALakECdCAEQQJ0ayADakEEayEHIAAgBWpBAWshAAsgB0EANgIAQdjOwAAgAEEBajYCAAtB5M7AACgCACIEQYD4AU0EQEGB+AEgBCIAayIDQdzOwAAoAgAgAGtLBEBB3M7AACAAIANBBEEEEExB5M7AACgCACEAC0HgzsAAKAIAIgcgAEECdCIFaiEDIARBgPgBRwR/IANBgOAHIARBAnQiA2sQVxogACAEa0GA+AFqIQAgBSADayAHakGA4AdqBSADC0EANgIAQeTOwAAgAEEBajYCAAsgCEEUaigCACUBQQAgBhALIQEQMyIAIAEmASAIIAA2AhxBzM7AACgCACIAIAZJDQFByM7AACgCACEFIwBBIGsiACQAIAAgCEEcaiIDKAIAEMoBIgQ2AgAgACAGNgIEIAQgBkcNBRCeASIHEJUBIgQlARABIQEQMyIJIAEmASAEQYQBTwRAIAQQWgsgCSUBIAMoAgAlASAFQQF2EAIgCUGEAU8EQCAJEFoLIAdBhAFPBEAgBxBaCyAAQSBqJAAgCEEIaiEJQQAhACMAQUBqIgokAAJAAkACfwJAIAZBzM7AACgCACIETQRAQcjOwAAoAgAhBEHkzsAAQQA2AgBB3M7AACgCAEGA+AFNBEBB3M7AAEEAQYH4AUEEQQQQTEHkzsAAKAIAIQALQeDOwAAoAgAiCyAAQQJ0IgVqQYDgBxBXQeTOwAAgAEGB+AFqIg02AgBBgOAHakEANgIAAkAgBgRAIAZBAXQhDiAEIQADQCAALwEAIgNBgPgBSQRAIAMgDU8NAyALIANBAnRqIgMgAygCAEEBajYCAAsgAEECaiEAIA5BAmsiDg0ACwsgCkEANgIIAkAgDUECSQ0AIAsgDUECdGpBCGsiACgCACEMIABBADYCACAKIAw2AgggACALRg0AIAVB+N8HaiIFQQJ2QQFqQQNxIgMEQCADQQJ0IQ4DQCAAQQRrIgAoAgAhAyAAIAw2AgAgCiADIAxqIgw2AgggDkEEayIODQALCyAFQQxJDQAgAEEQayEAA0AgAEEMaiIFKAIAIQMgBSAMNgIAIAogAyAMaiIHNgIIIABBCGoiBSgCACEDIAUgBzYCACAKIAMgB2oiBzYCCCAAQQRqIgUoAgAhAyAFIAc2AgAgCiADIAdqIgU2AgggACgCACEDIAAgBTYCACAKIAMgBWoiDDYCCCAAIAtGIABBEGshAEUNAAsLAkAgBgRAIAZBAXQhDkHUzsAAKAIAIQZB2M7AACgCACEHQQAhAANAIAQvAQAiA0GA+AFJBEAgAyANTw0DIAcgCyADQQJ0aiIFKAIAIgNNBEAgAyAHQbyCwAAQaQALIAYgA0ECdGogADYCACAFIAUoAgBBAWo2AgALIARBAmohBCAAQQFqIQAgDkECayIODQALCyANRQ0FIAsoAgAgDEcNA0EADAQLIAMgDUGsgsAAEGkACyADIA1BzILAABBpAAsgBiAEQdyBwAAQagALIApBAjYCHCAKQZyCwAA2AhggCkICNwIkIAogC61CgICAgPAChDcDOCAKIApBCGqtQoCAgIDwAoQ3AzAgCiAKQTBqNgIgIApBDGoiBiAKQRhqEDcjAEEgayIEJAAgBEEIaiEDIwBBIGsiBSQAAkACQAJAAkACQAJAQYjPwAAtAAAOAgABAgtBiM/AAEEBOgAACyADQQE2AgAMAQtBic/AAC0AACEAQYnPwABBAToAACAFIAA6AAcgAEEBRg0BIANBADoAFCADQQA2AgBBic/AAEEAOgAACyAFQSBqJAAMAQsgBUIANwIUIAVCgYCAgMAANwIMIAVB4JTAADYCCCAFQQdqIAVBCGoQfwALAn9B/c7AAC0AABpBKEEEEKYBIgAEQCAAQaCBwAA2AgAgACADKQIANwIEIAAgBikCADcCHCAAQQxqIANBCGopAgA3AgAgAEEUaiADQRBqKQIANwIAIABBJGogBkEIaigCADYCACAADAELQQRBKBDEAQALIQwgBEEgaiQAQQELIQAgCSAMNgIEIAkgADYCACAKQUBrJAAMAQtBAEEAQeyBwAAQaQALIAgoAgwhCSAIKAIIDQIgCUUNBEHYzsAAKAIAIgAgCUkNA0HUzsAAKAIAIQYgCCAIQRhqQQAgCRCxASIHNgIwIwBBIGsiACQAIAhBMGooAgAiBBDLASEDIAAgCTYCBCAAIAM2AgACQCADIAlGBEAQngEiBRCVASIDJQEgBiAJEAQhARAzIgYgASYBIAVBhAFPBEAgBRBaCyADQYQBTwRAIAMQWgsgBCAGQQAQrwEgBkGEAU8EQCAGEFoLIABBIGokAAwBCwwGCyAHQYQBSQ0EIAcQWgwECxBwAAsgBiAAQbyGwAAQagALIAggCTYCICAIQQE2AjQgCEHchsAANgIwIAhCATcCPCAIIAhBIGqtQoCAgICAA4Q3A0ggCCAIQcgAajYCOCAIQSRqIQNBACEAIAhBMGoiBigCDCEEAkACQAJAAkACQAJAAkAgBigCBA4CAAECCyAEDQFBASEHQQAhBkEBIQQMAwsgBEUNAQsgAyAGEDcMAwsgBigCACIEKAIEIgZBAEgNASAEKAIAIQcgBkUEQEEBIQRBACEGDAELQf3OwAAtAAAaQQEhACAGQQEQpgEiBEUNAQsgBCAHIAYQPCEAIAMgBjYCCCADIAA2AgQgAyAGNgIADAELIAAgBhCUAQALIAgoAiggCCgCLBC5AQALIAkgAEHMhsAAEGoACyAIKAIcIgBBhAFPBEAgABBaC0HAzsAAQcDOwAAoAgBBAWo2AgAgCCgCGCIAQYQBTwRAIAAQWgsgCCgCFCIAQYQBTwRAIAAQWgsgCEHQAGokACAJDAELIABBADYCCCAAIABBBGogAEEIahB+AAsLGgEBfyAAKAIAIgEEQCAAKAIEIAFBARCwAQsLFAAgASABIAAgACABXRsgACAAXBsLHAAgAEEANgIQIABCADcCCCAAQoCAgIDAADcCAAtGACAARQRAIwBBIGsiACQAIABBADYCGCAAQQE2AgwgAEH8qcAANgIIIABCBDcCECAAQQhqQZiqwAAQhAEACyAAIAEQxAEACxYBAW8gACUBEAAhARAzIgAgASYBIAALFgAgAEG4gMAANgIEIAAgAUEcajYCAAvWBgEGfwJ/AkACQAJAAkACQCAAQQRrIgUoAgAiBkF4cSIEQQRBCCAGQQNxIgcbIAFqTwRAIAdBACABQSdqIgkgBEkbDQECQAJAIAJBCU8EQCACIAMQNSIIDQFBAAwJCyADQcz/e0sNAUEQIANBC2pBeHEgA0ELSRshAQJAIAdFBEAgAUGAAkkgBCABQQRySXIgBCABa0GBgAhPcg0BDAkLIABBCGsiAiAEaiEHAkACQAJAAkAgASAESwRAIAdBzNLAACgCAEYNBCAHQcjSwAAoAgBGDQIgBygCBCIGQQJxDQUgBkF4cSIGIARqIgQgAUkNBSAHIAYQOyAEIAFrIgNBEEkNASAFIAEgBSgCAEEBcXJBAnI2AgAgASACaiIBIANBA3I2AgQgAiAEaiICIAIoAgRBAXI2AgQgASADEDAMDQsgBCABayIDQQ9LDQIMDAsgBSAEIAUoAgBBAXFyQQJyNgIAIAIgBGoiASABKAIEQQFyNgIEDAsLQcDSwAAoAgAgBGoiBCABSQ0CAkAgBCABayIDQQ9NBEAgBSAGQQFxIARyQQJyNgIAIAIgBGoiASABKAIEQQFyNgIEQQAhA0EAIQEMAQsgBSABIAZBAXFyQQJyNgIAIAEgAmoiASADQQFyNgIEIAIgBGoiAiADNgIAIAIgAigCBEF+cTYCBAtByNLAACABNgIAQcDSwAAgAzYCAAwKCyAFIAEgBkEBcXJBAnI2AgAgASACaiIBIANBA3I2AgQgByAHKAIEQQFyNgIEIAEgAxAwDAkLQcTSwAAoAgAgBGoiBCABSw0HCyADEBEiAUUNASABIABBfEF4IAUoAgAiAUEDcRsgAUF4cWoiASADIAEgA0kbEDwgABAlDAgLIAggACABIAMgASADSRsQPBogBSgCACICQXhxIgMgAUEEQQggAkEDcSICG2pJDQMgAkEAIAMgCUsbDQQgABAlCyAIDAYLQe2RwABBLkGcksAAEHgAC0GsksAAQS5B3JLAABB4AAtB7ZHAAEEuQZySwAAQeAALQaySwABBLkHcksAAEHgACyAFIAEgBkEBcXJBAnI2AgAgASACaiICIAQgAWsiAUEBcjYCBEHE0sAAIAE2AgBBzNLAACACNgIAIAAMAQsgAAsLGQAgASgCFEGGrMAAQQ4gASgCGCgCDBEBAAsWACAAKAIUIAEgAiAAKAIYKAIMEQEACxQAIAAoAgAgASAAKAIEKAIQEQAACxQAIAAoAgAgASAAKAIEKAIMEQAACxQAIAAoAhQgASAAKAIYKAIQEQAAC84IAQV/IwBB8ABrIgUkACAFIAM2AgwgBSACNgIIAkACQAJAAkACQAJAAn8gAAJ/AkAgAUGBAk8EQEEDIAAsAIACQb9/Sg0CGiAALAD/AUG/f0wNAUECDAILIAUgATYCFCAFIAA2AhBBAQwCCyAALAD+AUG/f0oLQf0BaiIGaiwAAEG/f0wNASAFIAY2AhQgBSAANgIQQQUhB0HJtsAACyEGIAUgBzYCHCAFIAY2AhggASACSSIHIAEgA0lyRQRAIAIgA0sNAiACRSABIAJNckUEQCAFQQxqIAVBCGogACACaiwAAEG/f0obKAIAIQMLIAUgAzYCICADIAEiAkkEQCADQQFqIgggA0EDayICQQAgAiADTRsiAkkNBAJAIAIgCEYNACAIIAJrIQcgACADaiwAAEG/f0oEQCAHQQFrIQYMAQsgAiADRg0AIAAgCGoiA0ECayIJLAAAQb9/SgRAIAdBAmshBgwBCyAJIAAgAmoiCEYNACADQQNrIgksAABBv39KBEAgB0EDayEGDAELIAggCUYNACADQQRrIgMsAABBv39KBEAgB0EEayEGDAELIAMgCEYNACAHQQVrIQYLIAIgBmohAgsCQCACRQ0AIAEgAksEQCAAIAJqLAAAQb9/Sg0BDAcLIAEgAkcNBgsgASACRg0EAn8CQAJAIAAgAmoiASwAACIAQQBIBEAgAS0AAUE/cSEGIABBH3EhAyAAQV9LDQEgA0EGdCAGciEADAILIAUgAEH/AXE2AiRBAQwCCyABLQACQT9xIAZBBnRyIQYgAEFwSQRAIAYgA0EMdHIhAAwBCyADQRJ0QYCA8ABxIAEtAANBP3EgBkEGdHJyIgBBgIDEAEYNBgsgBSAANgIkQQEgAEGAAUkNABpBAiAAQYAQSQ0AGkEDQQQgAEGAgARJGwshACAFIAI2AiggBSAAIAJqNgIsIAVBBTYCNCAFQdS3wAA2AjAgBUIFNwI8IAUgBUEYaq1CgICAgJAMhDcDaCAFIAVBEGqtQoCAgICQDIQ3A2AgBSAFQShqrUKAgICAsAyENwNYIAUgBUEkaq1CgICAgMAMhDcDUCAFIAVBIGqtQoCAgIDwAoQ3A0gMBgsgBSACIAMgBxs2AiggBUEDNgI0IAVBlLjAADYCMCAFQgM3AjwgBSAFQRhqrUKAgICAkAyENwNYIAUgBUEQaq1CgICAgJAMhDcDUCAFIAVBKGqtQoCAgIDwAoQ3A0gMBQsgACABQQAgBiAEEJ0BAAsgBUEENgI0IAVB9LbAADYCMCAFQgQ3AjwgBSAFQRhqrUKAgICAkAyENwNgIAUgBUEQaq1CgICAgJAMhDcDWCAFIAVBDGqtQoCAgIDwAoQ3A1AgBSAFQQhqrUKAgICA8AKENwNIDAMLIAIgCEHAuMAAEGsACyAEELMBAAsgACABIAIgASAEEJ0BAAsgBSAFQcgAajYCOCAFQTBqIAQQhAEACxQCAW8BfxAPIQAQMyIBIAAmASABCxMAIABBKDYCBCAAQYCAwAA2AgALEwAgAEH0gMAANgIEIAAgATYCAAsTACAAQSg2AgQgAEGMhMAANgIACyEAIABCnJzu3svC7uAnNwMIIABCtJOr5e2OzP6efzcDAAsiACAAQvLlnerun8WVjn83AwggAEKIoIuQ+YC1oqF/NwMACxAAIAAoAgQgACgCCCABEBwLEQAgACgCBCAAKAIIIAEQxgELGQACfyABQQlPBEAgASAAEDUMAQsgABARCwsiACAAQu26rbbNhdT14wA3AwggAEL4gpm9le7Gxbl/NwMACyAAIABC2KGkg7Hi0d18NwMIIABCldfdmMOXiowLNwMACxEAIAAoAgAgACgCBCABEMYBCxMAIABBtJbAADYCBCAAIAE2AgALEQAgASAAKAIAIAAoAgQQmQELEAAgACgCACAAKAIEIAEQHAsQACABIAAoAgAgACgCBBAeCxAAIAEoAhQgASgCGCAAECkLDgAgACUBIAElASACEAYLXwEBfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABAlDAILQe2RwABBLkGcksAAEHgAC0GsksAAQS5B3JLAABB4AAsLHQEBbyAAKAIAJQEgASACEAwhAxAzIgAgAyYBIAALCwAgACgCACABEEILDgBBuazAAEErIAAQeAALyQICBH8CfiAAKQMAIQYjAEEgayIDJABBFCEAAkAgBkKQzgBUBEAgBiEHDAELA0AgA0EMaiAAaiICQQRrIAYgBkKQzgCAIgdCkM4Afn2nIgRB//8DcUHkAG4iBUEBdEGer8AAai8AADsAACACQQJrIAQgBUHkAGxrQf//A3FBAXRBnq/AAGovAAA7AAAgAEEEayEAIAZC/8HXL1YgByEGDQALCwJAIAdC4wBYBEAgB6chAgwBCyAAQQJrIgAgA0EMamogB6ciAiACQf//A3FB5ABuIgJB5ABsa0H//wNxQQF0QZ6vwABqLwAAOwAACwJAIAJBCk8EQCAAQQJrIgAgA0EMamogAkEBdEGer8AAai8AADsAAAwBCyAAQQFrIgAgA0EMamogAkEwcjoAAAsgAUEBQQAgA0EMaiAAakEUIABrECEgA0EgaiQACw0AIABB/IjAACABECkLDgAgAUGUicAAQQUQmQELpwMCB38BfiAAKAIAIQAjAEHQAGsiAiQAIAJBIGogACAAKAIAKAIEEQIAIAIgAkHIAGqtQoCAgICABIQ3AyhBASEDIAJBATYCNCACQcSLwAA2AjAgAkIBNwI8IAIgAikDIDcCSCACIAJBKGo2AjgCQCABKAIUIgcgASgCGCIIIAJBMGoQKQ0AIAEtABxBBHFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBKGqtQoCAgICABIQhCSACKAIcIQQgAigCGCEFQQAhAEEBIQYDQAJAIABBAXEEQCAEIQEgBSEADAELIAUhACAEIQEDQCAARQRAQQAhAwwECyACQRBqIAAgASgCGBECACACKAIUIQEgAigCECEAIAZBAWsiBg0ACwsgAEEARyEDIABFDQEgAkEIaiAAIAEoAhgRAgAgAigCDCEEIAIoAgghBSACIAE2AiwgAiAANgIoQQEhACACQQE2AjQgAkHQi8AANgIwIAJCATcCPCACIAk3A0ggAiACQcgAajYCOEEAIQYgByAIIAJBMGoQKUUNAAsLIAJB0ABqJAAgAwsNACAAQeSNwAAgARApCwkAIAAgARAOAAspAAJ/IAAoAgAtAABFBEAgAUH5sMAAQQUQHgwBCyABQf6wwABBBBAeCwsNACAAQayRwAAgARApC+4BAQZ/An8gACgCACECIwBBgAFrIgQkACABKAIEIQcgASgCACEGIAEoAhwiBSEAAkAgBUEEcUUNACAFQQhyIQAgBg0AIAFCgYCAgKABNwIACyABIABBBHI2AhxBACEAA0AgACAEakH/AGogAkEPcSIDQTByIANB1wBqIANBCkkbOgAAIABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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"},961:(t,A)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.elapsed=function(t,A){if(void 0===A&&(A=new Error("changed").stack),void 0===A)throw new Error("auto uid featured not available (missing stack)");var n=e.get(A);return void 0===n&&(n=t),n--<=0?(e.delete(A),!0):(e.set(A,n),!1)};var e=new Map},970:(t,A,e)=>{e.r(A),e.d(A,{OrbitControls:()=>u});var n=e(184);const i={type:"change"},s={type:"start"},a={type:"end"},r=new n.RlV,o=new n.Zcv,g=Math.cos(70*n.cj9.DEG2RAD),c=new n.Pq0,l=2*Math.PI,I=-1,h=1e-6;class u extends n.H2z{constructor(t,A=null){super(t,A),this.state=I,this.target=new n.Pq0,this.cursor=new n.Pq0,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:n.kBv.ROTATE,MIDDLE:n.kBv.DOLLY,RIGHT:n.kBv.PAN},this.touches={ONE:n.wtR.ROTATE,TWO:n.wtR.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new n.Pq0,this._lastQuaternion=new n.PTz,this._lastTargetPosition=new n.Pq0,this._quat=(new n.PTz).setFromUnitVectors(t.up,new n.Pq0(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new n.YHV,this._sphericalDelta=new n.YHV,this._scale=1,this._panOffset=new n.Pq0,this._rotateStart=new n.I9Y,this._rotateEnd=new n.I9Y,this._rotateDelta=new n.I9Y,this._panStart=new n.I9Y,this._panEnd=new n.I9Y,this._panDelta=new n.I9Y,this._dollyStart=new n.I9Y,this._dollyEnd=new n.I9Y,this._dollyDelta=new n.I9Y,this._dollyDirection=new n.Pq0,this._mouse=new n.I9Y,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=d.bind(this),this._onPointerDown=B.bind(this),this._onPointerUp=C.bind(this),this._onContextMenu=w.bind(this),this._onMouseWheel=p.bind(this),this._onKeyDown=f.bind(this),this._onTouchStart=m.bind(this),this._onTouchMove=y.bind(this),this._onMouseDown=E.bind(this),this._onMouseMove=Q.bind(this),this._interceptControlDown=x.bind(this),this._interceptControlUp=S.bind(this),null!==this.domElement&&this.connect(this.domElement),this.update()}connect(t){super.connect(t),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(t){t.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=t}stopListenToKeyEvents(){null!==this._domElementKeyEvents&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(i),this.update(),this.state=I}update(t=null){const A=this.object.position;c.copy(A).sub(this.target),c.applyQuaternion(this._quat),this._spherical.setFromVector3(c),this.autoRotate&&this.state===I&&this._rotateLeft(this._getAutoRotationAngle(t)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let e=this.minAzimuthAngle,s=this.maxAzimuthAngle;isFinite(e)&&isFinite(s)&&(e<-Math.PI?e+=l:e>Math.PI&&(e-=l),s<-Math.PI?s+=l:s>Math.PI&&(s-=l),this._spherical.theta=e<=s?Math.max(e,Math.min(s,this._spherical.theta)):this._spherical.theta>(e+s)/2?Math.max(e,this._spherical.theta):Math.min(s,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),!0===this.enableDamping?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let a=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const t=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),a=t!=this._spherical.radius}if(c.setFromSpherical(this._spherical),c.applyQuaternion(this._quatInverse),A.copy(this.target).add(c),this.object.lookAt(this.target),!0===this.enableDamping?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let t=null;if(this.object.isPerspectiveCamera){const A=c.length();t=this._clampDistance(A*this._scale);const e=A-t;this.object.position.addScaledVector(this._dollyDirection,e),this.object.updateMatrixWorld(),a=!!e}else if(this.object.isOrthographicCamera){const A=new n.Pq0(this._mouse.x,this._mouse.y,0);A.unproject(this.object);const e=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),a=e!==this.object.zoom;const i=new n.Pq0(this._mouse.x,this._mouse.y,0);i.unproject(this.object),this.object.position.sub(i).add(A),this.object.updateMatrixWorld(),t=c.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;null!==t&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(t).add(this.object.position):(r.origin.copy(this.object.position),r.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(r.direction))<g?this.object.lookAt(this.target):(o.setFromNormalAndCoplanarPoint(this.object.up,this.target),r.intersectPlane(o,this.target))))}else if(this.object.isOrthographicCamera){const t=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),t!==this.object.zoom&&(this.object.updateProjectionMatrix(),a=!0)}return this._scale=1,this._performCursorZoom=!1,!!(a||this._lastPosition.distanceToSquared(this.object.position)>h||8*(1-this._lastQuaternion.dot(this.object.quaternion))>h||this._lastTargetPosition.distanceToSquared(this.target)>h)&&(this.dispatchEvent(i),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0)}_getAutoRotationAngle(t){return null!==t?l/60*this.autoRotateSpeed*t:l/60/60*this.autoRotateSpeed}_getZoomScale(t){const A=Math.abs(.01*t);return Math.pow(.95,this.zoomSpeed*A)}_rotateLeft(t){this._sphericalDelta.theta-=t}_rotateUp(t){this._sphericalDelta.phi-=t}_panLeft(t,A){c.setFromMatrixColumn(A,0),c.multiplyScalar(-t),this._panOffset.add(c)}_panUp(t,A){!0===this.screenSpacePanning?c.setFromMatrixColumn(A,1):(c.setFromMatrixColumn(A,0),c.crossVectors(this.object.up,c)),c.multiplyScalar(t),this._panOffset.add(c)}_pan(t,A){const e=this.domElement;if(this.object.isPerspectiveCamera){const n=this.object.position;c.copy(n).sub(this.target);let i=c.length();i*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*t*i/e.clientHeight,this.object.matrix),this._panUp(2*A*i/e.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(t*(this.object.right-this.object.left)/this.object.zoom/e.clientWidth,this.object.matrix),this._panUp(A*(this.object.top-this.object.bottom)/this.object.zoom/e.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(t,A){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const e=this.domElement.getBoundingClientRect(),n=t-e.left,i=A-e.top,s=e.width,a=e.height;this._mouse.x=n/s*2-1,this._mouse.y=-i/a*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(t){return Math.max(this.minDistance,Math.min(this.maxDistance,t))}_handleMouseDownRotate(t){this._rotateStart.set(t.clientX,t.clientY)}_handleMouseDownDolly(t){this._updateZoomParameters(t.clientX,t.clientX),this._dollyStart.set(t.clientX,t.clientY)}_handleMouseDownPan(t){this._panStart.set(t.clientX,t.clientY)}_handleMouseMoveRotate(t){this._rotateEnd.set(t.clientX,t.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const A=this.domElement;this._rotateLeft(l*this._rotateDelta.x/A.clientHeight),this._rotateUp(l*this._rotateDelta.y/A.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(t){this._dollyEnd.set(t.clientX,t.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(t){this._panEnd.set(t.clientX,t.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(t){this._updateZoomParameters(t.clientX,t.clientY),t.deltaY<0?this._dollyIn(this._getZoomScale(t.deltaY)):t.deltaY>0&&this._dollyOut(this._getZoomScale(t.deltaY)),this.update()}_handleKeyDown(t){let A=!1;switch(t.code){case this.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateUp(l*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),A=!0;break;case this.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateUp(-l*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),A=!0;break;case this.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateLeft(l*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),A=!0;break;case this.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateLeft(-l*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),A=!0}A&&(t.preventDefault(),this.update())}_handleTouchStartRotate(t){if(1===this._pointers.length)this._rotateStart.set(t.pageX,t.pageY);else{const A=this._getSecondPointerPosition(t),e=.5*(t.pageX+A.x),n=.5*(t.pageY+A.y);this._rotateStart.set(e,n)}}_handleTouchStartPan(t){if(1===this._pointers.length)this._panStart.set(t.pageX,t.pageY);else{const A=this._getSecondPointerPosition(t),e=.5*(t.pageX+A.x),n=.5*(t.pageY+A.y);this._panStart.set(e,n)}}_handleTouchStartDolly(t){const A=this._getSecondPointerPosition(t),e=t.pageX-A.x,n=t.pageY-A.y,i=Math.sqrt(e*e+n*n);this._dollyStart.set(0,i)}_handleTouchStartDollyPan(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enablePan&&this._handleTouchStartPan(t)}_handleTouchStartDollyRotate(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enableRotate&&this._handleTouchStartRotate(t)}_handleTouchMoveRotate(t){if(1==this._pointers.length)this._rotateEnd.set(t.pageX,t.pageY);else{const A=this._getSecondPointerPosition(t),e=.5*(t.pageX+A.x),n=.5*(t.pageY+A.y);this._rotateEnd.set(e,n)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const A=this.domElement;this._rotateLeft(l*this._rotateDelta.x/A.clientHeight),this._rotateUp(l*this._rotateDelta.y/A.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(t){if(1===this._pointers.length)this._panEnd.set(t.pageX,t.pageY);else{const A=this._getSecondPointerPosition(t),e=.5*(t.pageX+A.x),n=.5*(t.pageY+A.y);this._panEnd.set(e,n)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(t){const A=this._getSecondPointerPosition(t),e=t.pageX-A.x,n=t.pageY-A.y,i=Math.sqrt(e*e+n*n);this._dollyEnd.set(0,i),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const s=.5*(t.pageX+A.x),a=.5*(t.pageY+A.y);this._updateZoomParameters(s,a)}_handleTouchMoveDollyPan(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enablePan&&this._handleTouchMovePan(t)}_handleTouchMoveDollyRotate(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enableRotate&&this._handleTouchMoveRotate(t)}_addPointer(t){this._pointers.push(t.pointerId)}_removePointer(t){delete this._pointerPositions[t.pointerId];for(let A=0;A<this._pointers.length;A++)if(this._pointers[A]==t.pointerId)return void this._pointers.splice(A,1)}_isTrackingPointer(t){for(let A=0;A<this._pointers.length;A++)if(this._pointers[A]==t.pointerId)return!0;return!1}_trackPointer(t){let A=this._pointerPositions[t.pointerId];void 0===A&&(A=new n.I9Y,this._pointerPositions[t.pointerId]=A),A.set(t.pageX,t.pageY)}_getSecondPointerPosition(t){const A=t.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[A]}_customWheelEvent(t){const A=t.deltaMode,e={clientX:t.clientX,clientY:t.clientY,deltaY:t.deltaY};switch(A){case 1:e.deltaY*=16;break;case 2:e.deltaY*=100}return t.ctrlKey&&!this._controlActive&&(e.deltaY*=10),e}}function B(t){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._isTrackingPointer(t)||(this._addPointer(t),"touch"===t.pointerType?this._onTouchStart(t):this._onMouseDown(t)))}function d(t){!1!==this.enabled&&("touch"===t.pointerType?this._onTouchMove(t):this._onMouseMove(t))}function C(t){switch(this._removePointer(t),this._pointers.length){case 0:this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(a),this.state=I;break;case 1:const A=this._pointers[0],e=this._pointerPositions[A];this._onTouchStart({pointerId:A,pageX:e.x,pageY:e.y})}}function E(t){let A;switch(t.button){case 0:A=this.mouseButtons.LEFT;break;case 1:A=this.mouseButtons.MIDDLE;break;case 2:A=this.mouseButtons.RIGHT;break;default:A=-1}switch(A){case n.kBv.DOLLY:if(!1===this.enableZoom)return;this._handleMouseDownDolly(t),this.state=1;break;case n.kBv.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=2}else{if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=0}break;case n.kBv.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=0}else{if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=2}break;default:this.state=I}this.state!==I&&this.dispatchEvent(s)}function Q(t){switch(this.state){case 0:if(!1===this.enableRotate)return;this._handleMouseMoveRotate(t);break;case 1:if(!1===this.enableZoom)return;this._handleMouseMoveDolly(t);break;case 2:if(!1===this.enablePan)return;this._handleMouseMovePan(t)}}function p(t){!1!==this.enabled&&!1!==this.enableZoom&&this.state===I&&(t.preventDefault(),this.dispatchEvent(s),this._handleMouseWheel(this._customWheelEvent(t)),this.dispatchEvent(a))}function f(t){!1!==this.enabled&&this._handleKeyDown(t)}function m(t){switch(this._trackPointer(t),this._pointers.length){case 1:switch(this.touches.ONE){case n.wtR.ROTATE:if(!1===this.enableRotate)return;this._handleTouchStartRotate(t),this.state=3;break;case n.wtR.PAN:if(!1===this.enablePan)return;this._handleTouchStartPan(t),this.state=4;break;default:this.state=I}break;case 2:switch(this.touches.TWO){case n.wtR.DOLLY_PAN:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchStartDollyPan(t),this.state=5;break;case n.wtR.DOLLY_ROTATE:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchStartDollyRotate(t),this.state=6;break;default:this.state=I}break;default:this.state=I}this.state!==I&&this.dispatchEvent(s)}function y(t){switch(this._trackPointer(t),this.state){case 3:if(!1===this.enableRotate)return;this._handleTouchMoveRotate(t),this.update();break;case 4:if(!1===this.enablePan)return;this._handleTouchMovePan(t),this.update();break;case 5:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchMoveDollyPan(t),this.update();break;case 6:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchMoveDollyRotate(t),this.update();break;default:this.state=I}}function w(t){!1!==this.enabled&&t.preventDefault()}function x(t){"Control"===t.key&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function S(t){"Control"===t.key&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}}},A={};function e(n){var i=A[n];if(void 0!==i)return i.exports;var s=A[n]={exports:{}};return t[n].call(s.exports,s,s.exports,e),s.exports}e.m=t,e.d=(t,A)=>{for(var n in A)e.o(A,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:A[n]})},e.o=(t,A)=>Object.prototype.hasOwnProperty.call(t,A),e.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.b=document.baseURI||self.location.href,(0,e(371).create)()})();
//# sourceMappingURL=launcher.js.map